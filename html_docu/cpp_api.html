<!DOCTYPE html>
<html>

<head>
  <meta content="text/html;" http-equiv="Content-Type">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" href="img/quadriga-lib-q_letter64.png" type="image/png">
  <link type="text/css" rel="stylesheet" href="style2.css">
  <title>Quadriga-Lib: C++/MEX Utility library for radio channel modelling and simulations</title>
</head>
 
<body>

  <div id="quadriga-lib_header">
    <div id="quadriga-lib_header_row">
      <div id="quadriga-lib_header_cell_logo_img">
        <a href="https://arma.sourceforge.net">
          <img id="quadriga-lib_logo_img" src="img/quadriga-lib-logo80.png" alt="armadillo" align="top" border="0">
        </a>
      </div>
      <div id="quadriga-lib_header_spacer"></div>
      <div id="quadriga-lib_header_cell_logo_txt">
        <div id="quadriga-lib_logo_img2"></div><big><big><b>Quadriga-Lib</b>
          </big><br>C++/MEX Utility library for radio channel modelling and simulations</big>
      </div>
    </div>
  </div>

  <div id="quadriga-lib_menu">
    <ul class="quadriga-lib_menu">
      <li class="quadriga-lib_menu"><a class="quadriga-lib_menu" href="index.html">About</a></li>
      <li class="quadriga-lib_menu"><a class="quadriga-lib_menu_selected" href="cpp_api.html">C++ API</a></li>
      <li class="quadriga-lib_menu"><a class="quadriga-lib_menu" href="mex_api.html">MATLAB API</a></li>
      <li class="quadriga-lib_menu"><a class="quadriga-lib_menu" href="python_api.html">Python API</a></li>
      <li class="quadriga-lib_menu"><a class="quadriga-lib_menu" href="formats.html">Data Formats</a></li>
      <li class="quadriga-lib_menu"><a class="quadriga-lib_menu" href="faq.html">Questions</a></li>
      <li class="quadriga-lib_menu"><a class="quadriga-lib_menu" href="contact.html">Contact</a></li>
      <li class="quadriga-lib_menu"><a class="quadriga-lib_menu" href="download.html">Download</a></li>
    </ul>
  </div>

  <div id="quadriga-lib_content">

      <!-- CONTENT BEGIN --><big><b>C++ API Documentation for Quadriga-Lib v0.8.4</b></big>
<br><br><br>

<b>Overview</b>
<ul>
<li><a href="#part_1">Array antenna class</a></li>
<li><a href="#part_2">Array antenna functions</a></li>
<li><a href="#part_3">Channel class</a></li>
<li><a href="#part_4">Channel functions</a></li>
<li><a href="#part_5">Miscellaneous tools</a></li>
<li><a href="#part_6">Site-Specific Simulation Tools</a></li>
</ul>
<br>
<a name="part_1"></a>
<b>Array antenna class</b>
<ul>
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tbody>
<tr><td style="padding-bottom: 10px;"><a href="#arrayant">arrayant</a></td><td style="padding-bottom: 10px;">Class for storing and manipulating array antenna models</td></tr>
<tr><td><a href="#.append">.append</a></td><td>Append elements of another antenna array</td></tr>
<tr><td><a href="#.calc_directivity_dbi">.calc_directivity_dbi</a></td><td>Calculate the directivity (in dBi) of array antenna elements</td></tr>
<tr><td><a href="#.combine_pattern">.combine_pattern</a></td><td>Calculate effective radiation patterns for array antennas</td></tr>
<tr><td><a href="#.copy_element">.copy_element</a></td><td>Creates a copy of a single array antenna element</td></tr>
<tr><td><a href="#.export_obj_file">.export_obj_file</a></td><td>Export antenna pattern geometry to Wavefront OBJ file</td></tr>
<tr><td><a href="#.interpolate">.interpolate</a></td><td>Interpolate array antenna field patterns</td></tr>
<tr><td><a href="#.qdant_write">.qdant_write</a></td><td>Write array antenna object and layout to QDANT file</td></tr>
<tr><td><a href="#.remove_zeros">.remove_zeros</a></td><td>Remove zeros from antenna pattern data</td></tr>
<tr><td><a href="#.rotate_pattern">.rotate_pattern</a></td><td>Adjust orientation of antenna patterns</td></tr>
<tr><td><a href="#.set_size">.set_size</a></td><td>Change size of antenna array object</td></tr>
<tr><td><a href="#.is_valid">.is_valid</a></td><td>Validate integrity of antenna array object</td></tr>
</tbody>
</table>
</ul>
<br>
<a name="part_2"></a>
<b>Array antenna functions</b>
<ul>
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tbody>
<tr><td><a href="#get_channels_irs">get_channels_irs</a></td><td>Calculate channel coefficients for intelligent reflective surfaces (IRS)</td></tr>
<tr><td><a href="#get_channels_planar">get_channels_planar</a></td><td>Calculate channel coefficients for planar waves</td></tr>
<tr><td><a href="#get_channels_spherical">get_channels_spherical</a></td><td>Calculate channel coefficients for spherical waves</td></tr>
<tr><td><a href="#qdant_read">qdant_read</a></td><td>Reads array antenna data from QDANT files</td></tr>
<tr><td><a href="#generate_arrayant_omni">generate_arrayant_omni</a></td><td>Generate isotropic radiator with vertical polarization</td></tr>
<tr><td><a href="#generate_arrayant_xpol">generate_arrayant_xpol</a></td><td>Generate cross-polarized isotropic radiator</td></tr>
<tr><td><a href="#generate_arrayant_dipole">generate_arrayant_dipole</a></td><td>Generate short dipole with vertical polarization</td></tr>
<tr><td><a href="#generate_arrayant_half_wave_dipole">generate_arrayant_half_wave_dipole</a></td><td>Generate half-wave dipole with vertical polarization</td></tr>
<tr><td><a href="#generate_arrayant_custom">generate_arrayant_custom</a></td><td>Generate antenna with custom 3dB beamwidth</td></tr>
<tr><td><a href="#generate_arrayant_3gpp">generate_arrayant_3gpp</a></td><td>Generate 3GPP-NR compliant antenna model</td></tr>
<tr><td><a href="#generate_arrayant_multibeam">generate_arrayant_multibeam</a></td><td>Generate a planar multi-element antenna with support for multiple beam directions.</td></tr>
</tbody>
</table>
</ul>
<br>
<a name="part_3"></a>
<b>Channel class</b>
<ul>
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tbody>
<tr><td style="padding-bottom: 10px;"><a href="#channel">channel</a></td><td style="padding-bottom: 10px;">Class for storing and managing MIMO channel data and associated metadata</td></tr>
<tr><td><a href="#.add_paths">.add_paths</a></td><td>Append new propagation paths to an existing channel snapshot</td></tr>
<tr><td><a href="#.calc_effective_path_gain">.calc_effective_path_gain</a></td><td>Calculate the effective path gain for each snapshot (in linear scale)</td></tr>
<tr><td><a href="#.write_paths_to_obj_file">.write_paths_to_obj_file</a></td><td>Export propagation paths to a Wavefront OBJ file</td></tr>
</tbody>
</table>
</ul>
<br>
<a name="part_4"></a>
<b>Channel functions</b>
<ul>
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tbody>
<tr><td><a href="#any_type_id">any_type_id</a></td><td>Get type ID and raw access from a 'std::any' object</td></tr>
<tr><td><a href="#baseband_freq_response">baseband_freq_response</a></td><td>Compute the baseband frequency response of a MIMO channel</td></tr>
<tr><td><a href="#baseband_freq_response_vec">baseband_freq_response_vec</a></td><td>Compute the baseband frequency response of multiple MIMO channels</td></tr>
<tr><td><a href="#get_hdf5_version">get_hdf5_version</a></td><td>Get the version of the linked HDF5 library</td></tr>
<tr><td><a href="#hdf5_create">hdf5_create</a></td><td>Create a new HDF5 channel file with a defined storage layout</td></tr>
<tr><td><a href="#hdf5_read_layout">hdf5_read_layout</a></td><td>Read the HDF5 channel storage layout</td></tr>
<tr><td><a href="#hdf5_write">hdf5_write</a></td><td>Write channel data to HDF5 file</td></tr>
<tr><td><a href="#hdf5_read_channel">hdf5_read_channel</a></td><td>Read a channel object from an HDF5 file</td></tr>
<tr><td><a href="#hdf5_reshape_layout">hdf5_reshape_layout</a></td><td>Reshape the storage layout of an HDF5 channel file</td></tr>
<tr><td><a href="#hdf5_read_dset">hdf5_read_dset</a></td><td>Read an unstructured dataset from an HDF5 file</td></tr>
<tr><td><a href="#hdf5_read_dset_names">hdf5_read_dset_names</a></td><td>Read names of unstructured datasets from an HDF5 file</td></tr>
<tr><td><a href="#hdf5_write_dset">hdf5_write_dset</a></td><td>Write a single unstructured dataset to an HDF5 file</td></tr>
</tbody>
</table>
</ul>
<br>
<a name="part_5"></a>
<b>Miscellaneous tools</b>
<ul>
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tbody>
<tr><td><a href="#calc_rotation_matrix">calc_rotation_matrix</a></td><td>Calculate rotation matrices from Euler angles</td></tr>
<tr><td><a href="#cart2geo">cart2geo</a></td><td>Convert Cartesian coordinates to geographic coordinates (azimuth, elevation, distance)</td></tr>
<tr><td><a href="#colormap">colormap</a></td><td>Generate colormap</td></tr>
<tr><td><a href="#geo2cart">geo2cart</a></td><td>Transform geographic (azimuth, elevation, length) to Cartesian coordinates</td></tr>
<tr><td><a href="#interp_1d / interp_2d">interp_1d / interp_2d</a></td><td>Perform linear interpolation (1D or 2D) on single or multiple data sets.</td></tr>
<tr><td><a href="#write_png">write_png</a></td><td>Write data to a PNG file</td></tr>
</tbody>
</table>
</ul>
<br>
<a name="part_6"></a>
<b>Site-Specific Simulation Tools</b>
<ul>
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tbody>
<tr><td><a href="#calc_diffraction_gain">calc_diffraction_gain</a></td><td>Calculate diffraction gain for multiple transmit and receive positions</td></tr>
<tr><td><a href="#combine_irs_coord">combine_irs_coord</a></td><td>Combine path interaction coordinates for channels with intelligent reflective surfaces (IRS)</td></tr>
<tr><td><a href="#coord2path">coord2path</a></td><td>Convert path interaction coordinates into FBS/LBS positions, path length and angles</td></tr>
<tr><td><a href="#generate_diffraction_paths">generate_diffraction_paths</a></td><td>Generate propagation paths for estimating the diffraction gain</td></tr>
<tr><td><a href="#icosphere">icosphere</a></td><td>Construct a geodesic polyhedron (icosphere) from triangles</td></tr>
<tr><td><a href="#mitsuba_xml_file_write">mitsuba_xml_file_write</a></td><td>Write geometry and material data to a Mitsuba 3 XML scene file.</td></tr>
<tr><td><a href="#obj_file_read">obj_file_read</a></td><td>Read Wavefront `.obj` file and extract geometry and material information</td></tr>
<tr><td><a href="#obj_overlap_test">obj_overlap_test</a></td><td>Detect overlapping 3D objects in a triangular mesh</td></tr>
<tr><td><a href="#path_to_tube">path_to_tube</a></td><td>Convert a 3D path into a tube surface for visualization</td></tr>
<tr><td><a href="#point_cloud_aabb">point_cloud_aabb</a></td><td>Compute the Axis-Aligned Bounding Boxes (AABB) of a 3D point cloud</td></tr>
<tr><td><a href="#point_cloud_segmentation">point_cloud_segmentation</a></td><td>Reorganize a point cloud into spatial sub-clouds for efficient processing</td></tr>
<tr><td><a href="#point_cloud_split">point_cloud_split</a></td><td>Split a point cloud into two sub-clouds along a spatial axis</td></tr>
<tr><td><a href="#point_inside_mesh">point_inside_mesh</a></td><td>Test whether 3D points are inside a triangle mesh using raycasting</td></tr>
<tr><td><a href="#ray_mesh_interact">ray_mesh_interact</a></td><td>Calculates interactions (reflection, transmission, refraction) of radio waves with objects</td></tr>
<tr><td><a href="#ray_point_intersect">ray_point_intersect</a></td><td>Calculates the intersection of ray beams with points in three dimensions</td></tr>
<tr><td><a href="#ray_triangle_intersect">ray_triangle_intersect</a></td><td>Calculates the intersection of rays and triangles in three dimensions</td></tr>
<tr><td><a href="#subdivide_rays">subdivide_rays</a></td><td>Subdivide ray beams into four smaller sub-beams</td></tr>
<tr><td><a href="#subdivide_triangles">subdivide_triangles</a></td><td>Subdivide triangles into smaller triangles</td></tr>
<tr><td><a href="#triangle_mesh_aabb">triangle_mesh_aabb</a></td><td>Calculate the axis-aligned bounding box (AABB) of a triangle mesh and its sub-meshes</td></tr>
<tr><td><a href="#triangle_mesh_segmentation">triangle_mesh_segmentation</a></td><td>Reorganize a 3D mesh into smaller sub-meshes for faster processing</td></tr>
<tr><td><a href="#triangle_mesh_split">triangle_mesh_split</a></td><td>Split a 3D mesh into two sub-meshes along a given axis</td></tr>
</tbody>
</table>
</ul>
<br>
<div class="pagebreak"></div>
<hr class="greyline">
<hr class="greyline">
<br>
<br>
<font size=+1><b>Array antenna class</b></font>
<br>
<br>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="arrayant"></a>
<b>arrayant</b> - Class for storing and manipulating array antenna models
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">An array antenna consists of multiple individual elements. 
</li><li style="margin-bottom: 0.4em;">Each element occupies a specific position relative to the array's phase-center, its local origin. 
</li><li style="margin-bottom: 0.4em;">Elements can also be inter-coupled, represented by a coupling matrix. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Attributes:</i></b><br><table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>arma::Cube&lt;dtype&gt; e_theta_re</code></td>
  <td>Vertical component of the electric field, real part</td>
</tr>
<tr>
  <td><code>arma::Cube&lt;dtype&gt; e_theta_im</code></td>
  <td>Vertical component of the electric field, imaginary part</td>
</tr>
<tr>
  <td><code>arma::Cube&lt;dtype&gt; e_phi_re</code></td>
  <td>Horizontal component of the electric field, real part</td>
</tr>
<tr>
  <td><code>arma::Cube&lt;dtype&gt; e_phi_im</code></td>
  <td>Horizontal component of the electric field, imaginary part</td>
</tr>
<tr>
  <td><code>arma::Col&lt;dtype&gt; azimuth_grid</code></td>
  <td>Azimuth angles in pattern (theta) in [rad], between -pi and pi, sorted</td>
</tr>
<tr>
  <td><code>arma::Col&lt;dtype&gt; elevation_grid</code></td>
  <td>Elevation angles in pattern (phi) in [rad], between -pi/2 and pi/2, sorted</td>
</tr>
<tr>
  <td><code>arma::Mat&lt;dtype&gt; element_pos</code></td>
  <td>Element positions (optional), Size: Empty or [3, n_elements]</td>
</tr>
<tr>
  <td><code>arma::Mat&lt;dtype&gt; coupling_re</code></td>
  <td>Coupling matrix, real part (optional), Size: [n_elements, n_ports]</td>
</tr>
<tr>
  <td><code>arma::Mat&lt;dtype&gt; coupling_im</code></td>
  <td>Coupling matrix, imaginary part (optional), Size: [n_elements, n_ports]</td>
</tr>
<tr>
  <td><code>dtype center_frequency</code></td>
  <td>Center frequency in [Hz]</td>
</tr>
</table><br>
 
<ul><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> and <code>double</code> 
</li><li style="margin-bottom: 0.4em;"><code>e_theta_re</code>, <code>e_theta_im</code>, <code>e_phi_re</code>, <code>e_phi_im</code> must have size <code>[n_elevation, n_azimuth, n_elements]</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Example:</i></b><br><pre>
float pi = arma::datum::pi;

quadriga_lib::arrayant&lt;float&gt; ant;
ant.azimuth_grid = {-0.75f * pi, 0.0f, 0.75f * pi, pi};
ant.elevation_grid = {-0.45f * pi, 0.0f, 0.45f * pi};

arma::mat A = arma::linspace(1.0, 12.0, 12);
A.reshape(3, 4);

arma::fcube B;
B.zeros(3, 4, 1);
B.slice(0) = arma::conv_to&lt;arma::fmat&gt;::from(A);

ant.e_theta_re = B * 0.5f;
ant.e_theta_im = B * 0.002f;
ant.e_phi_re = -B;
ant.e_phi_im = -B * 0.001f;

arma::fmat C = {1.0f, 2.0f, 4.0f};
ant.element_pos = C.t();

ant.coupling_re = {1.0f};
ant.coupling_im = {0.1f};
ant.center_frequency = 2.0e9f;
ant.name = "name";
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Simple member functions:</i></b><br><table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>.n_elevation()</code></td>
  <td>Returns number of elevation angles as 64bit integer</td>
</tr>
<tr>
  <td><code>.n_azimuth()</code></td>
  <td>Returns number of azimuth angles as 64bit integer</td>
</tr>
<tr>
  <td><code>.n_elements()</code></td>
  <td>Returns number of antenna elements as 64bit integer</td>
</tr>
<tr>
  <td><code>.n_ports()</code></td>
  <td>Returns number of ports (after coupling) as 64bit integer</td>
</tr>
<tr>
  <td><code>.copy()</code></td>
  <td>Creates a copy of the array antenna object</td>
</tr>
<tr>
  <td><code>.reset()</code></td>
  <td>Reset the size to zero (the arrayant object will contain no data)</td>
</tr>
<tr>
  <td><code>.is_valid()</code></td>
  <td>Returns an empty string if arrayant object is valid or an error message otherwise</td>
</tr>
</table><br>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Complex member fuctions:</i></b><br><table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><a href="#.append">.append</a></td>
  <td>Append elements of another antenna array</td>
</tr>
<tr>
  <td><a href="#.calc_directivity_dbi">.calc_directivity_dbi</a></td>
  <td>Calculate the directivity (in dBi) of array antenna elements</td>
</tr>
<tr>
  <td><a href="#.combine_pattern">.combine_pattern</a></td>
  <td>Calculate effective radiation patterns for array antennas</td>
</tr>
<tr>
  <td><a href="#.copy_element">.copy_element</a></td>
  <td>Creates a copy of a single array antenna element</td>
</tr>
<tr>
  <td><a href="#.export_obj_file">.export_obj_file</a></td>
  <td>Export antenna pattern geometry to Wavefront OBJ file</td>
</tr>
<tr>
  <td><a href="#.interpolate">.interpolate</a></td>
  <td>Interpolate array antenna field patterns</td>
</tr>
<tr>
  <td><a href="#.qdant_write">.qdant_write</a></td>
  <td>Write array antenna object and layout to QDANT file</td>
</tr>
<tr>
  <td><a href="#.remove_zeros">.remove_zeros</a></td>
  <td>Remove zeros from antenna pattern data</td>
</tr>
<tr>
  <td><a href="#.rotate_pattern">.rotate_pattern</a></td>
  <td>Adjust orientation of antenna patterns</td>
</tr>
<tr>
  <td><a href="#.set_size">.set_size</a></td>
  <td>Change size of antenna array object</td>
</tr>
<tr>
  <td><a href="#.is_valid">.is_valid</a></td>
  <td>Validate integrity of antenna array object</td>
</tr>
</table><br>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name=".append"></a>
<b>.append</b> - Append elements of another antenna array
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Combines elements of another antenna array (<code>new_arrayant</code>) with the current antenna array object. 
</li><li style="margin-bottom: 0.4em;">Returns a new <code>arrayant</code> object containing elements from both antenna arrays. 
</li><li style="margin-bottom: 0.4em;">Throws an error if the sampling grids of the two antenna arrays do not match. 
</li><li style="margin-bottom: 0.4em;">Member function of <a href="#arrayant">arrayant</a> 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
quadriga_lib::arrayant&lt;dtype&gt; quadriga_lib::arrayant&lt;dtype&gt;::append(const arrayant&lt;dtype&gt; *new_arrayant) const;
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>const arrayant&lt;dtype&gt; *new_arrayant</code> (input)<br> 
   Pointer to an antenna array object whose elements will be added to the current object. Sampling grids must match exactly. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Returns:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>quadriga_lib::arrayant&lt;dtype&gt;</code><br> 
   A new antenna array object combining the current and new antenna elements. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Example:</i></b><br><pre>
quadriga_lib::arrayant&lt;double&gt; ant1 = quadriga_lib::generate_arrayant_custom&lt;double&gt;(90.0, 90.0, 0.0);
quadriga_lib::arrayant&lt;double&gt; ant2 = quadriga_lib::generate_arrayant_custom&lt;double&gt;(120.0, 60.0, 0.0);
quadriga_lib::arrayant&lt;double&gt; combined_ant = ant1.append(&amp;ant2);
</pre>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name=".calc_directivity_dbi"></a>
<b>.calc_directivity_dbi</b> - Calculate the directivity (in dBi) of array antenna elements
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Member function of <a href="#arrayant">arrayant</a> 
</li><li style="margin-bottom: 0.4em;">Directivity is a parameter of an antenna or which measures the degree to which the radiation emitted 
   is concentrated in a single direction. It is the ratio of the radiation intensity in a given direction 
   from the antenna to the radiation intensity averaged over all directions. Therefore, the directivity 
   of a hypothetical isotropic radiator is 1, or 0 dBi. 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
dtype quadriga_lib::arrayant&lt;dtype&gt;::calc_directivity_dBi(arma::uword i_element) const;
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>arma::uword <b>i_element</b></code><br> 
   Element index, 0-based<br> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Example:</i></b><br><pre>
auto ant = quadriga_lib::generate_arrayant_dipole&lt;float&gt;();
float directivity = ant.calc_directivity_dBi( 0 );
</pre>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name=".combine_pattern"></a>
<b>.combine_pattern</b> - Calculate effective radiation patterns for array antennas
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Member function of <a href="#arrayant">arrayant</a> 
</li><li style="margin-bottom: 0.4em;">By integrating element radiation patterns, element positions, and the coupling weights, one can 
   determine an effective radiation pattern observable by a receiver in the antenna's far field. 
</li><li style="margin-bottom: 0.4em;">Leveraging these effective patterns is especially beneficial in antenna design, beamforming 
   applications such as in 5G systems, and in planning wireless communication networks in complex 
   environments like urban areas. This streamlined approach offers a significant boost in computation 
   speed when calculating MIMO channel coefficients, as it reduces the number of necessary operations. 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> and <code>double</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
quadriga_lib::arrayant&lt;dtype&gt; quadriga_lib::arrayant&lt;dtype&gt;::combine_pattern(
                const arma::Col&lt;dtype&gt; *azimuth_grid_new = nullptr,
                const arma::Col&lt;dtype&gt; *elevation_grid_new = nullptr) const;
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>arma::Col&lt;dtype&gt; <b>*azimuth_grid_new</b></code> (optional)<br> 
   Azimuth angle grid of the output array antenna in [rad], between -pi and pi, sorted 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Col&lt;dtype&gt; <b>*elevation_grid_new</b></code> (optional)<br> 
   Elevation angle grid of the output array antenna in [rad], between -pi/2 and pi/2, sorted 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Example:</i></b><br><pre>
auto ant = quadriga_lib::generate_arrayant_omni&lt;double&gt;();  // Generate omni antenna
ant.copy_element(0, 1);                                     // Duplicate the first element
ant.element_pos.row(1) = {-0.25, 0.25};                     // Set element positions (in lambda)
ant.coupling_re.ones(2, 1);                                 // Set coupling matrix (real part)
ant.coupling_im.reset();                                    // Remove imaginary part
ant = ant.combine_pattern();                                // Calculate the combined pattern
</pre>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name=".copy_element"></a>
<b>.copy_element</b> - Creates a copy of a single array antenna element
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Member function of <a href="#arrayant">arrayant</a> 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> and <code>double</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
void quadriga_lib::arrayant&lt;dtype&gt;::copy_element(arma::uword source, arma::uvec destination);

void quadriga_lib::arrayant&lt;dtype&gt;::copy_element(arma::uword source, arma::uword destination);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>arma::uword <b>source</b></code> (optional)<br> 
   Index of the source element (0-based) 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::uvec <b>destination</b></code> or <code>arma::uword <b>destination</b></code><br> 
   Index of the destinations element (0-based), either as a vector or as a scalar. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Example:</i></b><br><pre>
auto ant = quadriga_lib::generate_arrayant_omni&lt;double&gt;();  // Generate omni antenna
ant.copy_element(0, 1);                                     // Duplicate the first element
ant.copy_element(1, {2,3});                                 // Duplicate multiple times
</pre>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name=".export_obj_file"></a>
<b>.export_obj_file</b> - Export antenna pattern geometry to Wavefront OBJ file
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">This function exports the antenna pattern geometry to a Wavefront OBJ file, useful for visualization in 3D software such as Blender. 
</li><li style="margin-bottom: 0.4em;">Member function of <a href="#arrayant">arrayant</a> 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
void quadriga_lib::arrayant&lt;dtype&gt;::export_obj_file(
                std::string fn,
                dtype directivity_range = 30.0,
                std::string colormap = "jet",
                dtype object_radius = 1.0,
                arma::uword icosphere_n_div = 4,
                arma::uvec i_element = {}) const;
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>std::string <b>fn</b></code> (input)<br> 
   Filename of the OBJ file to which the antenna pattern will be exported. Cannot be empty. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>directivity_range</b> = 30.0</code> (optional input)<br> 
   Directivity range in decibels (dB) for visualizing the antenna pattern. This value defines the 
   dynamic range of the visualized directivity pattern. Default: <code>30.0</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>std::string <b>colormap</b> = "jet"</code> (optional input)<br> 
   Colormap used for visualizing the antenna directivity. Supported colormaps are: <code>jet</code>, 
   <code>parula</code>, <code>winter</code>, <code>hot</code>, <code>turbo</code>, <code>copper</code>, <code>spring</code>, <code>cool</code>, <code>gray</code>, <code>autumn</code>, <code>summer</code>. 
   Default: <code>"jet"</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>object_radius</b> = 1.0</code> (optional input)<br> 
   Radius of the exported antenna pattern geometry object, specified in meters. Default: <code>1.0</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::uword <b>icosphere_n_div</b> = 4</code> (optional input)<br> 
   Number of subdivisions used to map the antenna pattern onto an icosphere. Higher values yield finer 
   mesh resolution. Default: <code>4</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::uvec <b>i_element</b> = {}</code> (optional input)<br> 
   Antenna element indices for which the pattern geometry is exported. Indices are 0-based. Providing 
   an empty vector <code>{}</code> (default) exports the geometry for all elements of the antenna array. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Example:</i></b><br><pre>
auto ant = quadriga_lib::generate_arrayant_custom&lt;double&gt;(90.0, 90.0, 0.0);
ant.export_obj_file("antenna_pattern.obj", 40.0, "turbo", 1.5, 5);
</pre>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name=".interpolate"></a>
<b>.interpolate</b> - Interpolate array antenna field patterns
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">This function interpolates polarimetric antenna field patterns for a given set of azimuth and 
   elevation angles. 
</li><li style="margin-bottom: 0.4em;">Member function of <a href="#arrayant">arrayant</a> 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
void quadriga_lib::arrayant&lt;dtype&gt;::interpolate(
                const arma::Mat&lt;dtype&gt; *azimuth,
                const arma::Mat&lt;dtype&gt; *elevation,
                arma::Mat&lt;dtype&gt; *V_re, arma::Mat&lt;dtype&gt; *V_im,
                arma::Mat&lt;dtype&gt; *H_re, arma::Mat&lt;dtype&gt; *H_im,
                arma::uvec i_element,
                const arma::Cube&lt;dtype&gt; *orientation,
                const arma::Mat&lt;dtype&gt; *element_pos_i,
                arma::Mat&lt;dtype&gt; *dist,
                arma::Mat&lt;dtype&gt; *azimuth_loc, arma::Mat&lt;dtype&gt; *elevation_loc,
                arma::Mat&lt;dtype&gt; *gamma) const;
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*azimuth</b></code> (input)<br> 
   Azimuth angles in [rad] for which the field pattern should be interpolated. Values must be 
   between -pi and pi, cannot be NULL 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td>Option 1:</td>
  <td>Use the same angles for all antenna elements (planar wave approximation)</td>
</tr>
<tr>
  <td></td>
  <td>Size: <code>[1, n_ang]</code></td>
</tr>
<tr>
  <td>Option 2:</td>
  <td>Provide different angles for each array element (e.g. for spherical waves)</td>
</tr>
<tr>
  <td></td>
  <td>Size: <code>[n_out, n_ang]</code></td>
</tr>
</table><br>
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*elevation</b></code> (input)<br> 
   Elevation angles in [rad] for which the field pattern should be interpolated. Values must be 
   between -pi/2 and pi/2, cannot be NULL 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td>Option 1:</td>
  <td>Use the same angles for all antenna elements (planar wave approximation)</td>
</tr>
<tr>
  <td></td>
  <td>Size: <code>[1, n_ang]</code></td>
</tr>
<tr>
  <td>Option 2:</td>
  <td>Provide different angles for each array element (e.g. for spherical waves)</td>
</tr>
<tr>
  <td></td>
  <td>Size: <code>[n_out, n_ang]</code></td>
</tr>
</table><br>
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt; <b>*V_re</b></code> (output)<br> 
   Real part of the interpolated e-theta (vertical) field component, Size <code>[n_out, n_ang]</code>, 
   will be resized if it does not match the required size (invalidates data pointers), cannot be NULL 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt; <b>*V_im</b></code> (output)<br> 
   Imaginary part of the interpolated e-theta (vertical) field component, Size <code>[n_out, n_ang]</code> 
   will be resized if it does not match the required size (invalidates data pointers), cannot be NULL 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt; <b>*H_re</b></code> (output)<br> 
   Real part of the interpolated e-phi (horizontal) field component, Size <code>[n_out, n_ang]</code> 
   will be resized if it does not match the required size (invalidates data pointers), cannot be NULL 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt; <b>*H_im</b></code> (output)<br> 
   Imaginary part of the interpolated e-phi (horizontal) field component, Size <code>[n_out, n_ang]</code> 
   will be resized if it does not match the required size (invalidates data pointers), cannot be NULL 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::uvec <b>i_element</b> = {}</code> (optional input)<br> 
   The element indices for which the interpolation should be done, optional argument, 
   values must be between 1 and <code>n_elements</code>. It is possible to duplicate elements, i.e. by passing 
   <code>{1,1,2}</code>. If this parameter is not provided (or an empty array is passed), <code>i_element</code> is initialized 
   to include all elements of the array antenna. In this case, <code>n_out = n_elements</code>, 
   Length: <code>n_out</code> or  empty <code>{}</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Cube&lt;dtype&gt; <b>*orientation</b> = nullptr</code> (optional input)<br> 
   This (optional) 3-element vector allows for setting orientation of the array antenna or 
   of individual elements using Euler angles (bank, tilt, heading); values must be given in [rad]; 
   By default, the orientation is <code>{0,0,0}</code>, i.e. the broadside of the antenna points at the horizon 
   towards the East. Sizes: <code>nullptr</code> (use default), <code>[3, 1]</code> (set orientation for entire array), 
   <code>[3, n_out]</code> (set orientation for individual elements), or <code>[3, 1, n_ang]</code> (set orientation for 
   individual angles) or <code>[3, n_out, n_ang]</code> (set orientation for individual elements and angles) 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*element_pos_i</b> = nullptr</code> (optional input)<br> 
   Positions of the array antenna elements in local cartesian coordinates (using units 
   of [m]). If this parameter is not given, the element positions from the <code>arrayant</code> object are used. 
   Sizes: <code>nullptr</code> (use <code>arrayant.element_pos</code>), <code>[3, n_out]</code> (set alternative positions) 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt; <b>*dist</b> = nullptr</code> (optional output)<br> 
   The effective distances between the antenna elements when seen from the direction 
   of the incident path. The distance is calculated by an projection of the array positions on the normal 
   plane of the incident path. This is needed for calculating the phase of the antenna response. 
   Size: <code>nullptr</code> (do not calculate this) or <code>[n_out, n_ang]</code> (argument be resized if it does not already 
   match this size) 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt; <b>*azimuth_loc</b> = nullptr</code> (optional output)<br> 
   The azimuth angles in [rad] for the local antenna coordinate system, i.e., after 
   applying the <code>orientation</code>. If no orientation vector is given, these angles are identical to the input 
   azimuth angles. Size: <code>nullptr</code> or <code>[n_out, n_ang]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt; <b>*elevation_loc</b> = nullptr</code> (optional output)<br> 
   The elevation angles in [rad] for the local antenna coordinate system, i.e., after 
   applying the <code>orientation</code>. If no orientation vector is given, these angles are identical to the input 
   elevation angles. Size: <code>nullptr</code> or <code>[n_out, n_ang]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt; <b>*gamma</b> = nullptr</code> (optional output)<br> 
   Polarization rotation angles in [rad]. Size: <code>nullptr</code> or <code>[n_out, n_ang]</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Example:</i></b><br><pre>
double pi = arma::datum::pi;

// Directional antenna, pointing east
auto ant = quadriga_lib::generate_arrayant_custom&lt;double&gt;(90.0, 90.0, 0.0);

arma::mat azimuth = {0.0, 0.5 * pi, -0.5 * pi, pi};     // Azimuth angles: East, North, South, West
arma::mat elevation(1, azimuth.n_elem);                 // Initialize to 0
arma::mat V_re, V_im, H_re, H_im;                       // Output variables (uninitialized)
ant.interpolate(&amp;azimuth, &amp;elevation, &amp;V_re, &amp;V_im, &amp;H_re, &amp;H_im);
V_re.print();
</pre>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name=".qdant_write"></a>
<b>.qdant_write</b> - Write array antenna object and layout to QDANT file
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">This function writes array antenna patterns and their layout into the QuaDRiGa array antenna exchange 
   format (QDANT), an XML-based file format 
</li><li style="margin-bottom: 0.4em;">Multiple array antennas can be stored in the same file using the <code>id</code> parameter. 
</li><li style="margin-bottom: 0.4em;">If writing to an exisiting file without specifying an <code>id</code>, the data gests appended at the end. 
   The output <code>id_in_file</code> identifies the location inside the file. 
</li><li style="margin-bottom: 0.4em;">An optional storage <code>layout</code> can be provided to organize data inside the file. 
</li><li style="margin-bottom: 0.4em;">Member function of <a href="#arrayant">arrayant</a> 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
unsigned quadriga_lib::arrayant&lt;dtype&gt;::qdant_write(
                std::string fn,
                unsigned id = 0,
                arma::u32_mat layout = {}) const;
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>std::string <b>fn</b></code> (input)<br> 
   Filename of the QDANT file to write the antenna pattern data. Cannot be empty. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>unsigned <b>id</b> = 0</code> (optional input)<br> 
   ID of the antenna to write into the file. If not provided or set to <code>0</code>, the antenna pattern is appended with a new ID equal to the maximum existing ID in the file plus one. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::u32_mat <b>layout</b> = {}</code> (optional input)<br> 
   Layout specifying the organization of multiple antenna elements inside the file. This matrix must only contain element IDs present within the file. Default: empty matrix <code>{}</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Returns:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>unsigned</code><br> 
   Returns the ID assigned to the antenna pattern within the file after writing. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Example:</i></b><br><pre>
quadriga_lib::arrayant&lt;double&gt; ant = quadriga_lib::generate_arrayant_custom&lt;double&gt;(90.0, 90.0, 0.0);
unsigned ant_id = ant.qdant_write("antenna_data.qdant");
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>See also:</i></b><br><ul><li style="margin-bottom: 0.4em;"><a href="#arrayant">arrayant</a> 
</li><li style="margin-bottom: 0.4em;"><a href="#qdant_read">qdant_read</a> 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name=".remove_zeros"></a>
<b>.remove_zeros</b> - Remove zeros from antenna pattern data
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">This function removes zeros from the antenna pattern data, altering its size accordingly. 
</li><li style="margin-bottom: 0.4em;">If called without an argument, the function modifies the antenna array properties in place. 
</li><li style="margin-bottom: 0.4em;">Member function of <a href="#arrayant">arrayant</a> 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
void quadriga_lib::arrayant&lt;dtype&gt;::remove_zeros(arrayant&lt;dtype&gt; *output = nullptr);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>arrayant&lt;dtype&gt; <b>*output</b> = nullptr</code> (optional output)<br> 
   Pointer to an antenna array object where the modified pattern data is should be written to. If set 
   to <code>nullptr</code> (default), the modifications are applied directly to the calling antenna object. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Example:</i></b><br><pre>
auto ant = quadriga_lib::generate_arrayant_custom&lt;double&gt;(90.0, 90.0, 0.0);
ant.remove_zeros(); // Modifies ant in-place
</pre>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name=".rotate_pattern"></a>
<b>.rotate_pattern</b> - Adjust orientation of antenna patterns
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>* Adjusts the orientation of antenna radiation patterns by performing precise rotations around the 
  three principal axes (x, y, z) of the local Cartesian coordinate system (Euler rotations) 
* Transforms both uniformly and non-uniformly sampled antenna patterns, useful for precise adjustments 
  in antennas like parabolic antennas with small apertures. 
* Member function of <a href="#arrayant">arrayant</a> 
* Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
void quadriga_lib::arrayant&lt;dtype&gt;::rotate_pattern(
                dtype x_deg = 0.0,
                dtype y_deg = 0.0,
                dtype z_deg = 0.0,
                unsigned usage = 0,
                unsigned element = -1,
                arrayant&lt;dtype&gt; *output = nullptr);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>dtype <b>x_deg</b> = 0.0</code> (optional input)<br> 
   Rotation angle around the x-axis (bank angle), specified in degrees. Default: <code>0.0</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>y_deg</b> = 0.0</code> (optional input)<br> 
   Rotation angle around the y-axis (tilt angle), specified in degrees. Default: <code>0.0</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>z_deg</b> = 0.0</code> (optional input)<br> 
   Rotation angle around the z-axis (heading angle), specified in degrees. Default: <code>0.0</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>unsigned <b>usage</b> = 0</code> (optional input)<br> 
   Rotation usage model, specifying which components to rotate: (<code>0</code>): Rotate both pattern and polarization, 
   (<code>1</code>): Rotate only pattern, (<code>2</code>): Rotate only polarization, (<code>3</code>): Rotate both pattern and polarization without adjusting the grid 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>unsigned <b>element</b> = -1</code> (optional input)<br> 
   Index of the antenna element (0-based) to rotate. Default (<code>-1</code>) applies rotation to all elements. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arrayant&lt;dtype&gt; <b>output</b> = nullptr</code> (optional output)<br> 
   Pointer to an antenna array object to store the modified pattern data. If <code>nullptr</code> (default), modifications are applied directly to the calling antenna object. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Example:</i></b><br><pre>
auto ant = quadriga_lib::generate_arrayant_custom&lt;double&gt;(90.0, 90.0, 0.0);
ant.rotate_pattern(0.0, 0.0, 45.0);
</pre>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name=".set_size"></a>
<b>.set_size</b> - Change size of antenna array object
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Changes the size of an antenna array (<code>arrayant</code>) without explicitly preserving existing data. 
</li><li style="margin-bottom: 0.4em;">Resets <code>element_pos</code> to zero and sets <code>coupling_re</code> and <code>coupling_im</code> to identity matrices. 
</li><li style="margin-bottom: 0.4em;">Other properties may contain undefined or garbage data after resizing 
</li><li style="margin-bottom: 0.4em;">Size update is performed only if the existing size differs from the specified new size 
</li><li style="margin-bottom: 0.4em;">Function returns an error if the antenna object is marked as read-only 
</li><li style="margin-bottom: 0.4em;">Member function of <a href="#arrayant">arrayant</a> 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
void quadriga_lib::arrayant&lt;dtype&gt;::set_size(
                arma::uword n_elevation,
                arma::uword n_azimuth,
                arma::uword n_elements,
                arma::uword n_ports);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>arma::uword <b>n_elevation</b></code> (input)<br> 
   Number of elevation angles to resize to. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::uword <b>n_azimuth</b></code> (input)<br> 
   Number of azimuth angles to resize to. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::uword <b>n_elements</b></code> (input)<br> 
   Number of antenna elements in the array after resizing. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::uword <b>n_ports</b></code> (input)<br> 
   Number of ports (after coupling of elements) in the resized antenna array. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Example:</i></b><br><pre>
quadriga_lib::arrayant&lt;double&gt; ant;
ant.set_size(180, 360, 4, 2);
</pre>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name=".is_valid"></a>
<b>.is_valid</b> - Validate integrity of antenna array object
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Checks the integrity of an antenna array (<code>arrayant</code>) object. 
</li><li style="margin-bottom: 0.4em;">Returns an empty string if the antenna object is valid. 
</li><li style="margin-bottom: 0.4em;">Provides an error message describing any issue if the object is invalid. 
</li><li style="margin-bottom: 0.4em;">A quick integrity check can be performed for efficiency. 
</li><li style="margin-bottom: 0.4em;">Member function of <a href="#arrayant">arrayant</a> 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
std::string quadriga_lib::arrayant&lt;dtype&gt;::is_valid(bool quick_check = true) const;
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>bool <b>quick_check</b> = true</code> (optional input)<br> 
   If set to <code>true</code> (default), performs a quick validation check. Setting it to <code>false</code> performs a more thorough validation. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Returns:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>std::string</code><br> 
   Returns an empty string (<code>""</code>) if the antenna object passes the integrity check; otherwise, returns an error message detailing the issue. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Example:</i></b><br><pre>
quadriga_lib::arrayant&lt;double&gt; ant;
std::string result = ant.is_valid();
if(result.empty()) {
    std::cout &lt;&lt; "Antenna array is valid." &lt;&lt; std::endl;
} else {
    std::cout &lt;&lt; "Error: " &lt;&lt; result &lt;&lt; std::endl;
}
</pre>
</li>
</ul>
<div class="pagebreak"></div>
<hr class="greyline">
<hr class="greyline">
<br>
<br>
<font size=+1><b>Array antenna functions</b></font>
<br>
<br>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="get_channels_irs"></a>
<b>get_channels_irs</b> - Calculate channel coefficients for intelligent reflective surfaces (IRS)
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Calculates MIMO channel coefficients and delays for IRS-assisted communication using two channel segments: 
   1. TX → IRS; 2. IRS → RX 
</li><li style="margin-bottom: 0.4em;">The IRS is modeled as a passive antenna array with phase shifts defined via its coupling matrix. 
</li><li style="margin-bottom: 0.4em;">IRS codebook entries can be selected via a port index (<code>i_irs</code>). 
</li><li style="margin-bottom: 0.4em;">Supports combining paths from both segments to form <code>n_path_irs</code> valid output paths, subject to a gain threshold. 
</li><li style="margin-bottom: 0.4em;">Optional second IRS array allows different antenna behavior for TX-IRS and IRS-RX directions. 
</li><li style="margin-bottom: 0.4em;">Returns a boolean vector indicating which path combinations are included in the output. 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
std::vector&lt;bool&gt; quadriga_lib::get_channels_irs(
                const arrayant&lt;dtype&gt; *tx_array,
                const arrayant&lt;dtype&gt; *rx_array,
                const arrayant&lt;dtype&gt; *irs_array,
                dtype Tx, dtype Ty, dtype Tz,
                dtype Tb, dtype Tt, dtype Th,
                dtype Rx, dtype Ry, dtype Rz,
                dtype Rb, dtype Rt, dtype Rh,
                dtype Ix, dtype Iy, dtype Iz,
                dtype Ib, dtype It, dtype Ih,
                const arma::Mat&lt;dtype&gt; *fbs_pos_1,
                const arma::Mat&lt;dtype&gt; *lbs_pos_1,
                const arma::Col&lt;dtype&gt; *path_gain_1,
                const arma::Col&lt;dtype&gt; *path_length_1,
                const arma::Mat&lt;dtype&gt; *M_1,
                const arma::Mat&lt;dtype&gt; *fbs_pos_2,
                const arma::Mat&lt;dtype&gt; *lbs_pos_2,
                const arma::Col&lt;dtype&gt; *path_gain_2,
                const arma::Col&lt;dtype&gt; *path_length_2,
                const arma::Mat&lt;dtype&gt; *M_2,
                arma::Cube&lt;dtype&gt; *coeff_re,
                arma::Cube&lt;dtype&gt; *coeff_im,
                arma::Cube&lt;dtype&gt; *delay,
                arma::uword i_irs = 0,
                dtype threshold_dB = -140.0,
                dtype center_frequency = 0.0,
                bool use_absolute_delays = false,
                arma::Cube&lt;dtype&gt; *aod = nullptr,
                arma::Cube&lt;dtype&gt; *eod = nullptr,
                arma::Cube&lt;dtype&gt; *aoa = nullptr,
                arma::Cube&lt;dtype&gt; *eoa = nullptr,
                const arrayant&lt;dtype&gt; *irs_array_2 = nullptr,
                const std::vector&lt;bool&gt; *active_path = nullptr);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>const arrayant&lt;dtype&gt; <b>*tx_array</b></code> (input)<br> 
   Pointer to the transmit antenna array object (with <code>n_tx</code> elements). 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arrayant&lt;dtype&gt; <b>*rx_array</b></code> (input)<br> 
   Pointer to the receive antenna array object (with <code>n_rx</code> elements). 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arrayant&lt;dtype&gt; <b>*irs_array</b></code> (input)<br> 
   Pointer to the IRS array antenna (with <code>n_irs</code> elements). 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>Tx</b>, <b>Ty</b>, <b>Tz</b></code> (input)<br> 
   Transmitter position in Cartesian coordinates [m]. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>Tb</b>, <b>Tt</b>, <b>Th</b></code> (input)<br> 
   Transmitter orientation (Euler angles) in radians. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>Rx</b>, <b>Ry</b>, <b>Rz</b></code> (input)<br> 
   Receiver position in Cartesian coordinates [m]. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>Rb</b>, <b>Rt</b>, <b>Rh</b></code> (input)<br> 
   Receiver orientation (Euler angles) in radians. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>Ix</b>, <b>Iy</b>, <b>Iz</b></code> (input)<br> 
   IRS position in Cartesian coordinates [m]. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>Ib</b>, <b>It</b>, <b>Ih</b></code> (input)<br> 
   IRS orientation (Euler angles) in radians. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*fbs_pos_1</b></code> (input)<br> 
   First-bounce scatterer positions of TX → IRS paths, Size <code>[3, n_path_1]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*lbs_pos_1</b></code> (input)<br> 
   Last-bounce scatterer positions of TX → IRS paths, Size <code>[3, n_path_1]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Col&lt;dtype&gt; <b>*path_gain_1</b></code> (input)<br> 
   Path gains (linear) for TX → IRS paths, Length <code>n_path_1</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Col&lt;dtype&gt; <b>*path_length_1</b></code> (input)<br> 
   Path lengths for TX → IRS paths, Length <code>n_path_1</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*M_1</b></code> (input)<br> 
   Polarization transfer matrix for TX → IRS paths, Size <code>[8, n_path_1]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*fbs_pos_2</b></code> (input)<br> 
   First-bounce scatterer positions of IRS → RX paths, Size <code>[3, n_path_2]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*lbs_pos_2</b></code> (input)<br> 
   Last-bounce scatterer positions of IRS → RX paths, Size <code>[3, n_path_2]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Col&lt;dtype&gt; <b>*path_gain_2</b></code> (input)<br> 
   Path gains (linear) for IRS → RX paths, Length <code>n_path_2</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Col&lt;dtype&gt; <b>*path_length_2</b></code> (input)<br> 
   Path lengths for IRS → RX paths, Length <code>n_path_2</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*M_2</b></code> (input)<br> 
   Polarization transfer matrix for IRS → RX paths, Size <code>[8, n_path_2]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Cube&lt;dtype&gt; <b>*coeff_re</b></code> (output)<br> 
   Real part of resulting IRS-assisted channel coefficients, Size <code>[n_rx, n_tx, n_path_irs]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Cube&lt;dtype&gt; <b>*coeff_im</b></code> (output)<br> 
   Imaginary part of channel coefficients, Size <code>[n_rx, n_tx, n_path_irs]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Cube&lt;dtype&gt; <b>*delay</b></code> (output)<br> 
   Propagation delays in seconds, Size <code>[n_rx, n_tx, n_path_irs]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::uword <b>i_irs</b> = 0</code> (optional input)<br> 
   Index of IRS codebook entry (port number), Default: <code>0</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>threshold_dB</b> = -140.0</code> (optional input)<br> 
   Threshold (in dB) below which paths are discarded. Default: <code>-140.0</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>center_frequency</b> = 0.0</code> (optional input)<br> 
   Center frequency in Hz; <code>0.0</code> disables phase computation. Default: <code>0.0</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>bool <b>use_absolute_delays</b> = false</code> (optional input)<br> 
   If true, includes LOS delay in all paths. Default: <code>false</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Cube&lt;dtype&gt; <b>*aod</b> = nullptr</code> (optional output)<br> 
   Azimuth of Departure angles [rad], Size <code>[n_rx, n_tx, n_path_irs]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Cube&lt;dtype&gt; <b>*eod</b> = nullptr</code> (optional output)<br> 
   Elevation of Departure angles [rad], Size <code>[n_rx, n_tx, n_path_irs]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Cube&lt;dtype&gt; <b>*aoa</b> = nullptr</code> (optional output)<br> 
   Azimuth of Arrival angles [rad], Size <code>[n_rx, n_tx, n_path_irs]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Cube&lt;dtype&gt; <b>*eoa</b> = nullptr</code> (optional output)<br> 
   Elevation of Arrival angles [rad], Size <code>[n_rx, n_tx, n_path_irs]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arrayant&lt;dtype&gt; <b>*irs_array_2</b> = nullptr</code> (optional input)<br> 
   Optional second IRS array (TX side) for asymmetric IRS behavior. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const std::vector&lt;bool&gt; <b>*active_path</b> = nullptr</code> (optional input)<br> 
   Optional bitmask for selecting active TX-IRS and IRS-RX path pairs. Ignores <code>threshold_dB</code> when provided. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Returns:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>std::vector&lt;bool&gt;</code> <br> 
   Boolean mask of length <code>n_path_1 * n_path_2</code>, indicating which path combinations were used. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>See also:</i></b><br><ul><li style="margin-bottom: 0.4em;"><a href="#combine_irs_coord">combine_irs_coord</a> 
</li><li style="margin-bottom: 0.4em;"><a href="#get_channels_spherical">get_channels_spherical</a> 
</li><li style="margin-bottom: 0.4em;"><a href="#get_channels_planar">get_channels_planar</a> 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="get_channels_planar"></a>
<b>get_channels_planar</b> - Calculate channel coefficients for planar waves
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Calculates MIMO channel coefficients and delays for a set of planar wave paths between two antenna arrays. 
</li><li style="margin-bottom: 0.4em;">Interpolates antenna patterns (including orientation and polarization) for both transmitter and receiver arrays. 
</li><li style="margin-bottom: 0.4em;">Supports LOS path identification based on distance (angles are ignored). 
</li><li style="margin-bottom: 0.4em;">Polarization transfer matrix models polarization coupling and must be normalized. 
</li><li style="margin-bottom: 0.4em;">Doppler weights can optionally be calculated from receiver motion relative to path direction. 
</li><li style="margin-bottom: 0.4em;">Element positions and antenna orientation are fully considered for delay and phase. 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
void quadriga_lib::get_channels_planar(
                const arrayant&lt;dtype&gt; *tx_array,
                const arrayant&lt;dtype&gt; *rx_array,
                dtype Tx, dtype Ty, dtype Tz,
                dtype Tb, dtype Tt, dtype Th,
                dtype Rx, dtype Ry, dtype Rz,
                dtype Rb, dtype Rt, dtype Rh,
                const arma::Col&lt;dtype&gt; *aod,
                const arma::Col&lt;dtype&gt; *eod,
                const arma::Col&lt;dtype&gt; *aoa,
                const arma::Col&lt;dtype&gt; *eoa,
                const arma::Col&lt;dtype&gt; *path_gain,
                const arma::Col&lt;dtype&gt; *path_length,
                const arma::Mat&lt;dtype&gt; *M,
                arma::Cube&lt;dtype&gt; *coeff_re,
                arma::Cube&lt;dtype&gt; *coeff_im,
                arma::Cube&lt;dtype&gt; *delay,
                dtype center_frequency = dtype(0.0),
                bool use_absolute_delays = false,
                bool add_fake_los_path = false,
                arma::Col&lt;dtype&gt; *rx_Doppler = nullptr);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>const arrayant&lt;dtype&gt; <b>*tx_array</b></code> (input)<br> 
   Pointer to the transmit antenna array object (with <code>n_tx</code> elements). 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arrayant&lt;dtype&gt; <b>*rx_array</b></code> (input)<br> 
   Pointer to the receive antenna array object (with <code>n_rx</code> elements). 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>Tx</b>, <b>Ty</b>, <b>Tz</b></code> (input)<br> 
   Transmitter position in Cartesian coordinates [m]. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>Tb</b>, <b>Tt</b>, <b>Th</b></code> (input)<br> 
   Transmitter orientation (Euler) angles (bank, tilt, head) in [rad]. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>Rx</b>, <b>Ry</b>, <b>Rz</b></code> (input)<br> 
   Receiver position in Cartesian coordinates [m]. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>Rb</b>, <b>Rt</b>, <b>Rh</b></code> (input)<br> 
   Receiver orientation (Euler) angles (bank, tilt, head) in [rad]. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Col&lt;dtype&gt; <b>*aod</b></code> (input)<br> 
   Departure azimuth angles in radians, Length <code>n_path</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Col&lt;dtype&gt; <b>*eod</b></code> (input)<br> 
   Departure elevation angles in radians, Length <code>n_path</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Col&lt;dtype&gt; <b>*aoa</b></code> (input)<br> 
   Arrival azimuth angles in radians, Length <code>n_path</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Col&lt;dtype&gt; <b>*eoa</b></code> (input)<br> 
   Arrival elevation angles in radians, Length <code>n_path</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Col&lt;dtype&gt; <b>*path_gain</b></code> (input)<br> 
   Path gains in linear scale, Length <code>n_path</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Col&lt;dtype&gt; <b>*path_length</b></code> (input)<br> 
   Path lengths from TX to RX phase center, Length <code>n_path</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*M</b></code> (input)<br> 
   Polarization transfer matrix of size <code>[8, n_path]</code>, interleaved: (ReVV, ImVV, ReVH, ImVH, ReHV, ImHV, ReHH, ImHH). 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Cube&lt;dtype&gt; <b>*coeff_re</b></code> (output)<br> 
   Real part of channel coefficients, Size <code>[n_rx, n_tx, n_path(+1)]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Cube&lt;dtype&gt; <b>*coeff_im</b></code> (output)<br> 
   Imaginary part of channel coefficients, Size <code>[n_rx, n_tx, n_path(+1)]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Cube&lt;dtype&gt; <b>*delay</b></code> (output)<br> 
   Propagation delays in seconds, Size <code>[n_rx, n_tx, n_path(+1)]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>center_frequency</b> = 0.0</code> (optional input)<br> 
   Center frequency in Hz; set to 0 to disable phase calculation. Default: <code>0.0</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>bool <b>use_absolute_delays</b> = false</code> (optional input)<br> 
   If true, includes LOS delay in all paths. Default: <code>false</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>bool <b>add_fake_los_path</b> = false</code> (optional input)<br> 
   Adds a zero-power LOS path if no LOS is present. Default: <code>false</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Col&lt;dtype&gt; <b>*rx_Doppler</b> = nullptr</code> (optional output)<br> 
   Doppler weights for moving RX, Length <code>n_path(+1)</code>. Positive = towards path, Negative = away. 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="get_channels_spherical"></a>
<b>get_channels_spherical</b> - Calculate channel coefficients for spherical waves
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Calculates MIMO channel coefficients and delays for a set of spherical wave paths between two antenna arrays. 
</li><li style="margin-bottom: 0.4em;">Interpolates antenna patterns (including orientation and polarization) for both transmitter and receiver arrays. 
</li><li style="margin-bottom: 0.4em;">Accurately models path-based propagation using provided scatterer positions. 
</li><li style="margin-bottom: 0.4em;">Supports LOS path identification and handles complex polarization coupling. 
</li><li style="margin-bottom: 0.4em;">Element positions and antenna orientation are fully considered for delay and phase. 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
void quadriga_lib::get_channels_spherical(
                const arrayant&lt;dtype&gt; *tx_array,
                const arrayant&lt;dtype&gt; *rx_array,
                dtype Tx, dtype Ty, dtype Tz,
                dtype Tb, dtype Tt, dtype Th,
                dtype Rx, dtype Ry, dtype Rz,
                dtype Rb, dtype Rt, dtype Rh,
                const arma::Mat&lt;dtype&gt; *fbs_pos,
                const arma::Mat&lt;dtype&gt; *lbs_pos,
                const arma::Col&lt;dtype&gt; *path_gain,
                const arma::Col&lt;dtype&gt; *path_length,
                const arma::Mat&lt;dtype&gt; *M,
                arma::Cube&lt;dtype&gt; *coeff_re,
                arma::Cube&lt;dtype&gt; *coeff_im,
                arma::Cube&lt;dtype&gt; *delay,
                dtype center_frequency = dtype(0.0),
                bool use_absolute_delays = false,
                bool add_fake_los_path = false,
                arma::Cube&lt;dtype&gt; *aod = nullptr,
                arma::Cube&lt;dtype&gt; *eod = nullptr,
                arma::Cube&lt;dtype&gt; *aoa = nullptr,
                arma::Cube&lt;dtype&gt; *eoa = nullptr)
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>const arrayant&lt;dtype&gt; <b>*tx_array</b></code> (input)<br> 
   Pointer to the transmit antenna array object (with <code>n_tx</code> elements). 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arrayant&lt;dtype&gt; <b>*rx_array</b></code> (input)<br> 
   Pointer to the receive antenna array object (with <code>n_rx</code> elements). 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>Tx</b>, <b>Ty</b>, <b>Tz</b></code> (input)<br> 
   Transmitter position in Cartesian coordinates [m]. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>Tb</b>, <b>Tt</b>, <b>Th</b></code> (input)<br> 
   Transmitter orientation (Euler) angles (bank, tilt, head) in [rad]. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>Rx</b>, <b>Ry</b>, <b>Rz</b></code> (input)<br> 
   Receiver position in Cartesian coordinates [m]. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>Rb</b>, <b>Rt</b>, <b>Rh</b></code> (input)<br> 
   Receiver orientation (Euler) angles (bank, tilt, head) in [rad]. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*fbs_pos</b></code> (input)<br> 
   First-bounce scatterer positions, Size: <code>[3, n_path]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*lbs_pos</b></code> (input)<br> 
   Last-bounce scatterer positions, Size: <code>[3, n_path]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Col&lt;dtype&gt; <b>*path_gain</b></code> (input)<br> 
   Path gains in linear scale, Length <code>n_path</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Col&lt;dtype&gt; <b>*path_length</b></code> (input)<br> 
   Path lengths from TX to RX phase center Length <code>n_path</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*M</b></code> (input)<br> 
   Polarization transfer matrix of size <code>[8, n_path]</code>, interleaved: (ReVV, ImVV, ReVH, ImVH, ReHV, ImHV, ReHH, ImHH). 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Cube&lt;dtype&gt; <b>*coeff_re</b></code> (output)<br> 
   Real part of channel coefficients, Size <code>[n_rx, n_tx, n_path]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Cube&lt;dtype&gt; <b>*coeff_im</b></code> (output)<br> 
   Imaginary part of channel coefficients, Size <code>[n_rx, n_tx, n_path]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Cube&lt;dtype&gt; <b>*delay</b></code> (output)<br> 
   Propagation delays in seconds, Size <code>[n_rx, n_tx, n_path]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>center_frequency</b> = 0.0</code> (optional input)<br> 
   Center frequency in Hz; set to 0 to disable phase calculation. Default: <code>0.0</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>bool <b>use_absolute_delays</b> = false</code> (optional input)<br> 
   If true, includes LOS delay in all paths. Default: <code>false</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>bool <b>add_fake_los_path</b> = false</code> (optional input)<br> 
   Adds a zero-power LOS path if no LOS is present. Default: <code>false</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Cube&lt;dtype&gt; <b>*aod</b> = nullptr</code> (optional output)<br> 
   Azimuth of Departure angles in radians, Size <code>[n_rx, n_tx, n_path]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Cube&lt;dtype&gt; <b>*eod</b> = nullptr</code> (optional output)<br> 
   Elevation of Departure angles in radians, Size <code>[n_rx, n_tx, n_path]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Cube&lt;dtype&gt; <b>*aoa</b> = nullptr</code> (optional output)<br> 
   Azimuth of Arrival angles in radians, Size <code>[n_rx, n_tx, n_path]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Cube&lt;dtype&gt; <i></i>*eoa = nullptr</code> (optional output)<br> 
   Elevation of Arrival angles in radians, Size <code>[n_rx, n_tx, n_path]</code>. 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="qdant_read"></a>
<b>qdant_read</b> - Reads array antenna data from QDANT files
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Reads antenna pattern data and layout from a QuaDRiGa array antenna exchange format (QDANT) file, which stores antenna pattern data in XML format. 
</li><li style="margin-bottom: 0.4em;">Returns an antenna array (<code>arrayant</code>) object constructed from the specified data in the QDANT file. 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
arrayant&lt;dtype&gt; quadriga_lib::qdant_read(std::string fn, unsigned id = 1, arma::u32_mat *layout = nullptr);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>std::string <b>fn</b></code> (input)<br> 
   Filename of the QDANT file from which antenna pattern data will be read. Cannot be empty. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>unsigned <b>id</b> = 1</code> (optional input)<br> 
   ID of the antenna within the QDANT file to read. Default is <code>1</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::u32_mat <b>layout</b> = nullptr</code> (optional output)<br> 
   Pointer to a matrix that will store the layout information of multiple antenna elements from the file. The layout contains element IDs present in the QDANT file. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Returns:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>arrayant&lt;dtype&gt;</code><br> 
   Antenna array object containing data from the specified antenna ID within the QDANT file. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Example:</i></b><br><pre>
arma::u32_mat layout;
auto ant = quadriga_lib::qdant_read&lt;double&gt;("antenna_data.qdant", 2, &amp;layout);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>See also:</i></b><br><ul><li style="margin-bottom: 0.4em;"><a href="#arrayant">arrayant</a> 
</li><li style="margin-bottom: 0.4em;"><a href="#.qdant_write">arrayant.qdant_write</a> 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="generate_arrayant_omni"></a>
<b>generate_arrayant_omni</b> - Generate isotropic radiator with vertical polarization
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Generates an isotropic antenna radiator pattern with vertical polarization. 
</li><li style="margin-bottom: 0.4em;">Allows specification of the resolution of the antenna pattern sampling grid. 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
arrayant&lt;dtype&gt; quadriga_lib::generate_arrayant_omni(dtype res = 1.0)
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>dtype <b>res</b> = 1.0</code> (optional input)<br> 
   Resolution of the antenna pattern sampling grid, specified in degrees. Default: <code>1.0</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Returns:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>arrayant&lt;dtype&gt;</code><br> 
   Antenna array object representing an isotropic radiator with vertical polarization. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Example:</i></b><br><pre>
auto ant = quadriga_lib::generate_arrayant_omni&lt;float&gt;(10.0f);
</pre>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="generate_arrayant_xpol"></a>
<b>generate_arrayant_xpol</b> - Generate cross-polarized isotropic radiator
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Generates a cross-polarized isotropic antenna radiator pattern. 
</li><li style="margin-bottom: 0.4em;">Allows specification of the resolution of the antenna pattern sampling grid. 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
arrayant&lt;dtype&gt; quadriga_lib::generate_arrayant_xpol(dtype res = 1.0)
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>dtype <b>res</b> = 1.0</code> (optional input)<br> 
   Resolution of the antenna pattern sampling grid, specified in degrees. Default: <code>1.0</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Returns:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>arrayant&lt;dtype&gt;</code><br> 
   Antenna array object representing a cross-polarized isotropic radiator. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Example:</i></b><br><pre>
auto ant = quadriga_lib::generate_arrayant_xpol&lt;float&gt;(10.0f);
</pre>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="generate_arrayant_dipole"></a>
<b>generate_arrayant_dipole</b> - Generate short dipole with vertical polarization
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Generates a short dipole antenna pattern with vertical polarization. 
</li><li style="margin-bottom: 0.4em;">Allows specification of the resolution of the antenna pattern sampling grid. 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
arrayant&lt;dtype&gt; quadriga_lib::generate_arrayant_dipole(dtype res = 1.0)
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>dtype <b>res</b> = 1.0</code> (optional input)<br> 
   Resolution of the antenna pattern sampling grid, specified in degrees. Default: <code>1.0</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Returns:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>arrayant&lt;dtype&gt;</code><br> 
   Antenna array object representing a vertically polarized short dipole. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Example:</i></b><br><pre>
auto ant = quadriga_lib::generate_arrayant_dipole&lt;float&gt;();
</pre>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="generate_arrayant_half_wave_dipole"></a>
<b>generate_arrayant_half_wave_dipole</b> - Generate half-wave dipole with vertical polarization
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Generates a vertically polarized half-wave dipole antenna pattern. 
</li><li style="margin-bottom: 0.4em;">Allows specification of the resolution of the antenna pattern sampling grid. 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
arrayant&lt;dtype&gt; quadriga_lib::generate_arrayant_half_wave_dipole(dtype res = 1.0)
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>dtype <b>res</b> = 1.0</code> (optional input)<br> 
   Resolution of the antenna pattern sampling grid, specified in degrees. Default: <code>1.0</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Returns:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>arrayant&lt;dtype&gt;</code><br> 
   Antenna array object representing a vertically polarized half-wave dipole. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Example:</i></b><br><pre>
auto ant = quadriga_lib::generate_arrayant_half_wave_dipole&lt;float&gt;();
</pre>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="generate_arrayant_custom"></a>
<b>generate_arrayant_custom</b> - Generate antenna with custom 3dB beamwidth
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Generates an antenna array object with a custom-defined 3dB beamwidth (FWHM) in azimuth and elevation. 
</li><li style="margin-bottom: 0.4em;">Allows control over the rear-side attenuation using a front-to-back gain ratio. 
</li><li style="margin-bottom: 0.4em;">Supports specification of the pattern sampling resolution. 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
arrayant&lt;dtype&gt; quadriga_lib::generate_arrayant_custom(dtype az_3dB = 90.0,
                dtype el_3db = 90.0, dtype rear_gain_lin = 0.0, dtype res = 1.0)
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>dtype <b>az_3dB</b> = 90.0</code> (optional input)<br> 
   3dB beamwidth in azimuth, specified in degrees. Default: <code>90.0</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>el_3db</b> = 90.0</code> (optional input)<br> 
   3dB beamwidth in elevation, specified in degrees. Default: <code>90.0</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>rear_gain_lin</b> = 0.0</code> (optional input)<br> 
   Front-to-back gain ratio as a linear value. Default: <code>0.0</code> (no rear gain) 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>res</b> = 1.0</code> (optional input)<br> 
   Resolution of the antenna pattern sampling grid, specified in degrees. Default: <code>1.0</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Returns:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>arrayant&lt;dtype&gt;</code><br> 
   Antenna array object with the specified 3dB beamwidth and rear gain. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Example:</i></b><br><pre>
auto ant = quadriga_lib::generate_arrayant_custom&lt;double&gt;(60.0, 45.0, 0.01, 1.0);
</pre>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="generate_arrayant_3gpp"></a>
<b>generate_arrayant_3gpp</b> - Generate 3GPP-NR compliant antenna model
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Generates an antenna array based on the 3GPP-NR channel model specification. 
</li><li style="margin-bottom: 0.4em;">Supports vertical and horizontal stacking of elements and panels with a range of polarization configurations. 
</li><li style="margin-bottom: 0.4em;">Optionally, a custom per-element pattern can be provided (element positions, coupling, and center frequency are ignored). 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
arrayant&lt;dtype&gt; quadriga_lib::generate_arrayant_3GPP(
                arma::uword M = 1, arma::uword N = 1, dtype center_freq = 299792458.0,
                unsigned pol = 1, dtype tilt = 0.0, dtype spacing = 0.5, arma::uword Mg = 1,
                arma::uword Ng = 1, dtype dgv = 0.5, dtype dgh = 0.5,
                const arrayant&lt;dtype&gt; *pattern = nullptr, dtype res = 1.0)
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>arma::uword <b>M</b> = 1</code> (optional input)<br> 
   Number of vertical elements in the array. Default: <code>1</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::uword <b>N</b> = 1</code> (optional input)<br> 
   Number of horizontal elements in the array. Default: <code>1</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>center_freq</b> = 299792458.0</code> (optional input)<br> 
   Center frequency of the antenna array in Hz. Default: <code>299792458.0</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>unsigned <b>pol</b> = 1</code> (optional input)<br> 
   Polarization configuration: 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>pol = 1</code></td>
  <td>vertical polarization (default value)</td>
</tr>
<tr>
  <td><code>pol = 2</code></td>
  <td>H/V polarized elements, results in 2NM elements</td>
</tr>
<tr>
  <td><code>pol = 3</code></td>
  <td>+/-45° polarized elements, results in 2NM elements</td>
</tr>
<tr>
  <td><code>pol = 4</code></td>
  <td>vertical polarization, combines elements in vertical direction, results in N elements</td>
</tr>
<tr>
  <td><code>pol = 5</code></td>
  <td>H/V polarization, combines elements in vertical direction, results in 2N elements</td>
</tr>
<tr>
  <td><code>pol = 6</code></td>
  <td>+/-45° polarization, combines elements in vertical direction, results in 2N elements</td>
</tr>
</table><br>
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>tilt</b> = 0.0</code> (optional input)<br> 
   Electrical downtilt angle in degrees. Used for <code>pol</code> values 4, 5, and 6. Default: <code>0.0</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>spacing</b> = 0.5</code> (optional input)<br> 
   Spacing between elements in wavelengths (λ). Default: <code>0.5</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::uword <b>Mg</b> = 1</code> (optional input)<br> 
   Number of vertically stacked panels (columns). Default: <code>1</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::uword <b>Ng</b> = 1</code> (optional input)<br> 
   Number of horizontally stacked panels (rows). Default: <code>1</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>dgv</b> = 0.5</code> (optional input)<br> 
   Panel spacing in vertical direction in wavelengths (λ). Default: <code>0.5</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>dgh</b> = 0.5</code> (optional input)<br> 
   Panel spacing in horizontal direction in wavelengths (λ). Default: <code>0.5</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arrayant&lt;dtype&gt; <b>pattern</b> = nullptr</code> (optional input)<br> 
   Optional pointer to a custom per-element antenna pattern. If provided, it overrides default generation. Only the shape of the pattern is used; element positions, coupling, and frequency are ignored. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>res</b> = 1.0</code> (optional input)<br> 
   Pattern resolution in degrees. Ignored if a custom pattern is provided. Default: <code>1.0</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Returns:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>arrayant&lt;dtype&gt;</code><br> 
   Generated antenna array object according to 3GPP-NR specifications. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Example:</i></b><br><pre>
// Generate 3GPP antenna array with 4x4 elements, H/V polarization
auto ant = quadriga_lib::generate_arrayant_3GPP&lt;double&gt;(4, 4, 3e9, 2);
</pre>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="generate_arrayant_multibeam"></a>
<b>generate_arrayant_multibeam</b> - Generate a planar multi-element antenna with support for multiple beam directions.
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>This function generates a planar array antenna with <b>M</b> rows and <b>N</b> columns.   
It allows customization of the per-element radiation pattern, polarization, and spacing.   
Multiple beam directions can be specified via azimuth and elevation angles.   
Beamforming uses <b>maximum-ratio transmission (MRT)</b>, which is optimal for a single  
beam and approximate when multiple beams are specified. 
 
Supported data types for <code>dtype</code>: <code>float</code> or <code>double</code>.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
arrayant&lt;dtype&gt; quadriga_lib::generate_arrayant_multibeam(
                arma::uword M = 1, 
                arma::uword N = 1, 
                arma::Col&lt;dtype&gt; az = {0.0}, 
                arma::Col&lt;dtype&gt; el = {0.0}, 
                arma::Col&lt;dtype&gt; weight = {1.0},
                dtype center_freq = 299792458.0, 
                unsigned pol = 1, 
                dtype spacing = 0.5, 
                dtype az_3dB = 120.0, 
                dtype el_3dB = 120.0,
                dtype rear_gain_lin = 0.0, 
                dtype res = 1.0, 
                bool separate_beams = false, 
                bool apply_weights = false );
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>arma::uword <b>M</b> = 1</code> (optional input)<br> 
   Number of vertical (rows) elements in the array. Default: <code>1</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::uword <b>N</b> = 1</code> (optional input)<br> 
   Number of horizontal (columns) elements in the array. Default: <code>1</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Col&lt;dtype&gt; <b>az</b> = {0.0}</code> (optional input)<br> 
   Azimuth beam angles (degrees). Vector of length <code>n_beams</code>. Default: <code>{0.0}</code> 
    
</li><li style="margin-bottom: 0.4em;"><code>arma::Col&lt;dtype&gt; <b>el</b> = {0.0}</code> (optional input)<br> 
   Elevation beam angles (degrees). Vector of length <code>n_beams</code>. Default: <code>{0.0}</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Col&lt;dtype&gt; <b>weight</b> = {1.0}</code> (optional input)<br> 
   Scaling factors for each beam. The vector must have the same length as <code>az</code> and <code>el</code>.   
   Values are normalized so that their sum equals 1. Can be used to prioritize beams.   
   Default: <code>{1.0}</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>center_freq</b> = 299792458.0</code> (optional input)<br> 
   Center frequency of the antenna array in Hz. Default: <code>299792458.0</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>unsigned <b>pol</b> = 1</code> (optional input)<br> 
   Polarization configuration: 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>pol = 1</code></td>
  <td>vertical polarization (default value)</td>
</tr>
<tr>
  <td><code>pol = 2</code></td>
  <td>H/V polarized elements, results in 2NM elements</td>
</tr>
<tr>
  <td><code>pol = 3</code></td>
  <td>+/-45° polarized elements, results in 2NM elements</td>
</tr>
</table><br>
   
</li><li style="margin-bottom: 0.4em;"><code>dtype <b>spacing</b> = 0.5</code> (optional input)<br> 
   Spacing between elements in wavelengths (λ). Default: <code>0.5</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>az_3dB</b> = 120.0</code> (optional input)<br> 
   3dB beamwidth in azimuth, specified in degrees. Default: <code>120.0</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>el_3db</b> = 120.0</code> (optional input)<br> 
   3dB beamwidth in elevation, specified in degrees. Default: <code>120.0</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>rear_gain_lin</b> = 0.0</code> (optional input)<br> 
   Front-to-back gain ratio as a linear value. Default: <code>0.0</code> (no rear gain) 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>res</b> = 1.0</code> (optional input)<br> 
   Resolution of the antenna pattern sampling grid, specified in degrees. Default: <code>1.0</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>bool <b>separate_beams</b> = false</code> (optional input)<br> 
   If set to true, create a separate beam for each angle pair (ignores weights) 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>bool <b>apply_weights</b> = false</code> (optional input)<br> 
   Switch to apply the beam-forming weights 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Returns:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>arrayant&lt;dtype&gt;</code><br> 
   Array antenna object containing the generated multibeam pattern. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Example:</i></b><br><pre>
// Generate a pattern with 2 weighted beams
double freq = 3.75e9;
arma::vec az = {20.0, 0.0};
arma::vec el = {-7.0, 30.0};
arma::vec weight = {2.0, 1.0};

auto ant = quadriga_lib::generate_arrayant_multibeam&lt;double&gt;(6, 6, az, el, weight, freq);
</pre>
</li>
</ul>
<div class="pagebreak"></div>
<hr class="greyline">
<hr class="greyline">
<br>
<br>
<font size=+1><b>Channel class</b></font>
<br>
<br>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="channel"></a>
<b>channel</b> - Class for storing and managing MIMO channel data and associated metadata
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">A channel object represents MIMO path-level channel data between antenna arrays over multiple time snapshots. 
</li><li style="margin-bottom: 0.4em;">Each snapshot may have a different number of propagation paths. 
</li><li style="margin-bottom: 0.4em;">Contains structured fields for positions, delays, gains, angles, coefficients, and more. 
</li><li style="margin-bottom: 0.4em;">Supports optional metadata via <code>par_names</code> and <code>par_data</code>. 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> and <code>double</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Attributes:</i></b><br><table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>std::string name</code></td>
  <td>Name of the channel object</td>
</tr>
<tr>
  <td><code>arma::Col&lt;dtype&gt; center_frequency</code></td>
  <td>Center frequency in [Hz], size <code>[1]</code> or <code>[n_snap]</code> or <code>[]</code></td>
</tr>
<tr>
  <td><code>arma::Mat&lt;dtype&gt; tx_pos</code></td>
  <td>Transmitter positions, size <code>[3, n_snap]</code> or <code>[3, 1]</code></td>
</tr>
<tr>
  <td><code>arma::Mat&lt;dtype&gt; rx_pos</code></td>
  <td>Receiver positions, size <code>[3, n_snap]</code> or <code>[3, 1]</code></td>
</tr>
<tr>
  <td><code>arma::Mat&lt;dtype&gt; tx_orientation</code></td>
  <td>Transmitter orientation (Euler), size <code>[3, n_snap]</code>, <code>[3, 1]</code>, or <code>[]</code></td>
</tr>
<tr>
  <td><code>arma::Mat&lt;dtype&gt; rx_orientation</code></td>
  <td>Receiver orientation (Euler), size <code>[3, n_snap]</code>, <code>[3, 1]</code>, or <code>[]</code></td>
</tr>
<tr>
  <td><code>std::vector&lt;arma::Cube&lt;dtype&gt;&gt; coeff_re</code></td>
  <td>Channel coefficients, real part, size <code>[n_rx, n_tx, n_path]</code> per snapshot</td>
</tr>
<tr>
  <td><code>std::vector&lt;arma::Cube&lt;dtype&gt;&gt; coeff_im</code></td>
  <td>Channel coefficients, imaginary part, same size as <code>coeff_re</code></td>
</tr>
<tr>
  <td><code>std::vector&lt;arma::Cube&lt;dtype&gt;&gt; delay</code></td>
  <td>Path delays [s], size <code>[n_rx, n_tx, n_path]</code> or <code>[1,1,n_path]</code> per snapshot</td>
</tr>
<tr>
  <td><code>std::vector&lt;arma::Col&lt;dtype&gt;&gt; path_gain</code></td>
  <td>Path gains (pre-pattern), length <code>[n_path]</code> per snapshot</td>
</tr>
<tr>
  <td><code>std::vector&lt;arma::Col&lt;dtype&gt;&gt; path_length</code></td>
  <td>Path lengths TX→RX [m], length <code>[n_path]</code> per snapshot</td>
</tr>
<tr>
  <td><code>std::vector&lt;arma::Mat&lt;dtype&gt;&gt; path_polarization</code></td>
  <td>Polarization matrix, size <code>[8, n_path]</code> per snapshot</td>
</tr>
<tr>
  <td><code>std::vector&lt;arma::Mat&lt;dtype&gt;&gt; path_angles</code></td>
  <td>Departure/arrival angles, size <code>[n_path, 4]</code>, columns: AOD, EOD, AOA, EOA</td>
</tr>
<tr>
  <td><code>std::vector&lt;arma::Mat&lt;dtype&gt;&gt; path_fbs_pos</code></td>
  <td>First-bounce scatterer positions, size <code>[3, n_path]</code></td>
</tr>
<tr>
  <td><code>std::vector&lt;arma::Mat&lt;dtype&gt;&gt; path_lbs_pos</code></td>
  <td>Last-bounce scatterer positions, size <code>[3, n_path]</code></td>
</tr>
<tr>
  <td><code>std::vector&lt;arma::Col&lt;unsigned&gt;&gt; no_interact</code></td>
  <td>Number of interactions per path, length <code>[n_path]</code> per snapshot</td>
</tr>
<tr>
  <td><code>std::vector&lt;arma::Mat&lt;dtype&gt;&gt; interact_coord</code></td>
  <td>Coordinates of all interactions, size <code>[3, sum(no_interact)]</code> per snapshot</td>
</tr>
<tr>
  <td><code>std::vector&lt;std::string&gt; par_names</code></td>
  <td>Names of unstructured parameters</td>
</tr>
<tr>
  <td><code>std::vector&lt;std::any&gt; par_data</code></td>
  <td>Unstructured metadata fields (e.g., string, scalar, matrix)</td>
</tr>
<tr>
  <td><code>int initial_position</code></td>
  <td>Index of reference snapshot (0-based)</td>
</tr>
</table><br>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Simple member functions:</i></b><br><table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>.n_snap()</code></td>
  <td>Returns the number of snapshots</td>
</tr>
<tr>
  <td><code>.n_rx()</code></td>
  <td>Returns the number of receive antennas (0 if coeffs not present)</td>
</tr>
<tr>
  <td><code>.n_tx()</code></td>
  <td>Returns the number of transmit antennas (0 if coeffs not present)</td>
</tr>
<tr>
  <td><code>.n_path()</code></td>
  <td>Returns the number of paths per snapshot as vector</td>
</tr>
<tr>
  <td><code>.empty()</code></td>
  <td>Returns true if the object has no channel data</td>
</tr>
<tr>
  <td><code>.is_valid()</code></td>
  <td>Returns an empty string if object is valid, else an error message</td>
</tr>
</table><br>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Complex member functions:</i></b><br><ul><li style="margin-bottom: 0.4em;"><a href="#.add_paths">.add_paths</a> 
</li><li style="margin-bottom: 0.4em;"><a href="#.calc_effective_path_gain">.calc_effective_path_gain</a> 
</li><li style="margin-bottom: 0.4em;"><a href="#.write_paths_to_obj_file">.write_paths_to_obj_file</a> 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name=".add_paths"></a>
<b>.add_paths</b> - Append new propagation paths to an existing channel snapshot
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Adds path-level channel data to a specific snapshot (<code>i_snap</code>) in a <code>channel</code> object. 
</li><li style="margin-bottom: 0.4em;">All fields provided must be consistent in length (<code>n_path_add</code>) and structure. 
</li><li style="margin-bottom: 0.4em;">The number of antennas must match existing entries for the snapshot. 
</li><li style="margin-bottom: 0.4em;">Existing fields in the channel object must also be provided to this method if relevant. 
</li><li style="margin-bottom: 0.4em;">Member function of <a href="#channel">channel</a> 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
void quadriga_lib::channel&lt;dtype&gt;::add_paths(
                arma::uword i_snap,
                const arma::Cube&lt;dtype&gt; *coeff_re_add = nullptr,
                const arma::Cube&lt;dtype&gt; *coeff_im_add = nullptr,
                const arma::Cube&lt;dtype&gt; *delay_add = nullptr,
                const arma::u32_vec *no_interact_add = nullptr,
                const arma::Mat&lt;dtype&gt; *interact_coord_add = nullptr,
                const arma::Col&lt;dtype&gt; *path_gain_add = nullptr,
                const arma::Col&lt;dtype&gt; *path_length_add = nullptr,
                const arma::Mat&lt;dtype&gt; *path_polarization_add = nullptr,
                const arma::Mat&lt;dtype&gt; *path_angles_add = nullptr,
                const arma::Mat&lt;dtype&gt; *path_fbs_pos_add = nullptr,
                const arma::Mat&lt;dtype&gt; *path_lbs_pos_add = nullptr);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>arma::uword <b>i_snap</b></code> (input)<br> 
   Index of the snapshot to which the new paths should be added (0-based). 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Cube&lt;dtype&gt; <b>*coeff_re_add</b></code> (optional input)<br> 
   Real part of channel coefficients. Size: <code>[n_rx, n_tx, n_path_add]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Cube&lt;dtype&gt; <b>*coeff_im_add</b></code> (optional input)<br> 
   Imaginary part of channel coefficients. Size: <code>[n_rx, n_tx, n_path_add]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Cube&lt;dtype&gt; <b>*delay_add</b></code> (optional input)<br> 
   Propagation delay in seconds. Size: <code>[n_rx, n_tx, n_path_add]</code> or <code>[1, 1, n_path_add]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::u32_vec <b>*no_interact_add</b></code> (optional input)<br> 
   Number of interaction points per path. Length: <code>[n_path_add]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*interact_coord_add</b></code> (optional input)<br> 
   Coordinates of interaction points. Size: <code>[3, sum(no_interact)]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Col&lt;dtype&gt; <b>*path_gain_add</b></code> (optional input)<br> 
   Path gains before antenna effects. Length: <code>[n_path_add]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Col&lt;dtype&gt; <b>*path_length_add</b></code> (optional input)<br> 
   Path lengths from TX to RX phase center. Length: <code>[n_path_add]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*path_polarization_add</b></code> (optional input)<br> 
   Polarization transfer matrices (interleaved). Size: <code>[8, n_path_add]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*path_angles_add</b></code> (optional input)<br> 
   Departure and arrival angles. Size: <code>[n_path_add, 4]</code>, format: <code>{AOD, EOD, AOA, EOA}</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*path_fbs_pos_add</b></code> (optional input)<br> 
   First-bounce scatterer positions. Size: <code>[3, n_path_add]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*path_lbs_pos_add</b></code> (optional input)<br> 
   Last-bounce scatterer positions. Size: <code>[3, n_path_add]</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Notes:</i></b><br><ul><li style="margin-bottom: 0.4em;">Any provided input must match the snapshot structure and existing fields of the <code>channel</code> object. 
</li><li style="margin-bottom: 0.4em;">This method does not update <code>tx_pos</code>, <code>rx_pos</code>, or orientation fields. 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name=".calc_effective_path_gain"></a>
<b>.calc_effective_path_gain</b> - Calculate the effective path gain for each snapshot (in linear scale)
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Computes the effective channel gain by summing the power of all paths and averaging over all transmit and receive antennas. 
</li><li style="margin-bottom: 0.4em;">If channel coefficients (<code>coeff_re</code>, <code>coeff_im</code>) are available, the result is based on the actual MIMO channel. 
</li><li style="margin-bottom: 0.4em;">If channel coefficients are unavailable but <code>path_polarization</code> exists, the gain is estimated assuming ideal dual-polarized (XPOL) antennas. 
</li><li style="margin-bottom: 0.4em;">Throws an exception if neither of these datasets is available. 
</li><li style="margin-bottom: 0.4em;">Returns one gain value per snapshot. 
</li><li style="margin-bottom: 0.4em;">Member function of <a href="#channel">channel</a> 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
arma::Col&lt;dtype&gt; quadriga_lib::channel&lt;dtype&gt;::calc_effective_path_gain(bool assume_valid = false) const;
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>bool <i></i>assume_valid*- = false</code> (optional input)<br> 
   Skip internal consistency checks if set to <code>true</code> (for performance in trusted contexts). Default: <code>false</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Returns:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>arma::Col&lt;dtype&gt;</code><br> 
   Column vector of effective path gains (linear scale), one entry per snapshot (length <code>n_snap</code>). 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name=".write_paths_to_obj_file"></a>
<b>.write_paths_to_obj_file</b> - Export propagation paths to a Wavefront OBJ file
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Writes ray-traced propagation paths to a <code>.obj</code> file for 3D visualization (e.g., in Blender). 
</li><li style="margin-bottom: 0.4em;">Each path is represented as a tube, optionally colored by path gain using a selected colormap. 
</li><li style="margin-bottom: 0.4em;">The function supports filtering by path gain, maximum number of paths, and snapshot index. 
</li><li style="margin-bottom: 0.4em;">Tube radius and detail can be customized. 
</li><li style="margin-bottom: 0.4em;">Member function of <a href="#channel">channel</a> 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
void quadriga_lib::channel&lt;dtype&gt;::write_paths_to_obj_file(
                std::string fn,
                arma::uword max_no_paths = 0,
                dtype gain_max = -60.0,
                dtype gain_min = -140.0,
                std::string colormap = "jet",
                arma::uvec i_snap = {},
                dtype radius_max = 0.05,
                dtype radius_min = 0.01,
                arma::uword n_edges = 5) const;
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>std::string <b>fn</b></code> (input)<br> 
   Path to the output <code>.obj</code> file. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::uword <b>max_no_paths</b> = 0</code> (optional input)<br> 
   Maximum number of paths to be visualized. A value of <code>0</code> includes all available paths above <code>gain_min</code>.  
   Default: <code>0</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>gain_max</b> = -60.0</code> (optional input)<br> 
   Maximum path gain (in dB) used for color-coding. Paths with higher gain are clipped. Default: <code>-60.0</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>gain_min</b> = -140.0</code> (optional input)<br> 
   Minimum path gain (in dB) for color-coding and optional path filtering. Default: <code>-140.0</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>std::string <b>colormap</b> = "jet"</code> (optional input)<br> 
   Name of the colormap to be used for path coloring.  
   Supported maps: <code>jet</code>, <code>parula</code>, <code>winter</code>, <code>hot</code>, <code>turbo</code>, <code>copper</code>, <code>spring</code>, <code>cool</code>, <code>gray</code>,  
   <code>autumn</code>, <code>summer</code>. Default: <code>"jet"</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::uvec <b>i_snap</b> = {}</code> (optional input)<br> 
   Indices of the snapshots to be included (0-based). Empty vector exports all snapshots. Default: <code>{}</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>radius_max</b> = 0.05</code> (optional input)<br> 
   Maximum radius (in meters) of the visualized tube geometry. Default: <code>0.05</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>radius_min</b> = 0.01</code> (optional input)<br> 
   Minimum radius (in meters) of the visualized tube geometry. Default: <code>0.01</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::uword <b>n_edges</b> = 5</code> (optional input)<br> 
   Number of vertices used to create each tube cross-section. Must be ≥ 3. Default: <code>5</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>See also:</i></b><br><ul><li style="margin-bottom: 0.4em;"><a href="#path_to_tube">path_to_tube</a> 
</li><li style="margin-bottom: 0.4em;"><a href="#colormap">colormap</a> 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div>
<hr class="greyline">
<hr class="greyline">
<br>
<br>
<font size=+1><b>Channel functions</b></font>
<br>
<br>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="any_type_id"></a>
<b>any_type_id</b> - Get type ID and raw access from a 'std::any' object
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Inspects a <code>std::any</code> object and returns a type identifier for its contents. 
</li><li style="margin-bottom: 0.4em;">Optionally retrieves the dimensions of the object (if it is a matrix, vector, or cube). 
</li><li style="margin-bottom: 0.4em;">Optionally retrieves a raw pointer to the internal data. 
</li><li style="margin-bottom: 0.4em;"><b>Warning:</b> Accessing data through <code>dataptr</code> is not type-safe and bypasses <code>const</code> protection. Use with extreme caution. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
int quadriga_lib::any_type_id(
                const std::any *data,
                unsigned long long *dims = nullptr,
                void **dataptr = nullptr);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>const std::any <b>*data</b></code> (input)<br> 
   Pointer to the <code>std::any</code> object to inspect. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>unsigned long long <b>*dims</b> = nullptr</code> (optional output)<br> 
   Pointer to an array of 3 integers that will hold the dimensions of the object:<br> 
   <code>dims[0]</code>, <code>dims[1]</code>, <code>dims[2]</code>: Number of rows, columns, slices (for Armadillo types).<br> 
   For <code>std::string</code>, <code>dims[0]</code> contains the string length, <code>dims[1]</code> and <code>dims[2]</code> are zero. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>void <b>&#42;&#42;dataptr</b> = nullptr</code> (optional output)<br> 
   If not <code>nullptr</code>, returns a raw pointer to the object's internal data.  This allows direct access, <b>without</b> type safety or <code>const</code> protection. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Returns:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>int</code><br> 
   Type ID corresponding to the content of the <code>std::any</code> object. Values are:<br><br> 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <th>ID</th>
  <th>Type</th>
  <th>ID</th>
  <th>Type</th>
  <th>ID</th>
  <th>Type</th>
</tr>
<tr>
  <td>-2</td>
  <td><code>no value</code></td>
  <td>-1</td>
  <td><code>unsupported type</code></td>
  <td>9</td>
  <td><code>std::string</code></td>
</tr>
<tr>
  <td>10</td>
  <td><code>float</code></td>
  <td>11</td>
  <td><code>double</code></td>
  <td>12</td>
  <td><code>unsigned long long int</code></td>
</tr>
<tr>
  <td>13</td>
  <td><code>long long int</code></td>
  <td>14</td>
  <td><code>unsigned int</code></td>
  <td>15</td>
  <td><code>int</code></td>
</tr>
<tr>
  <td>20</td>
  <td><code>arma::Mat&lt;float&gt;</code></td>
  <td>21</td>
  <td><code>arma::Mat&lt;double&gt;</code></td>
  <td>22</td>
  <td><code>arma::Mat&lt;arma::uword&gt;</code></td>
</tr>
<tr>
  <td>23</td>
  <td><code>arma::Mat&lt;arma::sword&gt;</code></td>
  <td>24</td>
  <td><code>arma::Mat&lt;unsigned&gt;</code></td>
  <td>25</td>
  <td><code>arma::Mat&lt;int&gt;</code></td>
</tr>
<tr>
  <td>30</td>
  <td><code>arma::Cube&lt;float&gt;</code></td>
  <td>31</td>
  <td><code>arma::Cube&lt;double&gt;</code></td>
  <td>32</td>
  <td><code>arma::Cube&lt;arma::uword&gt;</code></td>
</tr>
<tr>
  <td>33</td>
  <td><code>arma::Cube&lt;arma::sword&gt;</code></td>
  <td>34</td>
  <td><code>arma::Cube&lt;unsigned&gt;</code></td>
  <td>35</td>
  <td><code>arma::Cube&lt;int&gt;</code></td>
</tr>
<tr>
  <td>40</td>
  <td><code>arma::Col&lt;float&gt;</code></td>
  <td>41</td>
  <td><code>arma::Col&lt;double&gt;</code></td>
  <td>42</td>
  <td><code>arma::Col&lt;arma::uword&gt;</code></td>
</tr>
<tr>
  <td>43</td>
  <td><code>arma::Col&lt;arma::sword&gt;</code></td>
  <td>44</td>
  <td><code>arma::Col&lt;unsigned&gt;</code></td>
  <td>45</td>
  <td><code>arma::Col&lt;int&gt;</code></td>
</tr>
<tr>
  <td>50</td>
  <td><code>arma::Row&lt;float&gt;</code></td>
  <td>51</td>
  <td><code>arma::Row&lt;double&gt;</code></td>
  <td>52</td>
  <td><code>arma::Row&lt;arma::uword&gt;</code></td>
</tr>
<tr>
  <td>53</td>
  <td><code>arma::Row&lt;arma::sword&gt;</code></td>
  <td>54</td>
  <td><code>arma::Row&lt;unsigned&gt;</code></td>
  <td>55</td>
  <td><code>arma::Row&lt;int&gt;</code></td>
</tr>
</table><br>
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="baseband_freq_response"></a>
<b>baseband_freq_response</b> - Compute the baseband frequency response of a MIMO channel
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Computes the frequency-domain response of a time-domain MIMO channel using a discrete Fourier transform (DFT). 
</li><li style="margin-bottom: 0.4em;">Input consists of real and imaginary channel coefficients and corresponding delays for each MIMO sub-link. 
</li><li style="margin-bottom: 0.4em;">Outputs the complex channel response matrix <code>H</code> at given sub-carrier frequency positions. 
</li><li style="margin-bottom: 0.4em;">Internally uses AVX2 instructions for fast parallel computation of 8 carriers at once. 
</li><li style="margin-bottom: 0.4em;">Can be efficiently called in a loop (e.g., over snapshots) and parallelized with OpenMP. 
</li><li style="margin-bottom: 0.4em;">Internal arithmetic is performed in single precision for speed. 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
void quadriga_lib::baseband_freq_response(
                const arma::Cube&lt;dtype&gt; *coeff_re,
                const arma::Cube&lt;dtype&gt; *coeff_im,
                const arma::Cube&lt;dtype&gt; *delay,
                const arma::Col&lt;dtype&gt; *pilot_grid,
                const double bandwidth,
                arma::Cube&lt;dtype&gt; *hmat_re,
                arma::Cube&lt;dtype&gt; *hmat_im);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>const arma::Cube&lt;dtype&gt; <b>*coeff_re</b></code> (input)<br> 
   Real part of channel coefficients in time domain, Size <code>[n_rx, n_tx, n_path]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Cube&lt;dtype&gt; <b>*coeff_im</b></code> (input)<br> 
   Imaginary part of channel coefficients in time domain, Size <code>[n_rx, n_tx, n_path]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Cube&lt;dtype&gt; <b>*delay</b></code> (input)<br> 
   Path delays in seconds. Size <code>[n_rx, n_tx, n_path]</code> or broadcastable shape <code>[1, 1, n_path]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Col&lt;dtype&gt; <b>*pilot_grid</b></code> (input)<br> 
   Normalized sub-carrier positions relative to bandwidth. Range: <code>0.0</code> (center freq) to <code>1.0</code> (center + bandwidth). Length: <code>n_carriers</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const double <b>bandwidth</b></code> (input)<br> 
   Total baseband bandwidth in Hz (defines absolute frequency spacing of the pilot grid). 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Cube&lt;dtype&gt; <b>*hmat_re</b></code> (output)<br> 
   Output: Real part of the frequency-domain channel matrix, Size <code>[n_rx, n_tx, n_carriers]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Cube&lt;dtype&gt; <b>*hmat_im</b></code> (output)<br> 
   Output: Imaginary part of the frequency-domain channel matrix, Size <code>[n_rx, n_tx, n_carriers]</code>. 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="baseband_freq_response_vec"></a>
<b>baseband_freq_response_vec</b> - Compute the baseband frequency response of multiple MIMO channels
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Computes the frequency-domain response of a batch of time-domain MIMO channels using a discrete Fourier transform (DFT). 
</li><li style="margin-bottom: 0.4em;">This function wraps <code>quadriga_lib::baseband_freq_response</code> and applies it across multiple snapshots in parallel using OpenMP. 
</li><li style="margin-bottom: 0.4em;">Input consists of vectors of real/imaginary coefficients and delay Cubes for each snapshot. 
</li><li style="margin-bottom: 0.4em;">Output is a vector of frequency-domain channel matrices <code>H</code> (one per snapshot). 
</li><li style="margin-bottom: 0.4em;">Can optionally compute a selected subset of snapshots using <code>i_snap</code>. 
</li><li style="margin-bottom: 0.4em;">Internal arithmetic is performed in single precision for performance. 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
void quadriga_lib::baseband_freq_response_vec(
                const std::vector&lt;arma::Cube&lt;dtype&gt;&gt; *coeff_re,
                const std::vector&lt;arma::Cube&lt;dtype&gt;&gt; *coeff_im,
                const std::vector&lt;arma::Cube&lt;dtype&gt;&gt; *delay,
                const arma::Col&lt;dtype&gt; *pilot_grid,
                const double bandwidth,
                std::vector&lt;arma::Cube&lt;dtype&gt;&gt; *hmat_re,
                std::vector&lt;arma::Cube&lt;dtype&gt;&gt; *hmat_im,
                const arma::u32_vec *i_snap = nullptr);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>const std::vector&lt;arma::Cube&lt;dtype&gt;&gt; <b>*coeff_re</b></code> (input)<br> 
   Real part of channel coefficients, vector of length <code>n_snap</code>. Each cube has shape <code>[n_rx, n_tx, n_path]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const std::vector&lt;arma::Cube&lt;dtype&gt;&gt; <b>*coeff_im</b></code> (input)<br> 
   Imaginary part of channel coefficients, same structure as <code>coeff_re</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const std::vector&lt;arma::Cube&lt;dtype&gt;&gt; <b>*delay</b></code> (input)<br> 
   Path delays in seconds, same structure as <code>coeff_re</code>, shape can be broadcasted <code>[1, 1, n_path]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Col&lt;dtype&gt; <b>*pilot_grid</b></code> (input)<br> 
   Normalized sub-carrier positions relative to bandwidth. Range: <code>0.0</code> (center freq) to <code>1.0</code> (center + bandwidth). Length: <code>n_carriers</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const double <b>bandwidth</b></code> (input)<br> 
   Total baseband bandwidth in Hz, used to compute sub-carrier frequencies. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>std::vector&lt;arma::Cube&lt;dtype&gt;&gt; <b>*hmat_re</b></code> (output)<br> 
   Output: Real part of the frequency-domain channel matrices. Vector of length <code>n_out</code>. Each cube is <code>[n_rx, n_tx, n_carriers]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>std::vector&lt;arma::Cube&lt;dtype&gt;&gt; <b>*hmat_im</b></code> (output)<br> 
   Output: Imaginary part of the frequency-domain channel matrices. Same structure as <code>hmat_re</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::u32_vec <b>*i_snap</b> = nullptr</code> (optional input)<br> 
   Optional subset of snapshot indices to process. If omitted, all <code>n_snap</code> snapshots are processed. Length: <code>n_out</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>See also:</i></b><br><ul><li style="margin-bottom: 0.4em;"><a href="#baseband_freq_response">baseband_freq_response</a> (for processing a single snapshot) 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="get_hdf5_version"></a>
<b>get_hdf5_version</b> - Get the version of the linked HDF5 library
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Returns the version string of the HDF5 library used during linking. 
</li><li style="margin-bottom: 0.4em;">This function is useful for diagnostics, compatibility checks, or logging. 
</li><li style="margin-bottom: 0.4em;">The function reflects the version of the compiled HDF5 library, not necessarily the version of the header used at compile time. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
std::string quadriga_lib::get_HDF5_version();
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Returns:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>std::string</code><br> 
   HDF5 version string in the format <code>"x.y.z"</code>, e.g., <code>"1.12.2"</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Example:</i></b><br><pre>
std::string hdf5_ver = quadriga_lib::get_HDF5_version();
std::cout &lt;&lt; "Using HDF5 version: " &lt;&lt; hdf5_ver &lt;&lt; std::endl;
</pre>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="hdf5_create"></a>
<b>hdf5_create</b> - Create a new HDF5 channel file with a defined storage layout
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Quadriga-Lib offers an HDF5-based method for storing and managing channel data. A key feature of this 
   library is its ability to organize multiple channels within a single HDF5 file while enabling access 
   to individual data sets without the need to read the entire file. 
</li><li style="margin-bottom: 0.4em;">This function initializes a new HDF5 file for storing wireless channel data. 
</li><li style="margin-bottom: 0.4em;">Defines a multi-dimensional array layout for organizing channels (up to 4 dimensions). 
</li><li style="margin-bottom: 0.4em;">Typical usage: map base stations (BS), user equipment (UE), and frequencies to dimensions. 
</li><li style="margin-bottom: 0.4em;">The layout can later be reshaped using <code>hdf5_reshape_layout</code>, provided the total number of entries remains constant. 
</li><li style="margin-bottom: 0.4em;">Each combination of indices corresponds to a storage slot that can hold a channel object. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
void quadriga_lib::hdf5_create(
                std::string fn,
                unsigned nx = 65536,
                unsigned ny = 1,
                unsigned nz = 1,
                unsigned nw = 1);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>std::string <b>fn</b></code> (input)<br> 
   Filename (including path) of the HDF5 file to be created. If the file exists, it will be overwritten. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>unsigned <b>nx</b> = 65536</code> (input)<br> 
   Number of entries in the <b>x-dimension</b>, e.g., for base stations (BSs). Default: <code>65536</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>unsigned <b>ny</b> = 1</code> (input)<br> 
   Number of entries in the <b>y-dimension</b>, e.g., for user equipment (UEs). Default: <code>1</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>unsigned <b>nz</b> = 1</code> (input)<br> 
   Number of entries in the <b>z-dimension</b>, e.g., for frequency points. Default: <code>1</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>unsigned <b>nw</b> = 1</code> (input)<br> 
   Number of entries in the <b>w-dimension</b>, e.g., for repetitions, scenarios, or configurations. Default: <code>1</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Example:</i></b><br><pre>
// Create a file with layout: [10 BSs, 4 UEs, 2 frequencies]
quadriga_lib::hdf5_create("channels.hdf5", 10, 4, 2);
</pre>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="hdf5_read_layout"></a>
<b>hdf5_read_layout</b> - Read the HDF5 channel storage layout
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Reads the structure of the storage layout in an HDF5 file created for channel data. 
</li><li style="margin-bottom: 0.4em;">Returns the size of each of the four dimensions: <code>{nx, ny, nz, nw}</code>. 
</li><li style="margin-bottom: 0.4em;">Can optionally return a serialized list of channel IDs to indicate which entries contain data. 
</li><li style="margin-bottom: 0.4em;">If the file does not exist or is not a valid channel HDF5 file, the returned layout is <code>{0, 0, 0, 0}</code>. 
</li><li style="margin-bottom: 0.4em;">Entries in <code>channelID</code> are set to <code>0</code> if no data is present at that index. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
arma::u32_vec quadriga_lib::hdf5_read_layout(
                std::string fn,
                arma::u32_vec *channelID = nullptr);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>std::string <b>fn</b></code> (input)<br> 
   Path to the HDF5 file. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::u32_vec <b>*channelID</b> = nullptr</code> (optional output)<br> 
   Pointer to a vector receiving the serialized channel index contents.<br> 
   Length: <code>nx × ny × nz × nw</code>, where <code>channelID[i] == 0</code> indicates an empty slot. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Returns:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>arma::u32_vec</code><br> 
   Containing four elements: <code>{nx, ny, nz, nw}</code>, the layout of the storage grid. 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="hdf5_write"></a>
<b>hdf5_write</b> - Write channel data to HDF5 file
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Quadriga-Lib provides an HDF5-based solution for storing and organizing channel data. 
</li><li style="margin-bottom: 0.4em;">This function rites a <code>channel</code> object to a specified HDF5 file at the given 4D index location. 
</li><li style="margin-bottom: 0.4em;">If the file does not exist, a new file is created with default layout <code>(65535 × 1 × 1 × 1)</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
int quadriga_lib::hdf5_write(
                const quadriga_lib::channel&lt;dtype&gt; *ch,
                std::string fn,
                unsigned ix = 0,
                unsigned iy = 0,
                unsigned iz = 0,
                unsigned iw = 0,
                bool assume_valid = false);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>const channel&lt;dtype&gt; <b>*ch</b></code> (input)<br> 
   Pointer to the channel object to be stored. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>std::string <b>fn</b></code> (input)<br> 
   Path to the HDF5 file. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>unsigned <b>ix</b> = 0</code> (input)<br> 
   Index in the x-dimension (e.g., Base Station ID). Default: <code>0</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>unsigned <b>iy</b> = 0</code> (input)<br> 
   Index in the y-dimension (e.g., User Equipment ID). Default: <code>0</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>unsigned <b>iz</b> = 0</code> (input)<br> 
   Index in the z-dimension (e.g., Frequency point). Default: <code>0</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>unsigned <b>iw</b> = 0</code> (input)<br> 
   Index in the w-dimension (e.g., Repetition/Scenario). Default: <code>0</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>bool <b>assume_valid</b> = false</code> (input)<br> 
   If <code>true</code>, skips channel integrity validation before writing. Default: <code>false</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Returns:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>0</code> if a new dataset was created. 
</li><li style="margin-bottom: 0.4em;"><code>1</code> if an existing dataset was overwritten or extended. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Caveat:</i></b><br><ul><li style="margin-bottom: 0.4em;">If the file exists already, the new data is added to the exisiting file 
</li><li style="margin-bottom: 0.4em;">If the index already contains data, it will be overwritten 
</li><li style="margin-bottom: 0.4em;">Use <code>assume_valid = true</code> to skip internal validation (faster, but unsafe if data may be corrupted). 
</li><li style="margin-bottom: 0.4em;">Throws an error if the index was not reserved during <code>hdf5_create</code>. 
</li><li style="margin-bottom: 0.4em;">All structured data is written in single precision (but can can be provided as float or double) 
</li><li style="margin-bottom: 0.4em;">Unstructured datatypes are maintained in the HDF file 
</li><li style="margin-bottom: 0.4em;">Supported unstructured types: string, double, float, (u)int32, (u)int64 
</li><li style="margin-bottom: 0.4em;">Supported unstructured size: up to 3 dimensions 
</li><li style="margin-bottom: 0.4em;">Storage order of the unstructured data is maintained 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="hdf5_read_channel"></a>
<b>hdf5_read_channel</b> - Read a channel object from an HDF5 file
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Loads a <code>quadriga_lib::channel&lt;dtype&gt;</code> object from the specified index in a previously created HDF5 file. 
</li><li style="margin-bottom: 0.4em;">If the selected index does not contain a valid channel, an empty channel object is returned (with <code>no_snapshots == 0</code>). 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code> 
</li><li style="margin-bottom: 0.4em;">All structured data (e.g., channel coefficients, delays, positions) is stored in <b>single precision</b> in the 
   file but will be <b>converted</b> to the appropriate precision (<code>float</code> or <code>double</code>) depending on the provided template parameter. 
</li><li style="margin-bottom: 0.4em;">Unstructured or user-defined fields stored in <code>std::any</code> containers are not converted and retain their original type 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
quadriga_lib::channel&lt;dtype&gt; quadriga_lib::hdf5_read_channel(
                std::string fn,
                unsigned ix = 0,
                unsigned iy = 0,
                unsigned iz = 0,
                unsigned iw = 0);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>std::string <b>fn</b></code> (input)<br> 
   Filename of the HDF5 file containing the channel data. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>unsigned <b>ix</b> = 0</code> (input)<br> 
   x-Index in the file's 4D storage layout. Default: <code>0</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>unsigned <b>iy</b> = 0</code> (input)<br> 
   y-Index in the file's 4D storage layout. Default: <code>0</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>unsigned <b>iz</b> = 0</code> (input)<br> 
   z-Index in the file's 4D storage layout. Default: <code>0</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>unsigned <b>iw</b> = 0</code> (input)<br> 
   w-Index in the file's 4D storage layout. Default: <code>0</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Returns:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>quadriga_lib::channel&lt;dtype&gt;</code> 
   A channel object containing the channel data at the specified index. If no data is found, an empty channel object is returned. 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="hdf5_reshape_layout"></a>
<b>hdf5_reshape_layout</b> - Reshape the storage layout of an HDF5 channel file
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Updates the multi-dimensional storage layout of an existing HDF5 file that contains channel data. 
</li><li style="margin-bottom: 0.4em;">The layout consists of up to four dimensions: <code>{nx, ny, nz, nw}</code>. 
</li><li style="margin-bottom: 0.4em;">This is useful for reorganizing data after initial creation (e.g., grouping entries by BS/UE/frequency). 
</li><li style="margin-bottom: 0.4em;">The total number of entries must remain unchanged, i.e., <code>nx × ny × nz × nw</code> must equal the original layout. 
</li><li style="margin-bottom: 0.4em;">Throws an error if the reshaped layout violates this constraint. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
void quadriga_lib::hdf5_reshape_layout(
                std::string fn,
                unsigned nx,
                unsigned ny = 1,
                unsigned nz = 1,
                unsigned nw = 1);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>std::string <b>fn</b></code> (input)<br> 
   Filename of the HDF5 file to reshape. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>unsigned <b>nx</b></code> (input)<br> 
   Number of entries in the first dimension (e.g., base stations). 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>unsigned <b>ny</b> = 1</code> (input)<br> 
   Number of entries in the second dimension (e.g., user equipment). Default: <code>1</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>unsigned <b>nz</b> = 1</code> (input)<br> 
   Number of entries in the third dimension (e.g., carrier frequency). Default: <code>1</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>unsigned <b>nw</b> = 1</code> (input)<br> 
   Number of entries in the fourth dimension. Default: <code>1</code>. 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="hdf5_read_dset"></a>
<b>hdf5_read_dset</b> - Read an unstructured dataset from an HDF5 file
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Reads a user-defined, unstructured dataset stored in an HDF5 file at the specified index. 
</li><li style="margin-bottom: 0.4em;">Unstructured datasets are typically used to store additional parameters or metadata and are stored under a <b>name prefix</b> (e.g. <code>"par_"</code>) followed by the dataset name. 
</li><li style="margin-bottom: 0.4em;">Returns the dataset as a <code>std::any</code> object, which can hold any supported type (e.g., scalar values, vectors, matrices, cubes). 
</li><li style="margin-bottom: 0.4em;">Use <code>quadriga_lib::any_type_id</code> to determine the contained type and obtain a raw pointer for direct access. 
</li><li style="margin-bottom: 0.4em;">If the dataset does not exist at the specified index or name, an empty <code>std::any</code> object is returned. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
std::any quadriga_lib::hdf5_read_dset(
                std::string fn,
                std::string par_name,
                unsigned ix = 0,
                unsigned iy = 0,
                unsigned iz = 0,
                unsigned iw = 0,
                std::string prefix = "par_");
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>std::string <b>fn</b></code> (input)<br> 
   Filename of the HDF5 file containing the dataset. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>std::string <b>par_name</b></code> (input)<br> 
   Name of the dataset, <b>without</b> the prefix (e.g., <code>"carrier_frequency"</code>). 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>unsigned <b>ix</b> = 0</code> (input)<br> 
   x-Index in the HDF5 file’s 4D storage layout. Default: <code>0</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>unsigned <b>iy</b> = 0</code> (input)<br> 
   y-Index in the HDF5 file’s 4D storage layout. Default: <code>0</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>unsigned <b>iz</b> = 0</code> (input)<br> 
   z-Index in the HDF5 file’s 4D storage layout. Default: <code>0</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>unsigned <b>iw</b> = 0</code> (input)<br> 
   w-Index in the HDF5 file’s 4D storage layout. Default: <code>0</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>std::string <b>prefix</b> = "par_"</code> (input)<br> 
   Optional dataset name prefix. Default is <code>"par_"</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Returns:</i></b><br><ul><li style="margin-bottom: 0.4em;">A <code>std::any</code> object containing the dataset. If the dataset is not present, the return value is an empty <code>std::any</code>. 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="hdf5_read_dset_names"></a>
<b>hdf5_read_dset_names</b> - Read names of unstructured datasets from an HDF5 file
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Retrieves the names of all unstructured datasets stored at a specified 4D index in an HDF5 file. 
</li><li style="margin-bottom: 0.4em;">Dataset names are identified by a common prefix (default: <code>"par_"</code>) and the actual parameter name follows the prefix. 
</li><li style="margin-bottom: 0.4em;">The returned names in <code>par_names</code> exclude the prefix for convenience. 
</li><li style="margin-bottom: 0.4em;">Returns the number of datasets found at the given index. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
arma::uword quadriga_lib::hdf5_read_dset_names(
                std::string fn,
                std::vector&lt;std::string&gt; *par_names,
                unsigned ix = 0,
                unsigned iy = 0,
                unsigned iz = 0,
                unsigned iw = 0,
                std::string prefix = "par_");
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>std::string <b>fn</b></code> (input)<br> 
   Filename of the HDF5 file containing the datasets. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>std::vector&lt;std::string&gt; <b>*par_names</b></code> (output)<br> 
   Pointer to a vector that will be filled with all dataset names found at the specified index (excluding the prefix). 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>unsigned <b>ix</b> = 0</code> (input)<br> 
   x-Index in the HDF5 file’s 4D layout. Default: <code>0</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>unsigned <b>iy</b> = 0</code> (input)<br> 
   y-Index in the HDF5 file’s 4D layout. Default: <code>0</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>unsigned <b>iz</b> = 0</code> (input)<br> 
   z-Index in the HDF5 file’s 4D layout. Default: <code>0</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>unsigned <b>iw</b> = 0</code> (input)<br> 
   w-Index in the HDF5 file’s 4D layout. Default: <code>0</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>std::string <b>prefix</b> = "par_"</code> (input)<br> 
   Optional prefix string used to identify unstructured datasets. Default: <code>"par_"</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Returns:</i></b><br><ul><li style="margin-bottom: 0.4em;">The number of unstructured datasets found at the specified location with the given prefix. 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="hdf5_write_dset"></a>
<b>hdf5_write_dset</b> - Write a single unstructured dataset to an HDF5 file
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Writes a single unstructured data field to an HDF5 file at the specified 4D index. 
</li><li style="margin-bottom: 0.4em;">Supported scalar types: <code>std::string</code>, <code>unsigned</code>, <code>int</code>, <code>long long</code>, <code>unsigned long long</code>, <code>float</code>, <code>double</code> 
</li><li style="margin-bottom: 0.4em;">Supported Armadillo types: <code>arma::Col</code>, <code>arma::Row</code>, <code>arma::Mat</code>, and <code>arma::Cube</code> with <code>float</code>, <code>double</code>, <code>int</code>, <code>unsigned</code>, <code>sword</code>, <code>uword</code>, <code>unsigned long long</code> 
</li><li style="margin-bottom: 0.4em;"><code>arma::Row</code> vectors are converted to column vectors (<code>arma::Col</code>) before writing. 
</li><li style="margin-bottom: 0.4em;">The dataset name is prefixed with <code>"par_"</code> (default) unless another prefix is specified. 
</li><li style="margin-bottom: 0.4em;">Throws an error for unsupported types. 
</li><li style="margin-bottom: 0.4em;">Dataset names may only include alphanumeric characters and underscores. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
void quadriga_lib::hdf5_write_dset(
                std::string fn,
                std::string par_name,
                const std::any \*par_data,
                unsigned ix = 0,
                unsigned iy = 0,
                unsigned iz = 0,
                unsigned iw = 0,
                std::string prefix = "par_");
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>std::string <b>fn</b></code> (input)<br> 
   Filename of the HDF5 file to which the dataset will be written. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>std::string <b>par_name</b></code> (input)<br> 
   Name of the parameter to store (without prefix). Must contain only letters, digits, and underscores. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const std::any <b>*par_data</b></code> (input)<br> 
   Pointer to the data to be written. Type must be supported (see above). 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>unsigned <b>ix</b> = 0</code> (input)<br> 
   x-Index in the HDF5 file’s 4D layout. Default: <code>0</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>unsigned <b>iy</b> = 0</code> (input)<br> 
   y-Index in the HDF5 file’s 4D layout. Default: <code>0</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>unsigned <b>iz</b> = 0</code> (input)<br> 
   z-Index in the HDF5 file’s 4D layout. Default: <code>0</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>unsigned <b>iw</b> = 0</code> (input)<br> 
   w-Index in the HDF5 file’s 4D layout. Default: <code>0</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>std::string <b>prefix</b> = "par_"</code> (input)<br> 
   Optional prefix for the dataset name. Default: <code>"par_"</code>. 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div>
<hr class="greyline">
<hr class="greyline">
<br>
<br>
<font size=+1><b>Miscellaneous tools</b></font>
<br>
<br>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="calc_rotation_matrix"></a>
<b>calc_rotation_matrix</b> - Calculate rotation matrices from Euler angles
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Computes 3D rotation matrices from input Euler angles (bank, tilt, head). 
</li><li style="margin-bottom: 0.4em;">The result is returned in column-major order as a 3×3 matrix per input orientation vector. 
</li><li style="margin-bottom: 0.4em;">Calculations are internally performed in double precision for improved numerical accuracy, even if <code>dtype</code> is <code>float</code>. 
</li><li style="margin-bottom: 0.4em;">Supports optional inversion of the y-axis and optional transposition of the output matrix. 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
arma::Cube&lt;dtype&gt; quadriga_lib::calc_rotation_matrix(const arma::Cube&lt;dtype&gt; &amp;orientation,
                bool invert_y_axis = false, bool transposeR = false);

arma::Mat&lt;dtype&gt; quadriga_lib::calc_rotation_matrix(const arma::Mat&lt;dtype&gt; &amp;orientation,
                bool invert_y_axis = false, bool transposeR = false);

arma::Col&lt;dtype&gt; quadriga_lib::calc_rotation_matrix(const arma::Col&lt;dtype&gt; &amp;orientation,
                bool invert_y_axis = false, bool transposeR = false);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>const arma::Cube&lt;dtype&gt; <b>&amp;orientation</b></code> or <code>const arma::Mat&lt;dtype&gt; <b>&amp;orientation</b></code> or <code>const arma::Col&lt;dtype&gt; <b>&amp;orientation</b></code> (input)<br> 
   Input Euler angles (bank, tilt, head) in radians, Size <code>[3, n_row, n_col]</code> or <code>[3, n_mat]</code> or Size <code>[3]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>bool <b>invert_y_axis</b> = false</code> (optional input)<br> 
   If true, the y-axis of the rotation is inverted. Default: <code>false</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>bool <b>transposeR</b> = false</code> (optional input)<br> 
   If true, the transpose of the rotation matrix is returned. Default: <code>false</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Returns:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>arma::Cube&lt;dtype&gt;</code> or <code>arma::Mat&lt;dtype&gt;</code> or <code>arma::Col&lt;dtype&gt;</code><br> 
   Rotation matrices in column-major ordering. Size <code>[9, n_row, n_col]</code> or <code>[9, n_mat]</code> or <code>[9]</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Example:</i></b><br><pre>
arma::cube ori(3, 1, 1);
ori(0, 0, 0) = 0.0;         // bank
ori(1, 0, 0) = 0.0;         // tilt
ori(2, 0, 0) = 1.5708;      // head
auto R = quadriga_lib::calc_rotation_matrix(ori);
</pre>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="cart2geo"></a>
<b>cart2geo</b> - Convert Cartesian coordinates to geographic coordinates (azimuth, elevation, distance)
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Transforms 3D Cartesian coordinates <code>(x, y, z)</code> into geographic coordinates: 
   - Azimuth angle [rad] 
   - Elevation angle [rad] 
   - Distance (vector norm) 
</li><li style="margin-bottom: 0.4em;">Azimuth is measured in the x-y plane from the x-axis; elevation is from the x-y plane upward. 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
arma::Cube&lt;dtype&gt; quadriga_lib::cart2geo(const arma::Cube&lt;dtype&gt; &amp;cart);

arma::Mat&lt;dtype&gt; quadriga_lib::cart2geo(const arma::Mat&lt;dtype&gt; &amp;cart);

arma::Col&lt;dtype&gt; quadriga_lib::cart2geo(const arma::Col&lt;dtype&gt; &amp;cart);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>const arma::Cube&lt;dtype&gt; <b><i>cart</b></code> or <code>const arma::Mat&lt;dtype&gt; <b></i>cart</b></code> or <code>const arma::Col&lt;dtype&gt; <b>cart</b></code> (input)<br> 
   Cartesian coordinate vectors (x, y, z), Size <code>[3, n_row, n_col]</code> or <code>[3, n_row]</code> or <code>[3]</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Returns:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>arma::Cube&lt;dtype&gt;</code> or <code>arma::Mat&lt;dtype&gt;</code> or <code>arma::Col&lt;dtype&gt;</code><br> 
   Geographic coordinate vectors <code>(azimuth, elevation, distance)</code>, Size <code>[n_row, n_col, 3]</code> or <code>[n_row, 3]</code> or <code>[3]</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Example:</i></b><br><pre>
arma::vec cart = {1.0, 1.0, 1.0};
auto geo = quadriga_lib::cart2geo(cart);
</pre>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="colormap"></a>
<b>colormap</b> - Generate colormap
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Returns a 64x3 or 256x3 colormap matrix with RGB values in unsigned char format. 
</li><li style="margin-bottom: 0.4em;">Each row corresponds to an RGB color entry of the selected colormap. 
</li><li style="margin-bottom: 0.4em;">Useful for visualization purposes (e.g., heatmaps or 3D rendering). 
</li><li style="margin-bottom: 0.4em;">Available color maps include: <code>jet</code>, <code>parula</code>, <code>winter</code>, <code>hot</code>, <code>turbo</code>, <code>copper</code>, <code>spring</code>, <code>cool</code>, <code>gray</code>, <code>autumn</code>, <code>summer</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
arma::uchar_mat quadriga_lib::colormap(std::string map, bool high_res = false)
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>std::string <b>map</b></code> (input)<br> 
   Name of the desired colormap. Must be one of: 
   <code>"jet"</code>, <code>"parula"</code>, <code>"winter"</code>, <code>"hot"</code>, <code>"turbo"</code>, <code>"copper"</code>, <code>"spring"</code>, <code>"cool"</code>, <code>"gray"</code>, <code>"autumn"</code>, <code>"summer"</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>bool <b>high_res</b></code> (input)<br> 
   Enables 256 color steps 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Returns:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>arma::uchar_mat</code><br> 
   A matrix of size <code>[64 x 3]</code> or <code>[256 x 3]</code> containing RGB color values as unsigned chars in the range <code>[0, 255]</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Example:</i></b><br><pre>
arma::uchar_mat cm = quadriga_lib::colormap("turbo");
</pre>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="geo2cart"></a>
<b>geo2cart</b> - Transform geographic (azimuth, elevation, length) to Cartesian coordinates
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Converts azimuth and elevation angles (in radians) into 3D Cartesian coordinates. 
</li><li style="margin-bottom: 0.4em;">Optional radial distance (<code>length</code>) can be provided; otherwise, unit vectors are returned. 
</li><li style="margin-bottom: 0.4em;">Useful for converting spherical direction data into vector representations. 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
arma::Cube&lt;dtype&gt; quadriga_lib::geo2cart(
                const arma::Mat&lt;dtype&gt; &amp;azimuth,
                const arma::Mat&lt;dtype&gt; &amp;elevation,
                const arma::Mat&lt;dtype&gt; &amp;length = {})
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>azimuth</b></code> (input)<br> 
   Azimuth angles in radians. Size <code>[n_row, n_col]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>elevation</b></code> (input)<br> 
   Elevation angles in radians. Size <code>[n_row, n_col]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>length</b> = {}</code> (optional input)<br> 
   Radial distance (length). Same size as azimuth/elevation or empty for unit vectors. Size <code>[n_row, n_col]</code> or <code>[0, 0]</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Returns:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>arma::Cube&lt;dtype&gt;</code> (output)<br> 
   Cartesian coordinates with dimensions <code>[3, n_row, n_col]</code>, representing (x, y, z) for each input direction. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Example:</i></b><br><pre>
arma::mat az(2, 2), el(2, 2), len(2, 2, arma::fill::ones);
auto cart = quadriga_lib::geo2cart(az, el, len);
</pre>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="interp_1d / interp_2d"></a>
<b>interp_1d / interp_2d</b> - Perform linear interpolation (1D or 2D) on single or multiple data sets.
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Interpolates given input data at specified output points. 
</li><li style="margin-bottom: 0.4em;">Supports single and multiple data sets. 
</li><li style="margin-bottom: 0.4em;">Returns interpolated results either directly or through reference argument. 
</li><li style="margin-bottom: 0.4em;">Data types (<code>dtype</code>): <code>float</code> or <code>double</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declarations:</i></b><br><pre>
void interp_2D(const arma::Cube&lt;dtype&gt; &amp;input, const arma::Col&lt;dtype&gt; &amp;xi, const arma::Col&lt;dtype&gt; &amp;yi,
               const arma::Col&lt;dtype&gt; &amp;xo, const arma::Col&lt;dtype&gt; &amp;yo, arma::Cube&lt;dtype&gt; &amp;output);

arma::Cube&lt;dtype&gt; interp_2D(const arma::Cube&lt;dtype&gt; &amp;input, const arma::Col&lt;dtype&gt; &amp;xi, const arma::Col&lt;dtype&gt; &amp;yi,
                            const arma::Col&lt;dtype&gt; &amp;xo, const arma::Col&lt;dtype&gt; &amp;yo);

arma::Mat&lt;dtype&gt; interp_2D(const arma::Mat&lt;dtype&gt; &amp;input, const arma::Col&lt;dtype&gt; &amp;xi, const arma::Col&lt;dtype&gt; &amp;yi,
                           const arma::Col&lt;dtype&gt; &amp;xo, const arma::Col&lt;dtype&gt; &amp;yo);

arma::Mat&lt;dtype&gt; interp_1D(const arma::Mat&lt;dtype&gt; &amp;input, const arma::Col&lt;dtype&gt; &amp;xi, const arma::Col&lt;dtype&gt; &amp;xo);

arma::Col&lt;dtype&gt; interp_1D(const arma::Col&lt;dtype&gt; &amp;input, const arma::Col&lt;dtype&gt; &amp;xi, const arma::Col&lt;dtype&gt; &amp;xo);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>input</code>: Input data array/matrix (size details below) 
</li><li style="margin-bottom: 0.4em;"><code>xi</code>: Input x-axis sampling points, vector of length <code>nx</code> 
</li><li style="margin-bottom: 0.4em;"><code>yi</code>: Input y-axis sampling points (for 2D only), vector of length <code>ny</code> 
</li><li style="margin-bottom: 0.4em;"><code>xo</code>: Output x-axis sampling points, vector of length <code>mx</code> 
</li><li style="margin-bottom: 0.4em;"><code>yo</code>: Output y-axis sampling points (for 2D only), vector of length <code>my</code> 
</li><li style="margin-bottom: 0.4em;"><code>output</code>: Interpolated data cube (modified in-place for one variant) 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input / Output size details:</i></b><br><ul><li style="margin-bottom: 0.4em;">2D interpolation of multiple datasets (<code>arma::Cube</code>):<br> 
   Input size: <code>[ny, nx, ne]</code>, Output size: <code>[my, mx, ne]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;">2D interpolation of single dataset (<code>arma::Mat</code>):<br> 
   Input size: <code>[ny, nx]</code>, Output size: <code>[my, mx]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;">1D interpolation of multiple datasets (<code>arma::Mat</code>):<br> 
   Input size: <code>[nx, ne]</code>, Output size: <code>[mx, ne]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;">1D interpolation of single dataset (<code>arma::Col</code>):<br> 
   Input length: <code>[nx]</code>, Output length: <code>[mx]</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Examples:</i></b><br><ul><li style="margin-bottom: 0.4em;">2D interpolation example: 
</li></ul>
<pre>
arma::cube input(5, 5, 2, arma::fill::randu); // example input data
arma::vec xi = arma::linspace(0, 4, 5);
arma::vec yi = arma::linspace(0, 4, 5);
arma::vec xo = arma::linspace(0, 4, 10);
arma::vec yo = arma::linspace(0, 4, 10);

arma::cube output;
quadriga_lib::interp_2D(input, xi, yi, xo, yo, output);
</pre>
<ul><li style="margin-bottom: 0.4em;">1D interpolation example: 
</li></ul>
<pre>
arma::vec input = arma::linspace(0, 1, 5);
arma::vec xi = arma::linspace(0, 4, 5);
arma::vec xo = arma::linspace(0, 4, 10);

auto output = quadriga_lib::interp_1D(input, xi, xo);
</pre>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="write_png"></a>
<b>write_png</b> - Write data to a PNG file
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Converts input data into a color-coded PNG file for visualization 
</li><li style="margin-bottom: 0.4em;">Support optional selection of a colormap, as well a minimum and maximum value limits 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code> 
</li><li style="margin-bottom: 0.4em;">Uses the <a href="https://github.com/lvandeve/lodepng">LodePNG</a> library for PNG writing 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
void write_png( const arma::Mat&lt;dtype&gt; &amp;data, 
                std::string fn,              
                std::string colormap = "jet", 
                dtype min_val = NAN, 
                dtype max_val = NAN, 
                bool log_transform = false);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>&amp;data</b></code><br> 
   Data matrix 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>std::string <b>fn</b></code><br> 
   Path to the <code>.png</code> file to be written 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>std::string <b>colormap</b></code><br> 
   Name of the desired colormap. Must be one of: 
   <code>"jet"</code>, <code>"parula"</code>, <code>"winter"</code>, <code>"hot"</code>, <code>"turbo"</code>, <code>"copper"</code>, <code>"spring"</code>, <code>"cool"</code>, <code>"gray"</code>, <code>"autumn"</code>, <code>"summer"</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>min_val</b></code><br> 
   Minimum value. Values below this value will have be encoded with the color of the smallest value. 
   If <code>NAN</code> is provided (default), the lowest values is determined from the data. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>max_val</b></code><br> 
   Maximum value. Values above this value will have be encoded with the color of the largest value. 
   If <code>NAN</code> is provided (default), the largest values is determined from the data. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>bool <b>log_transform</b></code><br> 
   If enabled, the <code>data</code> values are transformed to the log-domain (<code>10*log10(data)</code>) before processing. 
   Default: false (disabled) 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>See also:</i></b><br><ul><li style="margin-bottom: 0.4em;"><a href="#colormap">colormap</a> 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div>
<hr class="greyline">
<hr class="greyline">
<br>
<br>
<font size=+1><b>Site-Specific Simulation Tools</b></font>
<br>
<br>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="calc_diffraction_gain"></a>
<b>calc_diffraction_gain</b> - Calculate diffraction gain for multiple transmit and receive positions
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>Diffraction refers to the phenomenon where waves bend or interfere around the edges of an obstacle, 
extending into the region that would otherwise be in the obstacle's geometrical shadow. The object 
causing the diffraction acts as a secondary source for the wave's propagation. A specific example of 
this is the knife-edge effect, or knife-edge diffraction, where a sharp, well-defined obstacle—like 
a mountain range or a building wall—partially truncates the incident radiation.<br><br> 
 
To estimate the diffraction gain in a three-dimensional space, one can assess the extent to which the 
Fresnel ellipsoid is obstructed by objects, and then evaluate the impact of this obstruction on the 
received power. This method presupposes that diffracted waves travel along slightly varied paths 
before arriving at a receiver. These waves may reach the receiver out of phase with the primary wave 
due to their different travel lengths, leading to either constructive or destructive interference.<br><br> 
 
The process of estimating the gain involves dividing the wave propagation from a transmitter to a 
receiver into <code>n_path</code> paths. These paths are represented by elliptic arcs, which are further 
approximated using <code>n_seg</code> line segments. Each segment can be individually blocked or attenuated 
by environmental objects. To determine the overall diffraction gain, a weighted sum of these 
individual path contributions is calculated. The weighting is adjusted to align with the uniform 
theory of diffraction (UTD) coefficients in two dimensions, but the methodology is adapted for 
any 3D object shape. <br><br> 
 
<ul><li style="margin-bottom: 0.4em;">This function computes the diffraction gain between multiple transmit and receive positions using a 3D triangular mesh. 
</li><li style="margin-bottom: 0.4em;">Supports accelerated computation via mesh segmentation: large meshes can be split into smaller sub-meshes to skip irrelevant geometry. 
</li><li style="margin-bottom: 0.4em;">Optionally returns the gain per link and the coordinates along the diffracted path. 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
void quadriga_lib::calc_diffraction_gain(
                const arma::Mat&lt;dtype&gt; *orig,
                const arma::Mat&lt;dtype&gt; *dest,
                const arma::Mat&lt;dtype&gt; *mesh,
                const arma::Mat&lt;dtype&gt; *mtl_prop,
                dtype center_frequency,
                int lod = 2,
                arma::Col&lt;dtype&gt; *gain = nullptr,
                arma::Cube&lt;dtype&gt; *coord = nullptr,
                int verbose = 0,
                const arma::u32_vec *sub_mesh_index = nullptr);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*orig</b></code> (input)<br> 
   Matrix of origin (transmitter) points, size <code>[n_pos, 3]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*dest</b></code> (input)<br> 
   Matrix of destination (receiver) points, size <code>[n_pos, 3]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*mesh</b></code> (input)<br> 
   Triangular mesh geometry. Each row contains 3 vertices, flattened as <code>[X1, Y1, Z1, X2, Y2, Z2, X3, Y3, Z3]</code>, size <code>[no_mesh, 9]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*mtl_prop</b></code> (input)<br> 
   Material properties per triangle, size <code>[no_mesh, 5]</code>, See <a href="#obj_file_read">obj_file_read</a> for details 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>center_frequency</b></code> (input)<br> 
   Center frequency in Hz used for diffraction calculations. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>int <b>lod</b> = 2</code> (optional input)<br> 
   Level of detail for diffraction approximation. See <a href="#generate_diffraction_paths">generate_diffraction_paths</a> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Col&lt;dtype&gt; <b>*gain</b></code> (output, optional)<br> 
   Calculated diffraction gain in linear scale, vector of size <code>[n_pos]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Cube&lt;dtype&gt; <b>*coord</b></code> (output, optional)<br> 
   Coordinates of the diffracted path, size <code>[3, n_seg-1, n_pos]</code>. Includes one point per segment excluding endpoints. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>int <b>verbose</b> = 0</code> (optional input)<br> 
   Verbosity level for debug and diagnostic output. Higher values enable more log messages. Default: <code>0</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::u32_vec <b>*sub_mesh_index</b></code> (input, optional)<br> 
   Optional sub-mesh indexing for acceleration. Vector mapping triangles to sub-meshes, length <code>[no_mesh]</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Technical Notes:</i></b><br><ul><li style="margin-bottom: 0.4em;">If <code>sub_mesh_index</code> is provided, spatial bounding boxes for each sub-mesh are automatically computed.  
   Any TX-RX path not intersecting a bounding box is excluded from detailed edge evaluation. 
</li><li style="margin-bottom: 0.4em;">The diffraction algorithm supports multiple edges and considers the geometric configuration and material properties of each triangle. 
</li><li style="margin-bottom: 0.4em;">The LOD parameter controls both accuracy and computational cost. Lower values use simplified heuristics;  
   higher values may result in significantly more computation time. 
</li><li style="margin-bottom: 0.4em;">Each ellipsoid consists of <code>n_path</code> diffraction paths. The number of paths is determined by the 
   level of detail (<code>lod</code>). See <a href="#generate_diffraction_paths">generate_diffraction_paths</a> for details  
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>See also:</i></b><br><ul><li style="margin-bottom: 0.4em;"><a href="#generate_diffraction_paths">generate_diffraction_paths</a> (for generating propagation paths for estimating the diffraction gain) 
</li><li style="margin-bottom: 0.4em;"><a href="#triangle_mesh_segmentation">triangle_mesh_segmentation</a> (for calculating the sub-meshes for acceleration) 
</li><li style="margin-bottom: 0.4em;"><a href="#obj_file_read">obj_file_read</a> (for reading 3D geometry and material data from an .obj file) 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="combine_irs_coord"></a>
<b>combine_irs_coord</b> - Combine path interaction coordinates for channels with intelligent reflective surfaces (IRS)
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Merges two propagation segments — (1) TX → IRS and (2) IRS → RX — into complete TX → RX paths via an IRS. 
</li><li style="margin-bottom: 0.4em;">Interaction coordinates of both segments are stored in a compressed format where <code>no_interact</code> is a vector of 
   length <code>n_path</code> storing the number of interactions per path and <code>interact_coord</code> stores all 
   interaction coordinates in path order. 
</li><li style="margin-bottom: 0.4em;">Each combined path includes interaction points from both segments, optionally reversed for each segment. 
</li><li style="margin-bottom: 0.4em;">The number of output paths <code>n_path_irs</code> is at most <code>n_path_1 × n_path_2</code>, but can be reduced by specifying <code>active_path</code>. 
</li><li style="margin-bottom: 0.4em;">Output includes the number and coordinates of interaction points per IRS-reflected path. 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
void quadriga_lib::combine_irs_coord(
                dtype Ix, dtype Iy, dtype Iz,
                const arma::u32_vec *no_interact_1,
                const arma::Mat&lt;dtype&gt; *interact_coord_1,
                const arma::u32_vec *no_interact_2,
                const arma::Mat&lt;dtype&gt; *interact_coord_2,
                arma::u32_vec *no_interact,
                arma::Mat&lt;dtype&gt; *interact_coord,
                bool reverse_segment_1 = false,
                bool reverse_segment_2 = false,
                const std::vector&lt;bool&gt; *active_path = nullptr);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>dtype <b>Ix</b>, <b>Iy</b>, <b>Iz</b></code> (input)<br> 
   IRS position in Cartesian coordinates <code>[m]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::u32_vec <b>*no_interact_1</b></code> (input)<br> 
   Number of interaction points in segment 1 (TX → IRS), vector of length <code>[n_path_1]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*interact_coord_1</b></code> (input)<br> 
   Interaction coordinates for segment 1, matrix of size <code>[3, sum(no_interact_1)]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::u32_vec <b>*no_interact_2</b></code> (input)<br> 
   Number of interaction points in segment 2 (IRS → RX), vector of length <code>[n_path_2]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*interact_coord_2</b></code> (input)<br> 
   Interaction coordinates for segment 2, matrix of size <code>[3, sum(no_interact_2)]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::u32_vec <b>*no_interact</b></code> (output)<br> 
   Combined number of interaction points per IRS-based path, vector of length <code>[n_path_irs]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt; <b>*interact_coord</b></code> (output)<br> 
   Combined interaction coordinates, matrix of size <code>[3, sum(no_interact)]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>bool <b>reverse_segment_1</b> = false</code> (optional input)<br> 
   If <code>true</code>, reverses the interaction coordinates of segment 1. TX and IRS positions are not swapped. Default: <code>false</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>bool <b>reverse_segment_2</b> = false</code> (optional input)<br> 
   If <code>true</code>, reverses the interaction coordinates of segment 2. IRS and RX positions are not swapped. Default: <code>false</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const std::vector&lt;bool&gt; <b>*active_path</b> = nullptr</code> (optional input)<br> 
   Optional mask vector of length <code>[n_path_1 × n_path_2]</code>. If provided, only paths with <code>true</code> are combined.  
   This is generated as the output of <a href="#get_channels_irs">get_channels_irs</a> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Technical Notes:</i></b><br><ul><li style="margin-bottom: 0.4em;">Paths are created by appending interaction coordinates from both segments. Reversing only affects the order of these coordinates. 
</li><li style="margin-bottom: 0.4em;">Output matrix <code>interact_coord</code> is built sequentially and should be preallocated only if the total number of interaction points is known in advance. 
</li><li style="margin-bottom: 0.4em;">The function supports sparsely activated paths via <code>active_path</code>, this is generated as a return value of <a href="#get_channels_irs">get_channels_irs</a> 
   and filters out paths that have very little power after being reflected by the IRS.  
</li><li style="margin-bottom: 0.4em;">This function is typically used as a complementary step to delay or coefficient calculations involving IRS-based channels.  
   It calculated the required data for visualizing paths, e.g. in Blender or other visualization tools. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>See also:</i></b><br><ul><li style="margin-bottom: 0.4em;"><a href="#get_channels_irs">get_channels_irs</a> (for computing IRS channels) 
</li><li style="margin-bottom: 0.4em;"><a href="#coord2path">coord2path</a> (for processing coordinates, calculating departure and arrival angels, etc.) 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="coord2path"></a>
<b>coord2path</b> - Convert path interaction coordinates into FBS/LBS positions, path length and angles
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Interaction coordinates can be stored in a compressed format where <code>no_interact</code> is a vector of 
   length <code>n_path</code> storing the number of interactions per path and <code>interact_coord</code> stores all 
   interaction coordinates in path order. 
</li><li style="margin-bottom: 0.4em;">This function processes the interaction coordinates of to extract relevant propagation metrics. 
</li><li style="margin-bottom: 0.4em;">Calculates absolute path lengths and first/last bounce scatterer positions and angles. 
</li><li style="margin-bottom: 0.4em;">LOS paths are assigned a virtual FBS/LBS position at the midpoint between TX and RX. 
</li><li style="margin-bottom: 0.4em;">Automatically resizes output arguments if necessary. 
</li><li style="margin-bottom: 0.4em;">Optionally reverses TX and RX to simulate the reverse link. 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
void quadriga_lib::coord2path(
                dtype Tx, dtype Ty, dtype Tz, 
                dtype Rx, dtype Ry, dtype Rz,
                const arma::u32_vec *no_interact, 
                const arma::Mat&lt;dtype&gt; *interact_coord,
                arma::Col&lt;dtype&gt; *path_length, 
                arma::Mat&lt;dtype&gt; *fbs_pos, 
                arma::Mat&lt;dtype&gt; *lbs_pos,
                arma::Mat&lt;dtype&gt; *path_angles, 
                std::vector&lt;arma::Mat&lt;dtype&gt;&gt; *path_coord, 
                bool reverse_path);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>dtype <b>Tx</b>, <b>Ty</b>, <b>Tz</b></code> (input)<br> 
   Transmitter position in Cartesian coordinates in [m] 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>Rx</b>, <b>Ry</b>, <b>Rz</b></code> (input)<br> 
   Receiver position in Cartesian coordinates in [m] 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::u32_vec <b>*no_interact</b></code> (input)<br> 
   Vector of length <code>n_path</code> indicating the number of interactions per path (0 = LOS) 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*interact_coord</b></code> (input)<br> 
   Matrix of size <code>[3, sum(no_interact)]</code> containing interaction coordinates in path order 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Col&lt;dtype&gt; <b>*path_length</b></code> (output, optional)<br> 
   Absolute path lengths from TX to RX, Length <code>[n_path]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt; <b>*fbs_pos</b></code> (output, optional)<br> 
   First-bounce scatterer positions, Size <code>[3, n_path]</code>; For LOS, set to midpoint between TX and RX 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt; <b>*lbs_pos</b></code> (output, optional)<br> 
   Last-bounce scatterer positions, Size <code>[3, n_path]</code>. For LOS, set to midpoint between TX and RX 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt; <b>*path_angles</b></code> (output, optional)<br> 
   Departure and arrival angles: columns {AOD, EOD, AOA, EOA}, size <code>[n_path, 4]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>std::vector&lt;arma::Mat&lt;dtype&gt;&gt; <b>*path_coord</b></code> (output, optional)<br> 
   Full path coordinates (including TX and RX), vector of size <code>n_path</code> with each entry of size <code>[3, n_interact+2]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>bool <b>reverse_path</b> = false</code> (optional input)<br> 
   If <code>true</code>, swaps TX and RX and reverses all interaction sequences. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Example:</i></b><br><pre>
// Suppose we have two paths: one LOS, one single-bounce.
// Path 0: LOS (no_interact[0] = 0)
// Path 1: single bounce at {5,0,2}.

arma::u32_vec no_int = {0, 1};
arma::mat interact(3, 1);
interact.col(0) = {5.0, 0.0, 2.0};

arma::vec lengths;
arma::mat fbs, lbs;
arma::mat angles;
std::vector&lt;arma::mat&gt; coords;

quadriga_lib::coord2path&lt;double&gt;(
    0.0, 0.0, 0.0,  // TX at origin
    10.0, 0.0, 0.0, // RX at x = 10 m
    &amp;no_int, &amp;interact, &amp;lengths, &amp;fbs, &amp;lbs, &amp;angles, &amp;coords);

// After the call:
// lengths: [10.0, 10.77]
// fbs:     Path 1 [5,0,0], Path 2 [5,0,2]
// lbs:     Path 1 [5,0,0], Path 2 [5,0,2]
// angles:  Path 1 [0, 0, pi, p], Path 2 [0, 22°, pi, 22°]
// coords[0]: [ [0,0,0], [10,0,0] ]
// coords[1]: [ [0,0,0], [5,0,2], [10,0,0] ]
</pre>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="generate_diffraction_paths"></a>
<b>generate_diffraction_paths</b> - Generate propagation paths for estimating the diffraction gain
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>This function generates the elliptic propagation paths and corresponding weights necessary for the 
calculation of the diffraction gain in <a href="#calc_diffraction_gain">calc_diffraction_gain</a>.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Caveat:</i></b><br><ul><li style="margin-bottom: 0.4em;">Each ellipsoid consists of <code>n_path</code> diffraction paths. The number of paths is determined by the 
   level of detail (<code>lod</code>). 
</li><li style="margin-bottom: 0.4em;">All diffraction paths of an ellipsoid originate at <code>orig</code> and arrive at <code>dest</code> 
</li><li style="margin-bottom: 0.4em;">Each diffraction path has <code>n_seg</code> segments 
</li><li style="margin-bottom: 0.4em;">Points <code>orig</code> and <code>dest</code> lay on the semi-major axis of the ellipsoid 
</li><li style="margin-bottom: 0.4em;">The generated rays sample the volume of the ellipsoid 
</li><li style="margin-bottom: 0.4em;">Weights are calculated from the Knife-edge diffraction model when parts of the ellipsoid are shadowed 
</li><li style="margin-bottom: 0.4em;">Initial weights are normalized such that <code>sum(prod(weights,3),2) = 1</code> 
</li><li style="margin-bottom: 0.4em;">Inputs <code>orig</code> and <code>dest</code> may be provided as double or single precision 
</li><li style="margin-bottom: 0.4em;">Supported datatypes <code>dtype</code> are <code>float</code> or <code>double</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
void generate_diffraction_paths(
                const arma::Mat&lt;dtype&gt; *orig, 
                const arma::Mat&lt;dtype&gt; *dest,
                dtype center_frequency, 
                int lod,
                arma::Cube&lt;dtype&gt; *ray_x, 
                arma::Cube&lt;dtype&gt; *ray_y, 
                arma::Cube&lt;dtype&gt; *ray_z,
                arma::Cube&lt;dtype&gt; *weight);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*orig</b></code> (input)<br> 
   Pointer to Armadillo matrix containing the origin points of the propagation ellipsoid (e.g. 
   transmitter positions). Size: <code>[ n_pos, 3 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*dest</b></code> (input)<br> 
   Pointer to Armadillo matrix containing the destination point of the propagation ellipsoid (e.g. 
   receiver positions). Size: <code>[ n_pos, 3 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>center_frequency</b></code> (input)<br> 
   The center frequency in [Hz], scalar, default = 299792458 Hz 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>int <b>lod</b></code> (input)<br> 
   Level of detail, scalar value 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>lod = 1</code></td>
  <td>results in <code>n_path = 7</code> and <code>n_seg = 3</code></td>
</tr>
<tr>
  <td><code>lod = 2</code></td>
  <td>results in <code>n_path = 19</code> and <code>n_seg = 3</code></td>
</tr>
<tr>
  <td><code>lod = 3</code></td>
  <td>results in <code>n_path = 37</code> and <code>n_seg = 4</code></td>
</tr>
<tr>
  <td><code>lod = 4</code></td>
  <td>results in <code>n_path = 61</code> and <code>n_seg = 5</code></td>
</tr>
<tr>
  <td><code>lod = 5</code></td>
  <td>results in <code>n_path = 1</code> and <code>n_seg = 2</code> (for debugging)</td>
</tr>
<tr>
  <td><code>lod = 6</code></td>
  <td>results in <code>n_path = 2</code> and <code>n_seg = 2</code> (for debugging)</td>
</tr>
</table><br>
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Cube&lt;dtype&gt; <b>*ray_x</b></code> (output)<br> 
   Pointer to an Armadillo cube for the x-coordinates of the generated rays; Size: <code>[ n_pos, n_path, n_seg-1 ]</code> 
   Size will be adjusted if not set correctly. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Cube&lt;dtype&gt; <b>*ray_y</b></code> (output)<br> 
   Pointer to an Armadillo cube for the y-coordinates of the generated rays; Size: <code>[ n_pos, n_path, n_seg-1 ]</code> 
   Size will be adjusted if not set correctly. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Cube&lt;dtype&gt; <b>*ray_z</b></code> (output)<br> 
   Pointer to an Armadillo cube for the z-coordinates of the generated rays; Size: <code>[ n_pos, n_path, n_seg-1 ]</code> 
   Size will be adjusted if not set correctly. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Cube&lt;dtype&gt; <b>*weight</b></code> (output)<br> 
   Pointer to an Armadillo cube for the  weights; Size: <code>[ n_pos, n_path, n_seg ]</code> 
   Size will be adjusted if not set correctly. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>See also:</i></b><br><ul><li style="margin-bottom: 0.4em;"><a href="#calc_diffraction_gain">calc_diffraction_gain</a> 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="icosphere"></a>
<b>icosphere</b> - Construct a geodesic polyhedron (icosphere) from triangles
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Generates a convex polyhedral surface (icosphere) made entirely of triangles, based on recursive subdivision of an icosahedron. 
</li><li style="margin-bottom: 0.4em;">Useful for sampling directions uniformly on a sphere, for applications like ray tracing, antenna pattern evaluation, or spatial grids. 
</li><li style="margin-bottom: 0.4em;">Each triangular face points outward from the center and has an associated normal. 
</li><li style="margin-bottom: 0.4em;">Optionally returns vertex directions and vector lengths in either Cartesian or spherical coordinates. 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
arma::uword quadriga_lib::icosphere(
                arma::uword n_div,
                dtype radius,
                arma::Mat&lt;dtype&gt; *center,
                arma::Col&lt;dtype&gt; *length = nullptr,
                arma::Mat&lt;dtype&gt; *vert = nullptr,
                arma::Mat&lt;dtype&gt; *direction = nullptr,
                bool direction_xyz = false);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>arma::uword <b>n_div</b></code> (input)<br> 
   Number of subdivisions per triangle edge. The total number of faces will be <code>n_faces = 20 × n_div²</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>radius</b></code> (input)<br> 
   Radius of the icosphere in meters. All triangle vertices lie on this sphere. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt; <b>*center</b></code> (output)<br> 
   Unit vectors pointing from the origin to the center of each triangle face. Usually a bit shorter than <code>radius</code>, Size <code>[n_faces, 3]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Col&lt;dtype&gt; <b>*length</b> = nullptr</code> (optional output)<br> 
   Vector magnitudes of each <code>center</code> vector (usually slightly less than <code>radius</code>). Vector size <code>[n_faces]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt; <b>*vert</b> = nullptr</code> (optional output)<br> 
   Vertex vectors from each triangle’s center to its three vertices, flattened as <code>[x1, y1, z1, x2, y2, z2, x3, y3, z3]</code>. Size <code>[n_faces, 9]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt; <b>*direction</b> = nullptr</code> (optional output)<br> 
   Direction vectors of the three triangle edges. Format depends on <code>direction_xyz</code>: If <code>false</code>  
   (spherical): <code>[v1az, v1el, v2az, v2el, v3az, v3el]</code>, If <code>true</code> (Cartesian): <code>[v1x, v1y, v1z, v2x, v2y, v2z, v3x, v3y, v3z]</code>, 
   Size <code>[n_faces, 6]</code> or <code>[n_faces, 9]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>bool <b>direction_xyz</b> = false</code> (optional input)<br> 
   If <code>true</code>, output directions in Cartesian coordinates. If <code>false</code>, output in spherical azimuth/elevation. Default: <code>false</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Returns:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>arma::uword</code><br> 
   The number of triangular faces generated: <code>n_faces = 20 × n_div²</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Technical Notes:</i></b><br><ul><li style="margin-bottom: 0.4em;">The generated mesh is well-suited for uniform angular sampling on a sphere. 
</li><li style="margin-bottom: 0.4em;">Triangle vertices are calculated relative to the center to ensure they lie on the desired sphere. 
</li><li style="margin-bottom: 0.4em;">The radius parameter scales the final structure without changing angular spacing. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Example:</i></b><br><pre>
arma::fmat center, vert, direction;
arma::fvec length;

// 4 subdivisions → 320 faces, map to unit sphere, output Cartesian directions
auto n = quadriga_lib::icosphere&lt;float&gt;(4, 1.0, &amp;center, &amp;length, &amp;vert, &amp;direction, true);
</pre>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="mitsuba_xml_file_write"></a>
<b>mitsuba_xml_file_write</b> - Write geometry and material data to a Mitsuba 3 XML scene file.
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>This routine converts a triangular surface mesh stored in <i>quadriga-lib</i> data structures into the 
XML format understood by <b>Mitsuba 3</b> <a href="https://www.mitsuba-renderer.org">www.mitsuba-renderer.org</a>. 
The generated file can be loaded directly by <b>NVIDIA Sionna RT</b> for differentiable radio-propagation  
simulations.<br><br> 
 
<ul><li style="margin-bottom: 0.4em;">Converts a 3D geometry mesh into Mitsuba 3 XML format for use with rendering tools. 
</li><li style="margin-bottom: 0.4em;">Enables exporting models from <code>quadriga-lib</code> to be used with <b>Mitsuba 3</b> or <b>Sionna RT</b>: 
</li><li style="margin-bottom: 0.4em;"><a href="https://www.mitsuba-renderer.org">Mitsuba 3</a>: Research-oriented retargetable rendering system. 
</li><li style="margin-bottom: 0.4em;"><a href="https://developer.nvidia.com/sionna">NVIDIA Sionna</a>: Hardware-accelerated differentiable ray tracer for wireless propagation, built on Mitsuba 3. 
</li><li style="margin-bottom: 0.4em;">Supports grouping faces into named objects and assigning materials by name. 
</li><li style="margin-bottom: 0.4em;">Optionally maps materials to ITU default presets used by Sionna RT. 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
void quadriga_lib::mitsuba_xml_file_write(
                const std::string &amp;fn,
                const arma::Mat&lt;dtype&gt; &amp;vert_list,
                const arma::umat &amp;face_ind,
                const arma::uvec &amp;obj_ind,
                const arma::uvec &amp;mtl_ind,
                const std::vector&lt;std::string&gt; &amp;obj_names,
                const std::vector&lt;std::string&gt; &amp;mtl_names,
                const arma::Mat&lt;dtype&gt; &amp;bsdf = {},
                bool map_to_itu_materials = false);

</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>const std::string <b>fn</b></code> (input)<br> 
   Output file name (including path and <code>.xml</code> extension). 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>vert_list</b></code> (input)<br> 
   Vertex list, size <code>[n_vert, 3]</code>, each row is a vertex (x, y, z) in Cartesian coordinates [m]. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::umat <b>face_ind</b></code> (input)<br> 
   Face indices (0-based), size <code>[n_mesh, 3]</code>, each row defines a triangle via vertex indices. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::uvec <b>obj_ind</b></code> (input)<br> 
   Object indices (1-based), size <code>[n_mesh]</code>. Assigns each triangle to an object. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::uvec <b>mtl_ind</b></code> (input)<br> 
   Material indices (1-based), size <code>[n_mesh]</code>. Assigns each triangle to a material. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const std::vector&lt;std::string&gt; <b>obj_names</b></code> (input)<br> 
   Names of objects. Length must be equal to <code>max(obj_ind)</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const std::vector&lt;std::string&gt; <b>mtl_names</b></code> (input)<br> 
   Names of materials. Length must be equal to <code>max(mtl_ind)</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>bsdf</b> = {}</code> (optional input)<br> 
   Material reflectivity data (BSDF parameters), size <code>[mtl_names.size(), 17]</code>. If omitted, the <code>null</code> BSDF is used. 
   Note that Sionna RT ignores all BSDF parameters. They are only used by the Mitsuma rendering system. 
   See <a href="#obj_file_read">obj_file_read</a> for a definition of the data fields. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>bool <b>map_to_itu_materials</b> = false</code> (optional input)<br> 
   If true, maps material names to ITU-defined presets used by Sionna RT. Default: <code>false</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>See also:</i></b><br><ul><li style="margin-bottom: 0.4em;"><a href="#obj_file_read">obj_file_read</a> 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="obj_file_read"></a>
<b>obj_file_read</b> - Read Wavefront `.obj` file and extract geometry and material information
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Parses a Wavefront <code>.obj</code> file containing triangularized 3D geometry. 
</li><li style="margin-bottom: 0.4em;">Extracts triangle face data, material properties, vertex indices, and optional metadata such as object/material names. 
</li><li style="margin-bottom: 0.4em;">Multiple triangles belonging to the same object are grouped together by <code>obj_ind</code>. 
</li><li style="margin-bottom: 0.4em;">Supports default and custom ITU-compliant materials encoded via the <code>usemtl</code> tag. 
</li><li style="margin-bottom: 0.4em;">Automatically resizes output matrices/vectors as needed to match the file content. 
</li><li style="margin-bottom: 0.4em;">Returns the number of triangular mesh elements found in the file. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
arma::uword quadriga_lib::obj_file_read(
                std::string fn,
                arma::Mat&lt;dtype&gt; *mesh = nullptr,
                arma::Mat&lt;dtype&gt; *mtl_prop = nullptr,
                arma::Mat&lt;dtype&gt; *vert_list = nullptr,
                arma::umat *face_ind = nullptr,
                arma::uvec *obj_ind = nullptr,
                arma::uvec *mtl_ind = nullptr,
                std::vector&lt;std::string&gt; *obj_names = nullptr,
                std::vector&lt;std::string&gt; *mtl_names = nullptr,
                arma::Mat&lt;dtype&gt; *bsdf = nullptr);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>std::string <b>fn</b></code> (input)<br> 
   Path to the <code>.obj</code> file to be read. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt; <b>*mesh</b> = nullptr</code> (optional output)<br> 
   Flattened triangle mesh data. Each row holds <code>[X1, Y1, Z1, X2, Y2, Z2, X3, Y3, Z3]</code>. Size: <code>[n_mesh, 9]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt; <b>*mtl_prop</b> = nullptr</code> (optional output)<br> 
   Material properties for each triangle. Size: <code>[n_mesh, 5]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt; <b>*vert_list</b> = nullptr</code> (optional output)<br> 
   List of all vertex positions found in the <code>.obj</code> file. Size: <code>[n_vert, 3]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::umat <b>*face_ind</b> = nullptr</code> (optional output)<br> 
   Indices into <code>vert_list</code> for each triangle (0-based). Size: <code>[n_mesh, 3]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::uvec <b>*obj_ind</b> = nullptr</code> (optional output)<br> 
   Object index (1-based) for each triangle. Size: <code>[n_mesh]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::uvec <b>*mtl_ind</b> = nullptr</code> (optional output)<br> 
   Material index (1-based) for each triangle. Size: <code>[n_mesh]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>std::vector&lt;std::string&gt; <b>*obj_names</b> = nullptr</code> (optional output)<br> 
   Names of objects found in the file. Length: <code>max(obj_ind)</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>std::vector&lt;std::string&gt; <b>*mtl_names</b> = nullptr</code> (optional output)<br> 
   Names of materials found in the file. Length: <code>max(mtl_ind)</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt; <b>*bsdf</b> = nullptr</code> (optional output)<br> 
   Principled BSDF (Bidirectional Scattering Distribution Function) values extracted from the 
   .MTL file. Size <code>[mtl_names.size(), 17]</code>. Values are: 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td>0</td>
  <td>Base Color Red</td>
  <td>Range 0-1</td>
  <td>Default = 0.8</td>
</tr>
<tr>
  <td>1</td>
  <td>Base Color Green</td>
  <td>Range 0-1</td>
  <td>Default = 0.8</td>
</tr>
<tr>
  <td>2</td>
  <td>Base Color Blue</td>
  <td>Range 0-1</td>
  <td>Default = 0.8</td>
</tr>
<tr>
  <td>3</td>
  <td>Transparency (alpha)</td>
  <td>Range 0-1</td>
  <td>Default = 1.0 (fully opaque)</td>
</tr>
<tr>
  <td>4</td>
  <td>Roughness</td>
  <td>Range 0-1</td>
  <td>Default = 0.5</td>
</tr>
<tr>
  <td>5</td>
  <td>Metallic</td>
  <td>Range 0-1</td>
  <td>Default = 0.0</td>
</tr>
<tr>
  <td>6</td>
  <td>Index of refraction (IOR)</td>
  <td>Range 0-4</td>
  <td>Default = 1.45</td>
</tr>
<tr>
  <td>7</td>
  <td>Specular Adjustment to the IOR</td>
  <td>Range 0-1</td>
  <td>Default = 0.5 (no adjustment)</td>
</tr>
<tr>
  <td>8</td>
  <td>Emission Color Red</td>
  <td>Range 0-1</td>
  <td>Default = 0.0</td>
</tr>
<tr>
  <td>9</td>
  <td>Emission Color Green</td>
  <td>Range 0-1</td>
  <td>Default = 0.0</td>
</tr>
<tr>
  <td>10</td>
  <td>Emission Color Blue</td>
  <td>Range 0-1</td>
  <td>Default = 0.0</td>
</tr>
<tr>
  <td>11</td>
  <td>Sheen</td>
  <td>Range 0-1</td>
  <td>Default = 0.0</td>
</tr>
<tr>
  <td>12</td>
  <td>Clearcoat</td>
  <td>Range 0-1</td>
  <td>Default = 0.0</td>
</tr>
<tr>
  <td>13</td>
  <td>Clearcoat roughness</td>
  <td>Range 0-1</td>
  <td>Default = 0.0</td>
</tr>
<tr>
  <td>14</td>
  <td>Anisotropic</td>
  <td>Range 0-1</td>
  <td>Default = 0.0</td>
</tr>
<tr>
  <td>15</td>
  <td>Anisotropic rotation</td>
  <td>Range 0-1</td>
  <td>Default = 0.0</td>
</tr>
<tr>
  <td>16</td>
  <td>Transmission</td>
  <td>Range 0-1</td>
  <td>Default = 0.0</td>
</tr>
</table><br>
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Returns:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>arma::uword</code><br> 
   Number of mesh triangles found in the file (<code>n_mesh</code>). 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Technical Notes:</i></b><br><ul><li style="margin-bottom: 0.4em;">Unknown or missing materials default to <code>"vacuum"</code> (ε_r = 1, σ = 0). 
</li><li style="margin-bottom: 0.4em;">Materials are applied per triangle via the <code>usemtl</code> tag in the <code>.obj</code> file. 
</li><li style="margin-bottom: 0.4em;">Input geometry must be fully triangulated—quads and n-gons are not supported. 
</li><li style="margin-bottom: 0.4em;">File parsing is case-sensitive for material names. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Material Tag Format:</i></b><br><ul><li style="margin-bottom: 0.4em;">Default materials (ITU-R P.2040-3 Table 3): <code>"usemtl itu_concrete"</code>, <code>"itu_brick"</code>, <code>"itu_wood"</code>, <code>"itu_water"</code>, etc. 
</li><li style="margin-bottom: 0.4em;">Frequency range: 1–40 GHz (limited to 1–10 GHz for ground materials) 
</li><li style="margin-bottom: 0.4em;">Custom materials syntax: <code>"usemtl Name::A:B:C:D:att"</code> with <code>A, B</code>: Real permittivity ε_r = <code>A * fGHz^B</code>, 
   <code>C, D</code>: Conductivity σ = <code>C * fGHz^D</code>, <code>att</code>: Penetration loss in dB (fixed, per interaction) 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Material properties:</i></b><br>Each material is defined by its electrical properties. Radio waves that interact with a building will 
produce losses that depend on the electrical properties of the building materials, the material 
structure and the frequency of the radio wave. The fundamental quantities of interest are the electrical 
permittivity (ϵ) and the conductivity (σ). A simple regression model for the frequency dependence is 
obtained by fitting measured values of the permittivity and the conductivity at a number of frequencies. 
The five parameters returned in <code>mtl_prop</code> then are:<br><br> 
 
<ul><li style="margin-bottom: 0.4em;">Real part of relative permittivity at f = 1 GHz (a) 
</li><li style="margin-bottom: 0.4em;">Frequency dependence of rel. permittivity (b) such that ϵ = a · f^b 
</li><li style="margin-bottom: 0.4em;">Conductivity at f = 1 GHz (c) 
</li><li style="margin-bottom: 0.4em;">Frequency dependence of conductivity (d) such that σ = c· f^d 
</li><li style="margin-bottom: 0.4em;">Fixed attenuation in dB applied to each transition 
</li></ul>
 
A more detailed explanation together with a derivation can be found in ITU-R P.2040. The following 
list of material is currently supported and the material can be selected by using the <code>usemtl</code> tag 
in the OBJ file. When using Blender, the simply assign a material with that name to an object or face. 
The following materials are defined by default:<br><br> 
 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <th>Name</th>
  <th>a</th>
  <th>b</th>
  <th>c</th>
  <th>d</th>
  <th>Att</th>
  <th>max fGHz</th>
  <th></th>
</tr>
<tr>
  <td>vacuum / air</td>
  <td>1.0</td>
  <td>0.0</td>
  <td>0.0</td>
  <td>0.0</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>textiles</td>
  <td>1.5</td>
  <td>0.0</td>
  <td>5e-5</td>
  <td>0.62</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>plastic</td>
  <td>2.44</td>
  <td>0.0</td>
  <td>2.33e-5</td>
  <td>1.0</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>ceramic</td>
  <td>6.5</td>
  <td>0.0</td>
  <td>0.0023</td>
  <td>1.32</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>sea_water</td>
  <td>80.0</td>
  <td>-0.25</td>
  <td>4.0</td>
  <td>0.58</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>sea_ice</td>
  <td>3.2</td>
  <td>-0.022</td>
  <td>1.1</td>
  <td>1.5</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>water</td>
  <td>80.0</td>
  <td>-0.18</td>
  <td>0.6</td>
  <td>1.52</td>
  <td>0.0</td>
  <td>20</td>
  <td></td>
</tr>
<tr>
  <td>water_ice</td>
  <td>3.17</td>
  <td>-0.005</td>
  <td>5.6e-5</td>
  <td>1.7</td>
  <td>0.0</td>
  <td>20</td>
  <td></td>
</tr>
<tr>
  <td>itu_concrete</td>
  <td>5.24</td>
  <td>0.0</td>
  <td>0.0462</td>
  <td>0.7822</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>itu_brick</td>
  <td>3.91</td>
  <td>0.0</td>
  <td>0.0238</td>
  <td>0.16</td>
  <td>0.0</td>
  <td>40</td>
  <td></td>
</tr>
<tr>
  <td>itu_plasterboard</td>
  <td>2.73</td>
  <td>0.0</td>
  <td>0.0085</td>
  <td>0.9395</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>itu_wood</td>
  <td>1.99</td>
  <td>0.0</td>
  <td>0.0047</td>
  <td>1.0718</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>itu_glass</td>
  <td>6.31</td>
  <td>0.0</td>
  <td>0.0036</td>
  <td>1.3394</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>itu_ceiling_board</td>
  <td>1.48</td>
  <td>0.0</td>
  <td>0.0011</td>
  <td>1.075</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>itu_chipboard</td>
  <td>2.58</td>
  <td>0.0</td>
  <td>0.0217</td>
  <td>0.78</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>itu_plywood</td>
  <td>2.71</td>
  <td>0.0</td>
  <td>0.33</td>
  <td>0.0</td>
  <td>0.0</td>
  <td>40</td>
  <td></td>
</tr>
<tr>
  <td>itu_marble</td>
  <td>7.074</td>
  <td>0.0</td>
  <td>0.0055</td>
  <td>0.9262</td>
  <td>0.0</td>
  <td>60</td>
  <td></td>
</tr>
<tr>
  <td>itu_floorboard</td>
  <td>3.66</td>
  <td>0.0</td>
  <td>0.0044</td>
  <td>1.3515</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>itu_metal</td>
  <td>1.0</td>
  <td>0.0</td>
  <td>1.0e7</td>
  <td>0.0</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>itu_very_dry_ground</td>
  <td>3.0</td>
  <td>0.0</td>
  <td>0.00015</td>
  <td>2.52</td>
  <td>0.0</td>
  <td>10</td>
  <td></td>
</tr>
<tr>
  <td>itu_medium_dry_ground</td>
  <td>15.0</td>
  <td>-0.1</td>
  <td>0.035</td>
  <td>1.63</td>
  <td>0.0</td>
  <td>10</td>
  <td></td>
</tr>
<tr>
  <td>itu_wet_ground</td>
  <td>30.0</td>
  <td>-0.4</td>
  <td>0.15</td>
  <td>1.3</td>
  <td>0.0</td>
  <td>10</td>
  <td></td>
</tr>
<tr>
  <td>itu_vegetation</td>
  <td>1.0</td>
  <td>0.0</td>
  <td>1.0e-4</td>
  <td>1.1</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>irr_glass</td>
  <td>6.27</td>
  <td>0.0</td>
  <td>0.0043</td>
  <td>1.1925</td>
  <td>23.0</td>
  <td>100</td>
  <td></td>
</tr>
</table><br>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Example:</i></b><br><pre>
arma::mat mesh, mtl_prop, vert_list;
arma::umat face_ind;
arma::uvec obj_ind, mtl_ind;
std::vector&lt;std::string&gt; obj_names, mtl_names;

quadriga_lib::obj_file_read&lt;double&gt;("cube.obj", &amp;mesh, &amp;mtl_prop, &amp;vert_list, &amp;face_ind, &amp;obj_ind, &amp;mtl_ind, &amp;obj_names, &amp;mtl_names);
</pre>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="obj_overlap_test"></a>
<b>obj_overlap_test</b> - Detect overlapping 3D objects in a triangular mesh
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Tests whether any objects in a triangular mesh overlap by checking for shared volume or intersection. 
</li><li style="margin-bottom: 0.4em;">Touching faces or edges are not considered overlapping 
</li><li style="margin-bottom: 0.4em;">Returns the indices (1-based) of all objects that intersect with at least one other object. 
</li><li style="margin-bottom: 0.4em;">Can optionally output a list of overlap reasons for diagnostic purposes. 
</li><li style="margin-bottom: 0.4em;">Uses a configurable geometric tolerance to account for numerical precision. 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
arma::uvec quadriga_lib::obj_overlap_test(
                const arma::Mat&lt;dtype&gt; *mesh,
                const arma::uvec *obj_ind,
                std::vector[std::string](std::string) *reason = nullptr,
                dtype tolerance = 0.0005);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*mesh</b></code> (input)<br> 
   Triangular mesh geometry. Each row contains 3 vertices flattened as <code>[X1, Y1, Z1, X2, Y2, Z2, X3, Y3, Z3]</code>. Size: <code>[n_mesh, 9]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::uvec <b>*obj_ind</b></code> (input)<br> 
   Object indices (1-based) that map multiple triangles in <code>mesh</code> to objects; Size: <code>[n_mesh]</code>; 
   This is an output generated by <a href="#obj_file_read">obj_file_read</a>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>std::vector&lt;std::string&gt; <b>*reason</b> = nullptr</code> (optional output)<br> 
   Human-readable list of overlap reasons corresponding to each overlapping object. Length: <code>[n_overlap]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>tolerance</b> = 0.0005</code> (optional input)<br> 
   Geometric tolerance (in meters) used to determine intersections. Default: <code>0.0005</code> (0.5 mm). 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Returns:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>arma::uvec</code>: Vector of unique object indices (1-based) that were found to overlap, size <code>[n_overlap]</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Technical Notes:</i></b><br><ul><li style="margin-bottom: 0.4em;">Overlap detection includes checks for: Intersecting triangle faces (shared volume), Vertices or edges penetrating another object’s bounding volume. 
</li><li style="margin-bottom: 0.4em;">The <code>tolerance</code> accounts for modeling inaccuracies and numerical instability—small overlaps below this threshold are ignored. 
</li><li style="margin-bottom: 0.4em;">This function does <b>not</b> modify the mesh or attempt to repair overlapping geometry — it only reports it. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>See also:</i></b><br><ul><li style="margin-bottom: 0.4em;"><a href="#obj_file_read">obj_file_read</a> 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="path_to_tube"></a>
<b>path_to_tube</b> - Convert a 3D path into a tube surface for visualization
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Converts a sequence of 3D points (path) into a tubular surface using a ring of vertices around each path segment. 
</li><li style="margin-bottom: 0.4em;">Produces a quad-based mesh suitable for rendering in 3D tools such as Blender or MeshLab. 
</li><li style="margin-bottom: 0.4em;">Uses circular cross-sections with configurable radius and edge count. 
</li><li style="margin-bottom: 0.4em;">Internal calculations are performed in double precision to ensure numerical stability along complex paths. 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
void quadriga_lib::path_to_tube(
                const arma::Mat&lt;dtype&gt; *path_coord,
                arma::Mat&lt;dtype&gt; *vert,
                arma::umat *faces,
                dtype radius = 1.0,
                arma::uword n_edges = 5);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*path_coord</b></code> (input)<br> 
   Ordered list of 3D coordinates along the path, matrix of size <code>[3, n_coord]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt; <b>*vert</b></code> (output)<br> 
   Generated tube vertex positions. Size: <code>[3, n_coord × n_edges]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::umat <b>*faces</b></code> (output)<br> 
   Quad face indices into <code>vert</code>. Each row contains 4 indices forming a quad. Size: <code>[4, (n_coord - 1) × n_edges]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>radius</b> = 1.0</code> (optional input)<br> 
   Radius of the tube cross-section (in meters). Default: <code>1.0</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::uword <b>n_edges</b> = 5</code> (optional input)<br> 
   Number of vertices used to approximate each circular cross-section. Must be <code>≥ 3</code>. Default: <code>5</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Technical Notes:</i></b><br><ul><li style="margin-bottom: 0.4em;">The generated tube is centered around the path with perpendicular circular cross-sections. 
</li><li style="margin-bottom: 0.4em;">Orientation between path segments is handled with continuous frame alignment to reduce twisting. 
</li><li style="margin-bottom: 0.4em;">Quad faces are generated by connecting adjacent rings along the path. 
</li><li style="margin-bottom: 0.4em;">Output <code>faces</code> can be directly exported to formats like <code>.obj</code> or <code>.ply</code>. 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="point_cloud_aabb"></a>
<b>point_cloud_aabb</b> - Compute the Axis-Aligned Bounding Boxes (AABB) of a 3D point cloud
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Calculates the axis-aligned bounding box (AABB) for either a single point cloud or a set of sub-clouds. 
</li><li style="margin-bottom: 0.4em;">Each sub-cloud is defined by its starting row index in the input matrix. 
</li><li style="margin-bottom: 0.4em;">The result is a matrix where each row contains the minimum and maximum extents of a sub-cloud in the x, y, and z dimensions. 
</li><li style="margin-bottom: 0.4em;">For SIMD-friendly memory alignment, the result is zero-padded to the nearest multiple of <code>vec_size</code>. 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
arma::Mat&lt;dtype&gt; quadriga_lib::point_cloud_aabb(
                const arma::Mat&lt;dtype&gt; *points,
                const arma::u32_vec *sub_cloud_index = nullptr,
                arma::uword vec_size = 1);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*points</b></code> (input)<br> 
   Matrix of 3D point coordinates. Size: <code>[n_points, 3]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::u32_vec <b>*sub_cloud_index</b> = nullptr</code> (optional input)<br> 
   Vector of row indices indicating the start of each sub-cloud. Length: <code>[n_sub]</code>. 
   If <code>nullptr</code>, the entire input is treated as a single cloud. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::uword <b>vec_size</b> = 1</code> (optional input)<br> 
   Vector size for SIMD alignment (e.g., 4, 8, or 16). The number of output rows is padded to a multiple of <code>vec_size</code>. 
   Default: <code>1</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Returns:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt;</code><br> 
   Matrix of bounding boxes for each sub-cloud. Size: <code>[n_out, 6]</code>, where <code>n_out</code> is the padded number of sub-clouds. 
   Each row has the format: <code>[x_min, x_max, y_min, y_max, z_min, z_max]</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Technical Notes:</i></b><br><ul><li style="margin-bottom: 0.4em;">If <code>sub_cloud_index</code> is provided, the last index is assumed to span to the end of the <code>points</code> matrix. 
</li><li style="margin-bottom: 0.4em;">Padding rows (if any) are filled with zeros and should be ignored if <code>n_sub</code> is known externally. 
</li><li style="margin-bottom: 0.4em;">Suitable for preprocessing in geometry analysis, rendering pipelines, and spatial acceleration structures (e.g., BVH or octrees). 
</li><li style="margin-bottom: 0.4em;">Sub-clouds can be computed using <a href="#point_cloud_segmentation">point_cloud_segmentation</a> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>See also:</i></b><br><ul><li style="margin-bottom: 0.4em;"><a href="#point_cloud_segmentation">point_cloud_segmentation</a> 
</li><li style="margin-bottom: 0.4em;"><a href="#point_cloud_split">point_cloud_split</a> 
</li><li style="margin-bottom: 0.4em;"><a href="#ray_point_intersect">ray_point_intersect</a> 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="point_cloud_segmentation"></a>
<b>point_cloud_segmentation</b> - Reorganize a point cloud into spatial sub-clouds for efficient processing
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Recursively partitions a 3D point cloud into smaller sub-clouds, each below a given size threshold. 
</li><li style="margin-bottom: 0.4em;">Sub-clouds are aligned to a specified SIMD vector size (e.g., for AVX or CUDA), with padding if necessary. 
</li><li style="margin-bottom: 0.4em;">Outputs (<code>pointsR</code>) a reorganized version of the input points that groups points by sub-cloud. 
</li><li style="margin-bottom: 0.4em;">Also produces forward and reverse index maps to track the reordering of points. 
</li><li style="margin-bottom: 0.4em;">Useful for optimizing spatial processing tasks such as bounding volume hierarchies or GPU batch execution. 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
arma::uword quadriga_lib::point_cloud_segmentation(
                const arma::Mat&lt;dtype&gt; *points,
                arma::Mat&lt;dtype&gt; *pointsR,
                arma::u32_vec *sub_cloud_index,
                arma::uword target_size = 1024,
                arma::uword vec_size = 1,
                arma::u32_vec *forward_index = nullptr,
                arma::u32_vec *reverse_index = nullptr);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*points</b></code> (input)<br> 
   Original 3D point cloud to be segmented. Size: <code>[n_points, 3]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt; <b>*pointsR</b></code> (output)<br> 
   Reorganized point cloud with points grouped by sub-cloud. Size: <code>[n_pointsR, 3]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::u32_vec <b>*sub_cloud_index</b></code> (output)<br> 
   Vector of starting indices (0-based) for each sub-cloud within <code>pointsR</code>. Length: <code>[n_sub]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::uword <b>target_size</b> = 1024</code> (optional input)<br> 
   Maximum number of elements allowed per sub-cloud (before padding). Default: <code>1024</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::uword <b>vec_size</b> = 1</code> (optional input)<br> 
   Vector alignment size for SIMD or CUDA. The number of points in each sub-cloud is padded to a multiple of this value. Default: <code>1</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::u32_vec <b>*forward_index</b> = nullptr</code> (optional output)<br> 
   Index map from original <code>points</code> to reorganized <code>pointsR</code> (1-based). Size: <code>[n_pointsR]</code>. Padding indices are <code>0</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::u32_vec <b>*reverse_index</b> = nullptr</code> (optional output)<br> 
   Index map from <code>pointsR</code> back to original <code>points</code> (0-based). Size: <code>[n_points]</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Returns:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>arma::uword</code><br> 
   Number of generated sub-clouds, <code>n_sub</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Technical Notes:</i></b><br><ul><li style="margin-bottom: 0.4em;">Sub-clouds are formed using recursive spatial splitting (e.g., median-split along bounding box axes). 
</li><li style="margin-bottom: 0.4em;">Padding points are placed at the AABB center of the corresponding sub-cloud and can be ignored in processing. 
</li><li style="margin-bottom: 0.4em;">This function is typically used as a preprocessing step for GPU acceleration or bounding volume hierarchy (BVH) generation. 
</li><li style="margin-bottom: 0.4em;">If <code>vec_size = 1</code>, no padding is applied and all output maps contain valid indices only. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>See also:</i></b><br><ul><li style="margin-bottom: 0.4em;"><a href="#point_cloud_aabb">point_cloud_aabb</a> 
</li><li style="margin-bottom: 0.4em;"><a href="#point_cloud_split">point_cloud_split</a> 
</li><li style="margin-bottom: 0.4em;"><a href="#ray_point_intersect">ray_point_intersect</a> 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="point_cloud_split"></a>
<b>point_cloud_split</b> - Split a point cloud into two sub-clouds along a spatial axis
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Divides a 3D point cloud into two sub-clouds along the specified axis. 
</li><li style="margin-bottom: 0.4em;">Attempts to split the data at the median value to balance the number of points in each half. 
</li><li style="margin-bottom: 0.4em;">Returns the axis used for the split, or a negative value if a valid split was not possible (e.g., all points fall on one side). 
</li><li style="margin-bottom: 0.4em;">Output point clouds are written into <code>pointsA</code> and <code>pointsB</code>, and their size is adjusted accordingly. 
</li><li style="margin-bottom: 0.4em;">An optional indicator vector identifies the target sub-cloud (A or B) for each input point. 
</li><li style="margin-bottom: 0.4em;">Used in recursive spatial partitioning such as building BVH structures. 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
int quadriga_lib::point_cloud_split(
                const arma::Mat&lt;dtype&gt; *points,
                arma::Mat&lt;dtype&gt; *pointsA,
                arma::Mat&lt;dtype&gt; *pointsB,
                int axis = 0,
                arma::Col&lt;int&gt; *split_ind = nullptr);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*points</b></code> (input)<br> 
   Input point cloud. Size: <code>[n_points, 3]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt; <b>*pointsA</b></code> (output)<br> 
   First sub-cloud after split. Size: <code>[n_pointsA, 3]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt; <b>*pointsB</b></code> (output)<br> 
   Second sub-cloud after split. Size: <code>[n_pointsB, 3]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>int <b>axis</b> = 0</code> (optional input)<br> 
   Axis to split along: <code>0</code> = longest extent (default), <code>1</code> = x-axis, <code>2</code> = y-axis, <code>3</code> = z-axis. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Col&lt;int&gt; <b>*split_ind</b> = nullptr</code> (optional output)<br> 
   Vector of length <code>[n_points]</code>, where each element is: <code>1</code> if the point goes to <code>pointsA</code>, <code>2</code> if it goes to <code>pointsB</code>, <code>0</code> if error. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Returns:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>int</code> <br> 
    Axis used for splitting: <code>1</code> = x, <code>2</code> = y, <code>3</code> = z,  or <code>-1</code>, <code>-2</code>, <code>-3</code> if the split failed (no points assigned to one of the outputs). 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Notes:</i></b><br><ul><li style="margin-bottom: 0.4em;">The function does not modify <code>pointsA</code> or <code>pointsB</code> if the split fails. 
</li><li style="margin-bottom: 0.4em;">The selected axis is based on the bounding box if <code>axis == 0</code> 
</li><li style="margin-bottom: 0.4em;">This function is a building block for spatial acceleration structures (e.g., BVH, KD-trees), see <a href="#point_cloud_segmentation">point_cloud_segmentation</a> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>See also:</i></b><br><ul><li style="margin-bottom: 0.4em;"><a href="#point_cloud_segmentation">point_cloud_aabb</a> 
</li><li style="margin-bottom: 0.4em;"><a href="#point_cloud_segmentation">point_cloud_segmentation</a> 
</li><li style="margin-bottom: 0.4em;"><a href="#ray_point_intersect">ray_point_intersect</a> 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="point_inside_mesh"></a>
<b>point_inside_mesh</b> - Test whether 3D points are inside a triangle mesh using raycasting
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Uses raycasting to determine whether each 3D point lies inside a triangle mesh. 
</li><li style="margin-bottom: 0.4em;">Requires that the mesh is watertight and all normals are pointing outwards. 
</li><li style="margin-bottom: 0.4em;">For each point, multiple rays are cast in various directions. 
</li><li style="margin-bottom: 0.4em;">If any ray intersects a mesh element with a negative incidence angle, the point is classified as <b>inside</b>. 
</li><li style="margin-bottom: 0.4em;">Output can be binary (0 = outside, 1 = inside) or labeled with object indices. 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
arma::u32_vec quadriga_lib::point_inside_mesh(
                const arma::Mat&lt;dtype&gt; *points,
                const arma::Mat&lt;dtype&gt; *mesh,
                const arma::u32_vec *obj_ind = nullptr,
                dtype distance = 0.0);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*points</b></code> (input)<br> 
   3D point coordinates to test, size <code>[n_points, 3]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*mesh</b></code> (input)<br> 
   Triangular mesh faces. Each row represents a triangle using 3 vertices in row-major format (x1,y1,z1,x2,y2,z2,x3,y3,z3), size <code>[n_mesh, 9]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::u32_vec <b>*obj_ind</b> = nullptr</code> (optional input)<br> 
   Optional object index for each mesh element (1-based), size <code>[n_mesh]</code>. If provided, the return vector will contain the index of the enclosing object instead of binary values. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>distance</b> = 0.0</code> (optional input)<br> 
   Optional distance in meters from objects that should be considered as <i>inside</i> the object. 
   Possible range: 0 - 20 m. Using this parameter significantly increases computation time. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Returns:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>arma::u32_vec</code>, size <code>[n_points]</code><br> 
   For each point: Returns <code>0</code> if the point is outside the mesh (or all objects), <code>1</code> if inside (or close to) any mesh object 
   (if <code>obj_ind</code> not given), or returns the <b>1-based object index</b> if <code>obj_ind</code> is provided. 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="ray_mesh_interact"></a>
<b>ray_mesh_interact</b> - Calculates interactions (reflection, transmission, refraction) of radio waves with objects
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Radio waves that interact with a building, or other objects in the environment, will produce losses 
   that depend on the electrical properties of the materials and material structure. 
</li><li style="margin-bottom: 0.4em;">This function calculates the interactions of radio-waves with objects in a 3D environment. 
</li><li style="margin-bottom: 0.4em;">It considers a plane wave incident upon a planar interface between two homogeneous and isotropic 
   media of differing electric properties. The media extend sufficiently far from the interface such 
   that the effect of any other interface is negligible. 
</li><li style="margin-bottom: 0.4em;">Supports beam-based modeling using triangular ray tubes defined by <code>trivec</code> and <code>tridir</code>. 
</li><li style="margin-bottom: 0.4em;">Air to media transition is assumed if front side of a face is hit and FBS != SBS 
</li><li style="margin-bottom: 0.4em;">Media to air transition is assumed if back side of a face is hit and FBS != SBS 
</li><li style="margin-bottom: 0.4em;">Media to media transition is assumed if FBS = SBS with opposing face orientations 
</li><li style="margin-bottom: 0.4em;">Order of the vertices determines side (front or back) of a mesh element 
</li><li style="margin-bottom: 0.4em;">Overlapping geometry in the triangle mesh must be avoided, since materials are transparent to radio 
   waves. 
</li><li style="margin-bottom: 0.4em;">Implementation is done according to ITU-R P.2040-1. 
</li><li style="margin-bottom: 0.4em;">Rays that do not interact with the environment (i.e. for which <code>fbs_ind = 0</code>) are omitted from the output. 
</li><li style="margin-bottom: 0.4em;">Maintains consistency of input and output ray formats, including direction encoding (spherical or Cartesian). 
</li><li style="margin-bottom: 0.4em;">Assigns interaction type codes to output rays, allowing classification (e.g., single hit, total  
   reflection, material-to-material). 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
void quadriga_lib::ray_mesh_interact(
                int interaction_type,
                dtype center_frequency,
                const arma::Mat&lt;dtype&gt; *orig,
                const arma::Mat&lt;dtype&gt; *dest,
                const arma::Mat&lt;dtype&gt; *fbs,
                const arma::Mat&lt;dtype&gt; *sbs,
                const arma::Mat&lt;dtype&gt; *mesh,
                const arma::Mat&lt;dtype&gt; *mtl_prop,
                const arma::u32_vec *fbs_ind,
                const arma::u32_vec *sbs_ind,
                const arma::Mat&lt;dtype&gt; *trivec = nullptr,
                const arma::Mat&lt;dtype&gt; *tridir = nullptr,
                const arma::Col&lt;dtype&gt; *orig_length = nullptr,
                arma::Mat&lt;dtype&gt; *origN = nullptr,
                arma::Mat&lt;dtype&gt; *destN = nullptr,
                arma::Col&lt;dtype&gt; *gainN = nullptr,
                arma::Mat&lt;dtype&gt; *xprmatN = nullptr,
                arma::Mat&lt;dtype&gt; *trivecN = nullptr,
                arma::Mat&lt;dtype&gt; *tridirN = nullptr,
                arma::Col&lt;dtype&gt; *orig_lengthN = nullptr,
                arma::Col&lt;dtype&gt; *fbs_angleN = nullptr,
                arma::Col&lt;dtype&gt; *thicknessN = nullptr,
                arma::Col&lt;dtype&gt; *edge_lengthN = nullptr,
                arma::Mat&lt;dtype&gt; *normal_vecN = nullptr,
                arma::s32_vec *out_typeN = nullptr);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>int <b>interaction_type</b></code> (input)<br> 
   Type of interaction: 0 = reflection, 1 = transmission, 2 = refraction. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>dtype <b>center_frequency</b></code> (input)<br> 
   Center frequency in Hz. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b><i>orig</b>, <b></i>dest</b></code> (input)<br> 
   Ray origin and destination points in global Cartesian space. Size: <code>[n_ray, 3]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b><i>fbs</b>, <b></i>sbs</b></code> (input)<br> 
   First and second interaction points. Size: <code>[n_ray, 3]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*mesh</b></code> (input)<br> 
   Triangle mesh faces. Size: <code>[n_mesh, 9]</code>, See <a href="#obj_file_read">obj_file_read</a> for details 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*mtl_prop</b></code> (input)<br> 
   Material properties per face. Size: <code>[n_mesh, 5]</code>, See <a href="#obj_file_read">obj_file_read</a> for details 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::u32_vec <b><i>fbs_ind</b>, <b></i>sbs_ind</b></code> (input)<br> 
   Mesh indices of interaction points (1-based). Size: <code>[n_ray]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*trivec</b></code> (optional input)<br> 
   The 3 vectors pointing from the center point of the ray at the <code>origin</code> to the vertices of a triangular 
   propagation tube (=beam wavefront), the values are in the order <code>[ v1x, v1y, v1z, v2x, v2y, v2z, v3x, v3y, v3z ]</code>; 
   Size: <code>[no_ray, 9]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*tridir</b></code> (optional input)<br> 
   The directions of the vertex-rays. Size: <code>[ n_ray, 6 ]</code> or <code>[ n_ray, 9 ]</code>, 
   For 6 columns, values are in geographic coordinates (azimuth and elevation angle in rad); the  
   values are in the order <code>[ v1az, v1el, v2az, v2el, v3az, v3el ]</code>; 
   For 9 columns, the input is in Cartesian coordinates and the values are in the  order  
   <code>[ v1x, v1y, v1z, v2x, v2y, v2z, v3x, v3y, v3z  ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Col&lt;dtype&gt; <b>*orig_length</b></code> (optional input)<br> 
   Path length at origin. Size: <code>[n_ray]</code>. Default is 0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt; <b>*origN</b></code> (output)<br> 
   New ray origins after the interaction with the medium, usually placed close to the FBS location. 
   A small offset of 0.001 m in the direction of travel after the interaction with the medium is added 
   to avoid getting stuct inside a mesh element. Size: <code>[ no_rayN, 3 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt; <b>*destN</b></code> (output)<br> 
   New ray destinaion after the interaction with the medium, taking the change of direction into account; 
   Size: <code>[no_rayN, 3]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Col&lt;dtype&gt; <b>*gainN</b></code> (output)<br> 
   Gain (negative loss) caused by the interaction with the medium, averaged over both polarization 
   directions. This value includes the in-medium attenuation, but does not account for FSPL.  
   Values are in linear scale (not dB); Size: <code>[no_rayN]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt; <b>*xprmatN</b></code> (output)<br> 
   Polarization transfer matrix; Interleaved complex values (ReVV, ImVV, ReVH, ImVH, ReHV, ImHV, ReHH, ImHH); 
   The values account for the following effects: (1) gain caused by the interaction with the medium, 
   (2) different reflection/transmission coefficients for transverse electric (TE) and transverse 
   magnetic (TM) polarisation, (3) orientation of the incidence plane, (4) in-medium attenuation. 
   FSPL is excluded, Size: <code>[ no_rayN, 8 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt; <b><i>trivecN</b>, <b></i>tridirN</b></code> (output)<br> 
   New ray tube geometry and direction. Format matches input. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Col&lt;dtype&gt; <b>*orig_lengthN</b></code> (output)<br> 
   Length of the ray from <code>orig</code> to <code>origN</code>. If <code>orig_length</code> is given as input, its value is added. 
   Size: <code>[ no_rayN ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Col&lt;dtype&gt; <b>*fbs_angleN</b></code> (output)<br> 
   Angle between incoming ray and FBS in [rad], Size <code>[ n_rayN ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Col&lt;dtype&gt; <b>*thicknessN</b></code> (output)<br> 
   Material thickness in meters calculated from the difference between FBS and SBS, Size <code>[ n_rayN ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Col&lt;dtype&gt; <b>*edge_lengthN</b></code> (output)<br> 
   Max. edge length of the ray tube triangle at the new origin. A value of infinity indicates that only 
   a part of the ray tube hits the object. Size <code>[ n_rayN, 3 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt; <b>*normal_vecN</b></code> (output)<br> 
   Normal vector of FBS and SBS, Size <code>[ n_rayN, 6 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::s32_vec <b>*out_typeN</b></code> (output)<br> 
   A numeric indicator describing the type of the interaction. The total refection indicator is only  
   set in refraction mode. Size <code>[ n_rayN ]</code><br><br> 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <th>No</th>
  <th>θF<0</th>
  <th>θS<0</th>
  <th>dFS=0</th>
  <th>TotRef</th>
  <th>iSBS=0</th>
  <th>NF=-NS</th>
  <th>NF=NS</th>
  <th>startIn</th>
  <th>endIn</th>
  <th>Meaning</th>
</tr>
<tr>
  <td>0</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td>Undefined</td>
</tr>
<tr>
  <td>1</td>
  <td>no</td>
  <td>N/A</td>
  <td>no</td>
  <td>N/A</td>
  <td>yes</td>
  <td>N/A</td>
  <td>N/A</td>
  <td>no</td>
  <td>yes</td>
  <td>Single Hit o-i</td>
</tr>
<tr>
  <td>2</td>
  <td>yes</td>
  <td>N/A</td>
  <td>no</td>
  <td>no</td>
  <td>yes</td>
  <td>N/A</td>
  <td>N/A</td>
  <td>yes</td>
  <td>no</td>
  <td>Single Hit i-o</td>
</tr>
<tr>
  <td>3</td>
  <td>yes</td>
  <td>N/A</td>
  <td>no</td>
  <td>yes</td>
  <td>yes</td>
  <td>N/A</td>
  <td>N/A</td>
  <td>yes</td>
  <td>no</td>
  <td>Single Hit i-o, TR</td>
</tr>
<tr>
  <td>---</td>
  <td>-----</td>
  <td>------</td>
  <td>-------</td>
  <td>--------</td>
  <td>--------</td>
  <td>--------</td>
  <td>-------</td>
  <td>---------</td>
  <td>-------</td>
  <td>----------------------------</td>
</tr>
<tr>
  <td>4</td>
  <td>no</td>
  <td>yes</td>
  <td>yes</td>
  <td>no</td>
  <td>no</td>
  <td>yes</td>
  <td>no</td>
  <td>yes</td>
  <td>yes</td>
  <td>M2M, M2 hit first</td>
</tr>
<tr>
  <td>5</td>
  <td>yes</td>
  <td>no</td>
  <td>yes</td>
  <td>no</td>
  <td>no</td>
  <td>yes</td>
  <td>no</td>
  <td>yes</td>
  <td>yes</td>
  <td>M2M, M1 hit first</td>
</tr>
<tr>
  <td>6</td>
  <td>yes</td>
  <td>no</td>
  <td>yes</td>
  <td>yes</td>
  <td>no</td>
  <td>yes</td>
  <td>no</td>
  <td>yes</td>
  <td>yes</td>
  <td>M2M, M1 hit first, TR</td>
</tr>
<tr>
  <td>---</td>
  <td>-----</td>
  <td>------</td>
  <td>-------</td>
  <td>--------</td>
  <td>--------</td>
  <td>--------</td>
  <td>-------</td>
  <td>---------</td>
  <td>-------</td>
  <td>----------------------------</td>
</tr>
<tr>
  <td>7</td>
  <td>no</td>
  <td>no</td>
  <td>yes</td>
  <td>N/A</td>
  <td>no</td>
  <td>no</td>
  <td>yes</td>
  <td>no</td>
  <td>yes</td>
  <td>Overlapping Faces, o-i</td>
</tr>
<tr>
  <td>8</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
  <td>yes</td>
  <td>yes</td>
  <td>no</td>
  <td>Overlapping Faces, i-o</td>
</tr>
<tr>
  <td>9</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>no</td>
  <td>no</td>
  <td>yes</td>
  <td>yes</td>
  <td>no</td>
  <td>Overlapping Faces, i-o, TR</td>
</tr>
<tr>
  <td>---</td>
  <td>-----</td>
  <td>------</td>
  <td>-------</td>
  <td>--------</td>
  <td>--------</td>
  <td>--------</td>
  <td>-------</td>
  <td>---------</td>
  <td>-------</td>
  <td>----------------------------</td>
</tr>
<tr>
  <td>10</td>
  <td>no</td>
  <td>yes</td>
  <td>yes</td>
  <td>N/A</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
  <td>Edge Hit, o-i-o</td>
</tr>
<tr>
  <td>11</td>
  <td>yes</td>
  <td>no</td>
  <td>yes</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
  <td>yes</td>
  <td>yes</td>
  <td>Edge Hit, i-o-i</td>
</tr>
<tr>
  <td>12</td>
  <td>yes</td>
  <td>no</td>
  <td>yes</td>
  <td>yes</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
  <td>yes</td>
  <td>yes</td>
  <td>Edge Hit, i-o-i, TR</td>
</tr>
<tr>
  <td>13</td>
  <td>no</td>
  <td>no</td>
  <td>yes</td>
  <td>N/A</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
  <td>yes</td>
  <td>Edge Hit, o-i</td>
</tr>
<tr>
  <td>14</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
  <td>yes</td>
  <td>no</td>
  <td>Edge Hit, i-o</td>
</tr>
<tr>
  <td>15</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
  <td>yes</td>
  <td>no</td>
  <td>Edge Hit, i-o, TR</td>
</tr>
</table><br>
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>See also:</i></b><br><ul><li style="margin-bottom: 0.4em;"><a href="#obj_file_read">obj_file_read</a> (for loading <code>mesh</code> and <code>mtl_prop</code> from OBJ file) 
</li><li style="margin-bottom: 0.4em;"><a href="#icosphere">icosphere</a> (for generating beams) 
</li><li style="margin-bottom: 0.4em;"><a href="#ray_triangle_intersect">ray_triangle_intersect</a> (for computing FBS and SBS positions) 
</li><li style="margin-bottom: 0.4em;"><a href="#ray_point_intersect">ray_point_intersect</a> (for calculating beam interactions with sampling points) 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="ray_point_intersect"></a>
<b>ray_point_intersect</b> - Calculates the intersection of ray beams with points in three dimensions
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>Unlike traditional ray tracing, where rays do not have a physical size, beam tracing models rays as  
beams with volume. Beams are defined by triangles whose vertices diverge as the beam extends. This  
approach is used to simulate a kind of divergence or spread in the beam, reminiscent of how radio  
waves spreads as they travel from a point source. The volumetric nature of the beams allows for more  
realistic modeling of energy distribution. As beams widen, the energy they carry can be distributed  
across their cross-sectional area, affecting the intensity of the interaction with surfaces. 
Unlike traditional ray tracing where intersections are line-to-geometry tests, beam tracing requires  
volumetric intersection tests. <br><br> 
 
<ul><li style="margin-bottom: 0.4em;">This function computes whether points in 3D Cartesian space are intersected by ray beams. 
</li><li style="margin-bottom: 0.4em;">A ray beam is defined by a ray origin and a triangular wavefront formed by three directional vectors. 
</li><li style="margin-bottom: 0.4em;">Returns a list of ray indices (0-based) that intersect with each point in the input point cloud. 
</li><li style="margin-bottom: 0.4em;">Optional support for pre-segmented point clouds (e.g., using <a href="#point_cloud_segmentation">point_cloud_segmentation</a>)  
   to reduce computational cost. 
</li><li style="margin-bottom: 0.4em;">All internal computations use single precision for speed. 
</li><li style="margin-bottom: 0.4em;">Uses Advanced Vector Extensions (AVX2) for efficient computation, if supported by the CPU 
</li><li style="margin-bottom: 0.4em;">Recommended to use with small tube radius and well-distributed points for optimal accuracy. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
template &lt;typename dtype&gt;
std::vector&lt;arma::u32_vec&gt; quadriga_lib::ray_point_intersect(
                const arma::Mat&lt;dtype&gt; *points,
                const arma::Mat&lt;dtype&gt; *orig,
                const arma::Mat&lt;dtype&gt; *trivec,
                const arma::Mat&lt;dtype&gt; *tridir,
                const arma::u32_vec *sub_cloud_index = nullptr,
                arma::u32_vec *hit_count = nullptr);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*points</b></code> (input)<br> 
   3D coordinates of the point cloud. Size: <code>[n_points, 3]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*orig</b></code> (input)<br> 
   Ray origin positions in global coordinate system. Size: <code>[n_ray, 3]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*trivec</b></code> (input)<br> 
   The 3 vectors pointing from the center point of the ray at the ray origin to the vertices of  
   a triangular propagation tube (the beam), the values are in the order  
   <code>[ v1x, v1y, v1z, v2x, v2y, v2z, v3x, v3y, v3z ]</code>; Size: <code>[ no_ray, 9 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*tridir</b></code> (input)<br> 
   The directions of the vertex-rays. Size: <code>[ n_ray, 9 ]</code>, Values must be given in Cartesian  
   coordinates in the order  <code>[ d1x, d1y, d1z, d2x, d2y, d2z, d3x, d3y, d3z  ]</code>; The vector does 
   not need to be normalized. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::u32_vec <b>*sub_cloud_index</b> = nullptr</code> (optional input)<br> 
   Index vector to mark boundaries between point cloud segments (e.g. for SIMD optimization). Length: <code>[n_sub]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::u32_vec <b>*hit_count</b> = nullptr</code> (optional output)<br> 
   Output array with number of rays that intersected each point. Length: <code>[n_points]</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Returns:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>std::vector&lt;arma::u32_vec&gt;</code><br> 
   List of ray indices that intersected each point (0-based). Each entry in the returned vector corresponds to one point. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>See also:</i></b><br><ul><li style="margin-bottom: 0.4em;"><a href="#icosphere">icosphere</a> (for generating beams) 
</li><li style="margin-bottom: 0.4em;"><a href="#point_cloud_segmentation">point_cloud_segmentation</a> (for generating point cloud segments) 
</li><li style="margin-bottom: 0.4em;"><a href="#subdivide_rays">subdivide_rays</a> (for subdivides ray beams into sub beams) 
</li><li style="margin-bottom: 0.4em;"><a href="#ray_triangle_intersect">ray_triangle_intersect</a> (for calculating intersection of rays and triangles) 
</li><li style="margin-bottom: 0.4em;"><a href="#ray_mesh_interact">ray_mesh_interact</a> (for calculating interactions of beams and a 3D model) 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="ray_triangle_intersect"></a>
<b>ray_triangle_intersect</b> - Calculates the intersection of rays and triangles in three dimensions
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Implements the Möller–Trumbore algorithm to compute intersections between rays and triangles in 3D. 
</li><li style="margin-bottom: 0.4em;">Efficient SIMD acceleration using AVX2 intrinsics to process 8 mesh triangles in parallel. 
</li><li style="margin-bottom: 0.4em;">Can detect first and second intersections (FBS/SBS), number of intersections, and intersection indices. 
</li><li style="margin-bottom: 0.4em;">Supports a compact input format where origin and destination coordinates are stored together. 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code> 
</li><li style="margin-bottom: 0.4em;">Internal computations are carried out in <b>single precision</b> regardless of <code>dtype</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
void quadriga_lib::ray_triangle_intersect(
                const arma::Mat&lt;dtype&gt; *orig,
                const arma::Mat&lt;dtype&gt; *dest,
                const arma::Mat&lt;dtype&gt; *mesh,
                arma::Mat&lt;dtype&gt; *fbs = nullptr,
                arma::Mat&lt;dtype&gt; *sbs = nullptr,
                arma::u32_vec *no_interact = nullptr,
                arma::u32_vec *fbs_ind = nullptr,
                arma::u32_vec *sbs_ind = nullptr,
                const arma::u32_vec *sub_mesh_index = nullptr,
                bool transpose_inputs = false);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*orig</b></code> (input)<br> 
   Ray origins in global coordinate system (GCS). Size: <code>[n_ray, 3]</code>, or <code>[n_ray, 6]</code> if <code>dest == nullptr</code>.  
   In the latter case, columns must be ordered as <code>{xo, yo, zo, xd, yd, zd}</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*dest</b></code> (input)<br> 
   Ray destinations in GCS. Size: <code>[n_ray, 3]</code>. Set to <code>nullptr</code> if <code>orig</code> has 6 columns and contains  
   both origin and destination. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*mesh</b></code> (input)<br> 
   Triangular surface mesh. Size: <code>[n_mesh, 9]</code>, where each row contains the 3 vertices  
   <code>{x1 y1 z1 x2 y2 z2 x3 y3 z3}</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt; <b>*fbs</b></code> (optional output)<br> 
   First-bounce surface intersection points (FBS). Size: <code>[n_ray, 3]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt; <b>*sbs</b></code> (optional output)<br> 
   Second-bounce surface intersection points (SBS). Size: <code>[n_ray, 3]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::u32_vec <b>*no_interact</b></code> (optional output)<br> 
   Number of intersections per ray (0, 1, or 2). Size: <code>[n_ray]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::u32_vec <b>*fbs_ind</b></code> (optional output)<br> 
   1-based index of the first intersected mesh element, 0 = no intersection. Size: <code>[n_ray]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::u32_vec <b>*sbs_ind</b></code> (optional output)<br> 
   1-based index of the second intersected mesh element, 0 = no second intersection. Size: <code>[n_ray]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::u32_vec <b>*sub_mesh_index</b></code> (optional input)<br> 
   Indexes indicating start of sub-meshes in <code>mesh</code>. Size: <code>[n_sub]</code>. Enables faster processing via segmentation. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>bool <b>transpose_inputs</b> = false</code> (optional input)<br> 
   If <code>true</code>, treats <code>orig</code>/<code>dest</code> as <code>[3, n_ray]</code> and <code>mesh</code> as <code>[9, n_mesh]</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>See also:</i></b><br><ul><li style="margin-bottom: 0.4em;"><a href="#obj_file_read">obj_file_read</a> (for loading <code>mesh</code> from an OBJ file) 
</li><li style="margin-bottom: 0.4em;"><a href="#icosphere">icosphere</a> (for generating beams) 
</li><li style="margin-bottom: 0.4em;"><a href="#triangle_mesh_segmentation">triangle_mesh_segmentation</a> (for calculating sub-meshes) 
</li><li style="margin-bottom: 0.4em;"><a href="#ray_point_intersect">ray_point_intersect</a> (for calculating beam interactions with sampling points) 
</li><li style="margin-bottom: 0.4em;"><a href="#subdivide_rays">subdivide_rays</a> (for subdivides ray beams into sub beams) 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="subdivide_rays"></a>
<b>subdivide_rays</b> - Subdivide ray beams into four smaller sub-beams
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Subdivides each ray beam (defined by a triangular wavefront) into four new beams with adjusted origin, shape, and direction. 
</li><li style="margin-bottom: 0.4em;">Supports input in Spherical or Cartesian direction format. 
</li><li style="margin-bottom: 0.4em;">When <code>dest</code> is not provided, the corresponding output <code>destN</code> is omitted. 
</li><li style="margin-bottom: 0.4em;">Useful for hierarchical ray tracing or angular resolution refinement. 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
arma::uword quadriga_lib::subdivide_rays(
                const arma::Mat&lt;dtype&gt; *orig,
                const arma::Mat&lt;dtype&gt; *trivec,
                const arma::Mat&lt;dtype&gt; *tridir,
                const arma::Mat&lt;dtype&gt; *dest = nullptr,
                arma::Mat&lt;dtype&gt; *origN = nullptr,
                arma::Mat&lt;dtype&gt; *trivecN = nullptr,
                arma::Mat&lt;dtype&gt; *tridirN = nullptr,
                arma::Mat&lt;dtype&gt; *destN = nullptr,
                const arma::u32_vec *index = nullptr,
                const double ray_offset = 0.0);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*orig</b></code> (input)<br> 
   Ray origin points in global coordinate system (GCS). 
   Size: <code>[n_ray, 3]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*trivec</b></code> (input)<br> 
   Vectors pointing from the ray origin to the three triangle vertices. 
   Size: <code>[n_ray, 9]</code>, order: <code>[x1 y1 z1 x2 y2 z2 x3 y3 z3]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*tridir</b></code> (input)<br> 
   Directions of the three vertex-rays. 
   Format can be Spherical <code>[n_ray, 6]</code> as <code>[v1az v1el v2az v2el v3az v3el]</code>, 
   or Cartesian <code>[n_ray, 9]</code> as <code>[v1x v1y v1z v2x v2y v2z v3x v3y v3z]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*dest</b> = nullptr</code> (input)<br> 
   Ray destination points. If <code>nullptr</code>, the output <code>destN</code> will remain empty. 
   Size: <code>[n_ray, 3]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt; <b>*origN</b></code> (output)<br> 
   New ray origins after subdivision. 
   Size: <code>[n_rayN, 3]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt; <b>*trivecN</b></code> (output)<br> 
   Updated vectors for each subdivided triangle beam. 
   Size: <code>[n_rayN, 9]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt; <b>*tridirN</b></code> (output)<br> 
   New directions of the subdivided vertex-rays, in the same format as input. 
   Size: <code>[n_rayN, 6]</code> (spherical) or <code>[n_rayN, 9]</code> (Cartesian). 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt; <b>*destN</b></code> (output)<br> 
   Updated destination points. 
   Size: <code>[n_rayN, 3]</code>, empty if input <code>dest</code> was <code>nullptr</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::u32_vec <b>*index</b></code> (optional input)<br> 
   List of ray indices to be subdivided (0-based). Only the specified rays are subdivided. 
   Size: <code>[n_ind]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const double <b>ray_offset</b> = 0.0</code> (optional input)<br> 
   Offset (in meters) applied to the origin of each subdivided ray along its propagation direction. 
   Default: <code>0.0</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Returns:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>arma::uword  <b>n_rayN</b></code><br> 
   Number of output rays, typically <code>4 × n_ray</code> or <code>4 × n_ind</code> if <code>index</code> is provided. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>See also:</i></b><br><ul><li style="margin-bottom: 0.4em;"><a href="#icosphere">icosphere</a> (for generating beams) 
</li><li style="margin-bottom: 0.4em;"><a href="#ray_point_intersect">ray_point_intersect</a> (for calculating beam interactions with sampling points) 
</li><li style="margin-bottom: 0.4em;"><a href="#ray_triangle_intersect">ray_triangle_intersect</a> (for calculating beam interactions with triangles) 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="subdivide_triangles"></a>
<b>subdivide_triangles</b> - Subdivide triangles into smaller triangles
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Uniformly subdivides each input triangle into <code>n_div × n_div</code> smaller triangles. 
</li><li style="margin-bottom: 0.4em;">Increases spatial resolution for mesh-based processing (e.g., ray tracing or visualization). 
</li><li style="margin-bottom: 0.4em;">Optional input/output material properties are duplicated across subdivided triangles. 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
arma::uword quadriga_lib::subdivide_triangles(
                arma::uword n_div,
                const arma::Mat&lt;dtype&gt; *triangles_in,
                arma::Mat&lt;dtype&gt; *triangles_out,
                const arma::Mat&lt;dtype&gt; *mtl_prop = nullptr,
                arma::Mat&lt;dtype&gt; *mtl_prop_out = nullptr);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>arma::uword <b>n_div</b></code> (input)<br> 
   Number of subdivisions per triangle edge; 
   total output triangles: <code>n_triangles_out = n_triangles_in × n_div × n_div</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*triangles_in</b></code> (input)<br> 
   Vertices of the triangular mesh in global Cartesian coordinates; each face is described by 3 
   points in 3D-space: <code>[ v1x, v1y, v1z, v2x, v2y, v2z, v3x, v3y, v3z ]</code>; Size: <code>[n_triangles_in, 9]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt; <b>*triangles_out</b></code> (output)<br> 
   Vertices of the sub-divided mesh in global Cartesian coordinates; Size: <code>[n_triangles_out, 9]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*mtl_prop</b> = nullptr</code> (optional input)<br> 
   Material properties associated for the input triangles; Size: <code>[n_triangles_in, 5]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt; <b>*mtl_prop_out</b> = nullptr</code> (optional output)<br> 
   Material properties for the subdivided triangles, copied from the parent triangle, 
   Size: <code>[n_triangles_out, 5]</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Returns:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>arma::uword <b>n_triangles_out</b></code><br> 
   Number of generated triangles (equals <code>n_triangles_in × n_div × n_div</code>). 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="triangle_mesh_aabb"></a>
<b>triangle_mesh_aabb</b> - Calculate the axis-aligned bounding box (AABB) of a triangle mesh and its sub-meshes
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>The axis-aligned minimum bounding box (or AABB) for a given set of triangles is its minimum 
bounding box subject to the constraint that the edges of the box are parallel to the (Cartesian) 
coordinate axes. Axis-aligned bounding boxes are used as an approximate location of the set of 
triangles. In order to find intersections with the triangles (e.g. using ray tracing), the 
initial check is the intersections between the rays and the AABBs. Since it is usually a much 
less expensive operation than the check of the actual intersection (because it only requires 
comparisons of coordinates), it allows quickly excluding checks of the pairs that are far apart.<br><br> 
 
<ul><li style="margin-bottom: 0.4em;">This function computes the axis-aligned bounding box for each sub-mesh in a 3D triangle mesh. 
</li><li style="margin-bottom: 0.4em;">Each triangle is defined by three vertices in a flat row: <code>[x1, y1, z1, x2, y2, z2, x3, y3, z3]</code>. 
</li><li style="margin-bottom: 0.4em;">Sub-meshes are defined by the <code>sub_mesh_index</code> list, indicating the starting row of each sub-mesh. 
</li><li style="margin-bottom: 0.4em;">The resulting bounding boxes are returned as a matrix of shape <code>[n_sub, 6]</code> with columns: <code>[x_min, x_max, y_min, y_max, z_min, z_max]</code>. 
</li><li style="margin-bottom: 0.4em;">If <code>vec_size &gt; 1</code>, the result is padded such that the number of rows in the output is a multiple of <code>vec_size</code>. 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
arma::Mat&lt;dtype&gt; quadriga_lib::triangle_mesh_aabb(
                const arma::Mat&lt;dtype&gt; *mesh,
                const arma::u32_vec *sub_mesh_index = nullptr,
                arma::uword vec_size = 1);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*mesh</b></code> (input)<br> 
   Vertices of the triangle mesh in global Cartesian coordinates. Each face is described by 3 
   points in 3D-space: <code>[ v1x, v1y, v1z, v2x, v2y, v2z, v3x, v3y, v3z ]</code>; Size: <code>[ n_triangles, 9 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::u32_vec <b>*sub_mesh_index</b> = nullptr</code> (optional input)<br> 
   Start indices of the sub-meshes in 0-based notation. If this parameter is not given, the AABB of 
   the entire triangle mesh is returned; Length <code>[n_sub]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::uword <b>vec_size</b> = 1</code> (optional input)<br> 
   Alignment size for SIMD processing (e.g., <code>8</code> for AVX2, <code>32</code> for CUDA).  
   Output is padded to a multiple of this value. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Returns:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt;</code><br>  
   A matrix of shape <code>[n_sub_aligned, 6]</code>, where each row is <code>[x_min, x_max, y_min, y_max, z_min, z_max]</code>. 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="triangle_mesh_segmentation"></a>
<b>triangle_mesh_segmentation</b> - Reorganize a 3D mesh into smaller sub-meshes for faster processing
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>This function processes the elements of a large triangle mesh by clustering those that are 
closely spaced. The resulting mesh retains the same elements but rearranges their order. 
The function aims to minimize the size of the axis-aligned bounding box around each cluster, 
referred to as a sub-mesh, while striving to maintain a specific number of elements within 
each cluster.<br><br> 
 
<ul><li style="margin-bottom: 0.4em;">Subdivision is recursive and based on bounding box partitioning until each sub-mesh contains no more than <code>target_size</code> triangles. 
</li><li style="margin-bottom: 0.4em;">Sub-meshes are aligned to <code>vec_size</code> for SIMD or GPU optimization; padded with dummy triangles at the center of each sub-mesh if needed. 
</li><li style="margin-bottom: 0.4em;">If material properties are provided, these are also reorganized and padded accordingly. 
</li><li style="margin-bottom: 0.4em;">The function returns the number of created sub-meshes, and reorders the triangles and materials. 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
arma::uword quadriga_lib::triangle_mesh_segmentation(
                const arma::Mat&lt;dtype&gt; *mesh,
                arma::Mat&lt;dtype&gt; *meshR,
                arma::u32_vec *sub_mesh_index,
                arma::uword target_size = 1024,
                arma::uword vec_size = 1,
                const arma::Mat&lt;dtype&gt; *mtl_prop = nullptr,
                arma::Mat&lt;dtype&gt; *mtl_propR = nullptr,
                arma::u32_vec *mesh_index = nullptr);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*mesh</b></code> (input)<br> 
   Vertices of the triangular mesh in global Cartesian coordinates. Each face is described by 3 
   points in 3D-space: <code>[ v1x, v1y, v1z, v2x, v2y, v2z, v3x, v3y, v3z ]</code>; Size: <code>[n_mesh, 9]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt; <b>*meshR</b></code> (output)<br> 
   Vertices of the clustered mesh in global Cartesian coordinates; Size: <code>[n_meshR, 9]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::u32_vec <b>*sub_mesh_index</b></code> (output)<br> 
   Start indices of the sub-meshes in 0-based notation; Vector of length <code>[n_sub]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::uword <b>target_size</b> = 1024</code> (input)<br> 
   The target number of elements of each sub-mesh. Default value = 1024. For best performance, the 
   value should be around <code>sgrt(n_mesh)</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::uword <b>vec_size</b> = 1</code> (input)<br> 
   Vector size for SIMD processing (e.g. 8 for AVX2, 32 for CUDA). Default value = 1. 
   For values > 1,the number of rows for each sub-mesh in the output is increased to a multiple 
   of <code>vec_size</code>. For padding, zero-sized triangles are placed at the center of the AABB of 
   the corresponding sub-mesh. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*mtl_prop</b> = nullptr</code> (optional input)<br> 
   Material properties corresponding to the original mesh; Size: <code>[n_mesh, 5]</code>; See <a href="#obj_file_read">obj_file_read</a> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt; <b>*mtl_propR</b> = nullptr</code> (optional output)<br> 
   Reorganized material properties, aligned and padded if necessary, Size: <code>[n_meshR, 5]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::u32_vec <b>*mesh_index</b> = nullptr</code> (optional output)<br> 
   1-based mapping from the original mesh to the reorganized mesh; Size: <code>[n_meshR]</code> (0 = padding) 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Returns:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>arma::uword <b>n_sub</b></code><br> 
   The number of created sub-meshes. Output matrices are resized accordingly. 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="triangle_mesh_split"></a>
<b>triangle_mesh_split</b> - Split a 3D mesh into two sub-meshes along a given axis
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Divides a triangular mesh into two sub-meshes along a selected axis (or automatically the longest). 
</li><li style="margin-bottom: 0.4em;">The function chooses a split point based on the bounding box center of the selected axis. 
</li><li style="margin-bottom: 0.4em;">Returns the axis used for the split: <code>1 = x</code>, <code>2 = y</code>, <code>3 = z</code>; or negative values if the split failed. 
</li><li style="margin-bottom: 0.4em;">An optional indicator vector identifies the target sub-mesh (A or B) for each input point. 
</li><li style="margin-bottom: 0.4em;">On failure (i.e., all triangles fall into one side), outputs <code>meshA</code> and <code>meshB</code> remain unchanged. 
</li><li style="margin-bottom: 0.4em;">Allowed datatypes (<code>dtype</code>): <code>float</code> or <code>double</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
int quadriga_lib::triangle_mesh_split(
                const arma::Mat&lt;dtype&gt; *mesh,
                arma::Mat&lt;dtype&gt; *meshA,
                arma::Mat&lt;dtype&gt; *meshB,
                int axis = 0,
                arma::Col&lt;int&gt; *split_ind = nullptr);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>const arma::Mat&lt;dtype&gt; <b>*mesh</b></code> (input)<br> 
   Triangle mesh input; each row contains one triangle as <code>[x1 y1 z1 x2 y2 z2 x3 y3 z3]</code> 
   Size: <code>[n_mesh, 9]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt; <b>*meshA</b></code> (output)<br> 
   First resulting sub-mesh; triangles with centroid below split threshold. Size: <code>[n_meshA, 9]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Mat&lt;dtype&gt; <b>*meshB</b></code> (output)<br> 
   Second resulting sub-mesh; triangles with centroid above split threshold. Size: <code>[n_meshB, 9]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>int <b>axis</b> = 0</code> (optional input)<br> 
   Axis to split along: <code>0</code> = longest extent (default), <code>1</code> = x-axis, <code>2</code> = y-axis, <code>3</code> = z-axis. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>arma::Col&lt;int&gt; <b>*split_ind</b> = nullptr</code> (optional output)<br> 
   Output vector indicating assignment of each triangle: <code>1</code> = meshA, <code>2</code> = meshB, <code>0</code> = not assigned (on failure) 
   Length: <code>[n_mesh]</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Returns:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>int</code> <br> 
   The axis used for the split (<code>1</code>, <code>2</code>, or <code>3</code>), or negative value on failure (<code>-1</code>, <code>-2</code>, or <code>-3</code>). 
</li></ul>
</li>
</ul>
    <!-- CONTENT END -->

    <br>
    <!-- <br> -->

    <div id="quadriga-lib_sf_line"></div>

  </div>

</body>

</html>