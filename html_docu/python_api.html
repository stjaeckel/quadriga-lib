<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta content="text/html;" http-equiv="Content-Type">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" href="quadriga-lib-q_letter64.png" type="image/png">
  <link type="text/css" rel="stylesheet" href="style2.css">
  <title>Quadriga-Lib: C++/MEX Utility library for radio channel modelling and simulations</title>
  <meta name="description" content="Quadriga-Lib is an open-source C++ library for realistic radio 
      channel modelling with MATLAB/Octave/Python APIs and tools for arrays, channel data, and site-specific simulations.">
 </head>
 
<body>

  <div id="quadriga-lib_header">
    <div id="quadriga-lib_header_row">
      <div id="quadriga-lib_header_cell_logo_img">
        <a href="http://quadriga-lib.org">
          <img id="quadriga-lib_logo_img" src="quadriga-lib-logo80.png" alt="Quadriga-Lib" align="top" border="0">
        </a>
      </div>
      <div id="quadriga-lib_header_spacer"></div>
      <div id="quadriga-lib_header_cell_logo_txt">
        <div id="quadriga-lib_logo_img2"></div><big><big><b>Quadriga-Lib</b>
          </big><br>C++/MEX/Python Utility library for radio channel modelling and simulations</big>
      </div>
    </div>
  </div>

  <div id="quadriga-lib_menu">
    <ul class="quadriga-lib_menu">
      <li class="quadriga-lib_menu"><a class="quadriga-lib_menu" href="index.html">About</a></li>
      <li class="quadriga-lib_menu"><a class="quadriga-lib_menu" href="cpp_api.html">C++ API</a></li>
      <li class="quadriga-lib_menu"><a class="quadriga-lib_menu" href="mex_api.html">MATLAB API</a></li>
      <li class="quadriga-lib_menu"><a class="quadriga-lib_menu_selected" href="python_api.html">Python API</a></li>
      <li class="quadriga-lib_menu"><a class="quadriga-lib_menu" href="formats.html">Data Formats</a></li>
      <li class="quadriga-lib_menu"><a class="quadriga-lib_menu" href="faq.html">Questions</a></li>
      <li class="quadriga-lib_menu"><a class="quadriga-lib_menu" href="download.html">Download</a></li>
    </ul>
  </div>

  <div id="quadriga-lib_content">

      <!-- CONTENT BEGIN --><big><b>Python API Documentation for Quadriga-Lib v0.10.4</b></big>
<br><br><br>

<b>Notes</b>
<br>

<ul>
<li>The Quadriga-Lib Python interface of implemented using pybind11. 
Before getting started, make sure that the Python library is compiled for your system and python environment.</li>
<br>
<li>Unless otherwise stated, the Quadriga-Lib Python API reads and writes data to and from Numpy arrays in 
    double precision. Hence, you need to have numpy installed and imported in your python file.</li>
<br>    
<li>There is currently no Microsoft Windows version of the Quadriga-Lib Python interface.
    This is planned for a later stage.</li>
<br>    
<li>The Quadriga-Lib Python package is compiled into a single ".so" file located in the "lib" folder. 
To import it in Python, the "lib" folder must be on your Python path, which is usually not the case
unless you install a package using pip or conda. To import the "quadriga_lib" from a custom location,
you can do the following:
<pre>
import sys
import numpy as np

sys.path.append("/path_to/quadriga-lib/lib")
import quadriga_lib
</pre></li>


</ul>

<br> 
<b>Overview</b>
<ul>
<li><a href="#e091e809">Array antenna functions</a></li>
<li><a href="#eab50272">Channel functions</a></li>
<li><a href="#b11e2d16">Miscellaneous / Tools</a></li>
<li><a href="#2c1fd9e4">Site-Specific Simulation Tools</a></li>
</ul>
<br>
<b>Array antenna functions</b>
<ul>
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tbody>
<tr><td><a href="#calc_directivity">calc_directivity</a></td><td>Calculates the directivity (in dBi) of array antenna elements</td></tr>
<tr><td><a href="#combine_pattern">combine_pattern</a></td><td>Calculate effective radiation patterns for array antennas</td></tr>
<tr><td><a href="#copy_element">copy_element</a></td><td>Create copies of array antenna elements</td></tr>
<tr><td><a href="#export_obj_file">export_obj_file</a></td><td>Creates a Wavefront OBJ file for visualizing the shape of the antenna pattern</td></tr>
<tr><td><a href="#generate">generate</a></td><td>Generates predefined array antenna models</td></tr>
<tr><td><a href="#interpolate">interpolate</a></td><td>Interpolate array antenna field patterns</td></tr>
<tr><td><a href="#qdant_read">qdant_read</a></td><td>Reads array antenna data from QDANT files</td></tr>
<tr><td><a href="#qdant_write">qdant_write</a></td><td>Writes array antenna data to QDANT files</td></tr>
<tr><td><a href="#rotate_pattern">rotate_pattern</a></td><td>Rotates antenna patterns</td></tr>
<tr><td><a href="#generate_speaker">generate_speaker</a></td><td>Generates a parametric loudspeaker directivity model</td></tr>
<tr><td><a href="#get_channels_planar">get_channels_planar</a></td><td>Calculate channel coefficients for planar waves</td></tr>
<tr><td><a href="#get_channels_spherical">get_channels_spherical</a></td><td>Calculate channel coefficients from path data and antenna patterns</td></tr>
</tbody>
</table>
</ul>
<br>
<b>Channel functions</b>
<ul>
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tbody>
<tr><td><a href="#baseband_freq_response">baseband_freq_response</a></td><td>Transforms the channel into frequency domain and returns the frequency response</td></tr>
<tr><td><a href="#channel_export_obj_file">channel_export_obj_file</a></td><td>Export path data to a Wavefront OBJ file for visualization in Blender</td></tr>
<tr><td><a href="#get_ieee_indoor">get_ieee_indoor</a></td><td>Generate indoor MIMO channel realizations for IEEE TGn/TGac/TGax/TGah models</td></tr>
<tr><td><a href="#hdf5_create_file">hdf5_create_file</a></td><td>Create a new HDF5 channel file with a custom storage layout</td></tr>
<tr><td><a href="#hdf5_read_channel">hdf5_read_channel</a></td><td>Reads channel data from HDF5 files</td></tr>
<tr><td><a href="#hdf5_read_dset">hdf5_read_dset</a></td><td>Read a single unstructured dataset from an HDF5 file</td></tr>
<tr><td><a href="#hdf5_read_dset_names">hdf5_read_dset_names</a></td><td>Read the names of unstructured data fields from an HDF5 file</td></tr>
<tr><td><a href="#hdf5_read_layout">hdf5_read_layout</a></td><td>Read the storage layout of channel data inside an HDF5 file</td></tr>
<tr><td><a href="#hdf5_reshape_layout">hdf5_reshape_layout</a></td><td>Reshapes the storage layout inside an existing HDF5 file</td></tr>
<tr><td><a href="#hdf5_write_channel">hdf5_write_channel</a></td><td>Writes channel data to HDF5 files</td></tr>
<tr><td><a href="#hdf5_write_dset">hdf5_write_dset</a></td><td>Writes unstructured data to a HDF5 file</td></tr>
<tr><td><a href="#qrt_file_parse">qrt_file_parse</a></td><td>Read metadata from a QRT file</td></tr>
<tr><td><a href="#qrt_file_read">qrt_file_read</a></td><td>Read ray-tracing data from QRT file</td></tr>
</tbody>
</table>
</ul>
<br>
<b>Miscellaneous / Tools</b>
<ul>
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tbody>
<tr><td><a href="#cart2geo">cart2geo</a></td><td>Transform Cartesian (x,y,z) coordinates to Geographic (az, el, length) coordinates</td></tr>
<tr><td><a href="#components">components</a></td><td>Returns the version numbers of all quadriga-lib sub-components</td></tr>
<tr><td><a href="#version">version</a></td><td>Returns the quadriga-lib version number</td></tr>
<tr><td><a href="#write_png">write_png</a></td><td>Write data to a PNG file</td></tr>
</tbody>
</table>
</ul>
<br>
<b>Site-Specific Simulation Tools</b>
<ul>
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tbody>
<tr><td><a href="#icosphere">icosphere</a></td><td>Construct a geodesic polyhedron (icosphere), a convex polyhedron made from triangles</td></tr>
<tr><td><a href="#mitsuba_xml_file_write">mitsuba_xml_file_write</a></td><td>Write geometry and material data to a Mitsuba 3 XML scene file.</td></tr>
<tr><td><a href="#obj_file_read">obj_file_read</a></td><td>Reads a triangulated 3D polygon mesh from a Wavefront OBJ file</td></tr>
<tr><td><a href="#point_cloud_aabb">point_cloud_aabb</a></td><td>Calculates the axis-aligned bounding box (AABB) for a 3D point cloud or a set of sub-clouds</td></tr>
<tr><td><a href="#point_cloud_segmentation">point_cloud_segmentation</a></td><td>Rearranges elements of a point cloud into smaller sub-clouds</td></tr>
<tr><td><a href="#point_inside_mesh">point_inside_mesh</a></td><td>Test whether 3D points are inside a triangle mesh using raycasting</td></tr>
<tr><td><a href="#ray_point_intersect">ray_point_intersect</a></td><td>Calculates which 3D points are intersected by volumetric ray beams</td></tr>
<tr><td><a href="#ray_triangle_intersect">ray_triangle_intersect</a></td><td>Calculates the intersection of rays and triangles in three dimensions</td></tr>
<tr><td><a href="#triangle_mesh_aabb">triangle_mesh_aabb</a></td><td>Calculate the axis-aligned bounding box (AABB) of a triangle mesh and its sub-meshes</td></tr>
<tr><td><a href="#triangle_mesh_segmentation">triangle_mesh_segmentation</a></td><td>Rearranges elements of a triangle mesh into smaller sub-meshes</td></tr>
</tbody>
</table>
</ul>
<br>
<div class="pagebreak"></div>
<hr class="greyline">
<hr class="greyline">
<br>
<br>
<a name="e091e809"></a>
<font size=+1><b>Array antenna functions</b></font>
<br>
<br>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="calc_directivity"></a>
<b>calc_directivity</b> - Calculates the directivity (in dBi) of array antenna elements
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>Directivity is a parameter of an antenna or which measures the degree to which the radiation emitted 
is concentrated in a single direction. It is the ratio of the radiation intensity in a given direction 
from the antenna to the radiation intensity averaged over all directions. Therefore, the directivity 
of a hypothetical isotropic radiator is 1, or 0 dBi.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
from quadriga_lib import arrayant
directivity = arrayant.calc_directivity(arrayant, element)
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>arrayant_in</code></b><br> 
   Dictionary containing the arrayant data with the following keys: 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>e_theta_re</code></td>
  <td>e-theta field component, real part</td>
  <td>Shape: <code>(n_elevation, n_azimuth, n_elements)</code></td>
</tr>
<tr>
  <td><code>e_theta_im</code></td>
  <td>e-theta field component, imaginary part</td>
  <td>Shape: <code>(n_elevation, n_azimuth, n_elements)</code></td>
</tr>
<tr>
  <td><code>e_phi_re</code></td>
  <td>e-phi field component, real part</td>
  <td>Shape: <code>(n_elevation, n_azimuth, n_elements)</code></td>
</tr>
<tr>
  <td><code>e_phi_im</code></td>
  <td>e-phi field component, imaginary part</td>
  <td>Shape: <code>(n_elevation, n_azimuth, n_elements)</code></td>
</tr>
<tr>
  <td><code>azimuth_grid</code></td>
  <td>Azimuth angles in [rad], -pi to pi, sorted</td>
  <td>Shape: <code>(n_azimuth)</code></td>
</tr>
<tr>
  <td><code>elevation_grid</code></td>
  <td>Elevation angles in [rad], -pi/2 to pi/2, sorted</td>
  <td>Shape: <code>(n_elevation)</code></td>
</tr>
</table><br>
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>element</code></b> (optional)<br> 
   Element index, 0-based. If not provided or empty, the directivity is calculated for all elements in the 
   array antenna. Shape: <code>(n_out)</code> or empty 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Argument:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>directivity</code></b><br> 
   Directivity of the antenna pattern in dBi, Shape: <code>[n_out)</code> or <code>[n_elements)</code> 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="combine_pattern"></a>
<b>combine_pattern</b> - Calculate effective radiation patterns for array antennas
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>An array antenna consists of multiple individual elements. Each element occupies a specific position 
relative to the array's phase-center, its local origin. Elements can also be inter-coupled, 
represented by a coupling matrix. By integrating the element radiation patterns, their positions, 
and the coupling weights, one can determine an effective radiation pattern observable by a receiver 
in the antenna's far field. Leveraging these effective patterns is especially beneficial in antenna 
design, beamforming applications such as in 5G systems, and in planning wireless communication 
networks in complex environments like urban areas. This streamlined approach offers a significant 
boost in computation speed when calculating MIMO channel coefficients, as it reduces the number of 
necessary operations. The function <code>arrayant_combine_pattern</code> is designed to compute these effective 
radiation patterns.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
from quadriga_lib import arrayant

# Minimal example
arrayant_out = arrayant.combine_pattern(arrayant)

# Optional inputs: freq, azimuth_grid, elevation_grid
arrayant_out = arrayant.combine_pattern(arrayant, freq, azimuth_grid, elevation_grid)
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>arrayant</code></b><br> 
   Dictionary containing the arrayant data with the following keys: 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>e_theta_re</code></td>
  <td>e-theta field component, real part</td>
  <td>Shape: <code>(n_elevation, n_azimuth, n_elements)</code></td>
</tr>
<tr>
  <td><code>e_theta_im</code></td>
  <td>e-theta field component, imaginary part</td>
  <td>Shape: <code>(n_elevation, n_azimuth, n_elements)</code></td>
</tr>
<tr>
  <td><code>e_phi_re</code></td>
  <td>e-phi field component, real part</td>
  <td>Shape: <code>(n_elevation, n_azimuth, n_elements)</code></td>
</tr>
<tr>
  <td><code>e_phi_im</code></td>
  <td>e-phi field component, imaginary part</td>
  <td>Shape: <code>(n_elevation, n_azimuth, n_elements)</code></td>
</tr>
<tr>
  <td><code>azimuth_grid</code></td>
  <td>Azimuth angles in [rad], -pi to pi, sorted</td>
  <td>Shape: <code>(n_azimuth)</code></td>
</tr>
<tr>
  <td><code>elevation_grid</code></td>
  <td>Elevation angles in [rad], -pi/2 to pi/2, sorted</td>
  <td>Shape: <code>(n_elevation)</code></td>
</tr>
<tr>
  <td><code>element_pos</code></td>
  <td>Antenna element (x,y,z) positions</td>
  <td>Shape: <code>(3, n_elements)</code></td>
</tr>
<tr>
  <td><code>coupling_re</code></td>
  <td>Coupling matrix, real part</td>
  <td>Shape: <code>(n_elements, n_ports)</code></td>
</tr>
<tr>
  <td><code>coupling_im</code></td>
  <td>Coupling matrix, imaginary part</td>
  <td>Shape: <code>(n_elements, n_ports)</code></td>
</tr>
<tr>
  <td><code>center_freq</code></td>
  <td>Center frequency in [Hz], optional</td>
  <td>Scalar</td>
</tr>
<tr>
  <td><code>name</code></td>
  <td>Name of the array antenna object, optional</td>
  <td>String</td>
</tr>
</table><br>
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>freq</code></b> (optional)<br> 
   An alternative value for the center frequency. Overwrites the value given in <code>arrayant_in</code>. If 
   neither <code>freq</code> not <code>arrayant_in["center_freq")</code> are given, an error is thrown. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>azimuth_grid</code></b> (optional)<br> 
   Alternative azimuth angles for the output in [rad], -pi to pi, sorted, Shape: <code>(n_azimuth_out)</code>, 
   If not given, <code>arrayant_in["azimuth_grid")</code> is used instead. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>elevation_grid</code></b> (optional)<br> 
   Alternative elevation angles for the output in [rad], -pi/2 to pi/2, sorted, Shape: <code>(n_elevation_out)</code>, 
   If not given, <code>arrayant_in["elevation_grid")</code> is used instead. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>arrayant_out</code></b><br> 
   Dictionary containing the arrayant data with the following keys: 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>e_theta_re</code></td>
  <td>e-theta field component, real part</td>
  <td>Shape: <code>(n_elevation_out, n_azimuth_out, n_ports)</code></td>
</tr>
<tr>
  <td><code>e_theta_im</code></td>
  <td>e-theta field component, imaginary part</td>
  <td>Shape: <code>(n_azimuth_out, n_azimuth_out, n_ports)</code></td>
</tr>
<tr>
  <td><code>e_phi_re</code></td>
  <td>e-phi field component, real part</td>
  <td>Shape: <code>(n_azimuth_out, n_azimuth_out, n_ports)</code></td>
</tr>
<tr>
  <td><code>e_phi_im</code></td>
  <td>e-phi field component, imaginary part</td>
  <td>Shape: <code>(n_azimuth_out, n_azimuth_out, n_ports)</code></td>
</tr>
<tr>
  <td><code>azimuth_grid</code></td>
  <td>Azimuth angles in [rad], -pi to pi, sorted</td>
  <td>Shape: <code>(n_azimuth_out)</code></td>
</tr>
<tr>
  <td><code>elevation_grid</code></td>
  <td>Elevation angles in [rad], -pi/2 to pi/2, sorted</td>
  <td>Shape: <code>(n_azimuth_out)</code></td>
</tr>
<tr>
  <td><code>element_pos</code></td>
  <td>Antenna element (x,y,z) positions, set to 0</td>
  <td>Shape: <code>(3, n_ports)</code></td>
</tr>
<tr>
  <td><code>coupling_re</code></td>
  <td>Coupling matrix, real part, identity matrix</td>
  <td>Shape: <code>(n_ports, n_ports)</code></td>
</tr>
<tr>
  <td><code>coupling_im</code></td>
  <td>Coupling matrix, imaginary part, zero matrix</td>
  <td>Shape: <code>(n_ports, n_ports)</code></td>
</tr>
<tr>
  <td><code>center_freq</code></td>
  <td>Center frequency in [Hz]</td>
  <td>Scalar</td>
</tr>
<tr>
  <td><code>name</code></td>
  <td>Name of the array antenna object, same as input</td>
  <td>String</td>
</tr>
</table><br>
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="copy_element"></a>
<b>copy_element</b> - Create copies of array antenna elements
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>Copies one or more antenna elements to new positions within the arrayant, expanding the element 
count if necessary. Supports both single-frequency arrayants (3D pattern fields) and multi-frequency 
arrayants (4D pattern fields). For multi-frequency inputs, element copying is applied consistently 
across all frequency entries. 
 
The function auto-detects whether the input is single-frequency or multi-frequency by inspecting 
the dimensionality of the <code>e_theta_re</code> field (3D = single, 4D = multi).
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
from quadriga_lib import arrayant

# Single-frequency: copy element 0 to position 1
arrayant_out = arrayant.copy_element(ant, source_element=[0], dest_element=[1])

# Single-frequency: copy element 0 to positions 2 and 3
arrayant_out = arrayant.copy_element(ant, source_element=[0], dest_element=[2, 3])

# Multi-frequency (4D patterns): same interface
speaker_out = arrayant.copy_element(speaker, source_element=[0], dest_element=[1])

# Copy multiple sources to multiple destinations (must be same length)
arrayant_out = arrayant.copy_element(ant, source_element=[0, 1], dest_element=[2, 3])
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>arrayant</code></b> [1] (required)<br> 
   Dictionary containing the arrayant data. Pattern fields may be 3D (single-frequency) or 
   4D (multi-frequency, 4th dimension = frequency). The following keys are expected: 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>e_theta_re</code></td>
  <td>e-theta field component, real part</td>
  <td>Shape: <code>(n_el, n_az, n_elem)</code> or <code>(n_el, n_az, n_elem, n_freq)</code></td>
</tr>
<tr>
  <td><code>e_theta_im</code></td>
  <td>e-theta field component, imaginary part</td>
  <td>Shape: <code>(n_el, n_az, n_elem)</code> or <code>(n_el, n_az, n_elem, n_freq)</code></td>
</tr>
<tr>
  <td><code>e_phi_re</code></td>
  <td>e-phi field component, real part</td>
  <td>Shape: <code>(n_el, n_az, n_elem)</code> or <code>(n_el, n_az, n_elem, n_freq)</code></td>
</tr>
<tr>
  <td><code>e_phi_im</code></td>
  <td>e-phi field component, imaginary part</td>
  <td>Shape: <code>(n_el, n_az, n_elem)</code> or <code>(n_el, n_az, n_elem, n_freq)</code></td>
</tr>
<tr>
  <td><code>azimuth_grid</code></td>
  <td>Azimuth angles in [rad], -pi to pi, sorted</td>
  <td>Shape: <code>(n_azimuth)</code></td>
</tr>
<tr>
  <td><code>elevation_grid</code></td>
  <td>Elevation angles in [rad], -pi/2 to pi/2, sorted</td>
  <td>Shape: <code>(n_elevation)</code></td>
</tr>
<tr>
  <td><code>element_pos</code></td>
  <td>Antenna element (x,y,z) positions, optional</td>
  <td>Shape: <code>(3, n_elements)</code></td>
</tr>
<tr>
  <td><code>coupling_re</code></td>
  <td>Coupling matrix, real part, optional</td>
  <td>Shape: <code>(n_elem, n_ports)</code> or <code>(n_elem, n_ports, n_freq)</code></td>
</tr>
<tr>
  <td><code>coupling_im</code></td>
  <td>Coupling matrix, imaginary part, optional</td>
  <td>Shape: <code>(n_elem, n_ports)</code> or <code>(n_elem, n_ports, n_freq)</code></td>
</tr>
<tr>
  <td><code>center_freq</code></td>
  <td>Center frequency in [Hz], optional</td>
  <td>Scalar or 1D array <code>(n_freq)</code></td>
</tr>
<tr>
  <td><code>name</code></td>
  <td>Name of the array antenna object, optional</td>
  <td>String</td>
</tr>
</table><br>
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>source_element</code></b> [2] (required)<br> 
   Index of the source elements (0-based), scalar or vector 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>dest_element</code></b> [3] (optional)<br> 
   Index of the destination elements (0-based), either as a vector or as a scalar. If <code>source_element</code> 
   is also a vector, <code>dest_element</code> must have the same length. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>arrayant_out</code></b><br> 
   Dictionary containing the arrayant data with the copied elements. Output format matches the 
   input format (3D for single-frequency, 4D for multi-frequency). 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="export_obj_file"></a>
<b>export_obj_file</b> - Creates a Wavefront OBJ file for visualizing the shape of the antenna pattern
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
from quadriga_lib import arrayant
arrayant.export_obj_file( fn, arrayant, directivity_range, colormap,
                object_radius, icosphere_n_div, i_element )
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>fn</code></b><br> 
   Filename of the OBJ file, string 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>arrayant</code></b><br> 
   Dictionary containing array antenna data with at least the following keys: 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>e_theta_re</code></td>
  <td>Real part of e-theta field component</td>
  <td>Shape: <code>(n_elevation, n_azimuth, n_elements_c)</code></td>
</tr>
<tr>
  <td><code>e_theta_im</code></td>
  <td>Imaginary part of e-theta field component</td>
  <td>Shape: <code>(n_elevation, n_azimuth, n_elements_c)</code></td>
</tr>
<tr>
  <td><code>e_phi_re</code></td>
  <td>Real part of e-phi field component</td>
  <td>Shape: <code>(n_elevation, n_azimuth, n_elements_c)</code></td>
</tr>
<tr>
  <td><code>e_phi_im</code></td>
  <td>Imaginary part of e-phi field component</td>
  <td>Shape: <code>(n_elevation, n_azimuth, n_elements_c)</code></td>
</tr>
<tr>
  <td><code>azimuth_grid</code></td>
  <td>Azimuth angles in [rad] -pi to pi, sorted</td>
  <td>Shape: <code>(n_azimuth)</code></td>
</tr>
<tr>
  <td><code>elevation_grid</code></td>
  <td>Elevation angles in [rad], -pi/2 to pi/2, sorted</td>
  <td>Shape: <code>(n_elevation)</code></td>
</tr>
<tr>
  <td><code>element_pos</code></td>
  <td>Antenna element (x,y,z) positions, optional</td>
  <td>Shape: <code>(3, n_elements)</code></td>
</tr>
<tr>
  <td><code>name</code></td>
  <td>Name of the array antenna object</td>
  <td>String</td>
</tr>
</table><br>
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>directivity_range</code></b><br> 
   Directivity range of the antenna pattern visualization in dB 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>colormap</code></b><br> 
   Colormap for the visualization, string, supported are 'jet', 'parula', 'winter', 'hot', 'turbo', 
   'copper', 'spring', 'cool', 'gray', 'autumn', 'summer', Optional, default = 'jet' 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>object_radius</code></b><br> 
   Radius in meters of the exported object 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>icosphere_n_div</code></b><br> 
   Map pattern to an Icosphere with given number of subdivisions 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>element</code></b><br> 
   Antenna element indices, 0-based, empty = export all 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="generate"></a>
<b>generate</b> - Generates predefined array antenna models
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>This functions can be used to generate a variety of pre-defined array antenna models, including 3GPP 
array antennas used for 5G-NR simulations. The first argument is the array type. The following input 
arguments are then specific to this type.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
from quadriga_lib import arrayant

# Isotropic radiator, vertical polarization
arrayant = arrayant.generate('omni', res)

# Short dipole radiating with vertical polarization
arrayant = arrayant.generate('dipole', res)

# Half-wave dipole radiating with vertical polarization
arrayant = arrayant.generate('half-wave-dipole', res)

# Cross-polarized isotropic radiator
arrayant = arrayant.generate('xpol', res)

# A unified linear array with isotropic patterns
arrayant = arrayant.generate('ula', res=30, N=4, freq=2.4e9, spacing=0.7)

# An antenna with a custom 3dB beam with (in degree)
arrayant = arrayant.generate('custom', res, az_3dB, el_3db, rear_gain_lin)

# 3GPP-NR antenna model (example for 2x2, V-polarized, 0.7λ spacing)
arrayant = arrayant.generate('3gpp', M=2, N=2, freq=3.7e9, pol=1, spacing=0.7)

# Planar multi-element antenna with support for multiple beam directions
arrayant = arrayant.generate('multibeam', M=6, N=6, freq=3.7e9, pol=1, spacing=0.7, az=[-30.0, 30.0], el=[0.0, 0.0])
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>type</code></b><br> 
   Antenna model type, string 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>res</code></b><br> 
   Pattern resolution in [deg], scalar, default = 1 deg 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>freq</code></b><br> 
   The center frequency in [Hz], scalar, default = 299792458 Hz 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input arguments for type `custom`, `3gpp` and `multibeam`:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>az_3dB</code></b><br> 
   3dB beam width in azimuth direction in [deg], scalar, 
   default for <code>custom</code> = 90 deg, default for <code>3gpp</code> = 67 deg, <code>multibeam</code> = 120 deg 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>el_3db</code></b><br> 
   3dB beam width in elevation direction in [deg], scalar, 
   default for <code>custom</code> = 90 deg, default for <code>3gpp</code> = 67 deg, <code>multibeam</code> = 120 deg 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>rear_gain_lin</code></b><br> 
   Isotropic gain (linear scale) at the back of the antenna, scalar, default = 0.0 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input arguments for type `3gpp` and `multibeam`:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>M</code></b><br> 
   Number of vertically stacked elements for <code>3gpp</code> and <code>multibeam</code>, scalar, default = 1 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>N</code></b><br> 
   Number of horizontally stacked elements for <code>3gpp</code>, <code>ula</code> and <code>multibeam</code>, scalar, default = 1 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>pol</code></b><br> 
   Polarization indicator to be applied for each of the M elements:<br> 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>pol = 1</code></td>
  <td>vertical polarization (default value), <code>3gpp</code> and <code>multibeam</code></td>
</tr>
<tr>
  <td><code>pol = 2</code></td>
  <td>H/V polarized elements, results in 2NM elements, <code>3gpp</code> and <code>multibeam</code></td>
</tr>
<tr>
  <td><code>pol = 3</code></td>
  <td>+/-45° polarized elements, results in 2NM elements, <code>3gpp</code> and <code>multibeam</code></td>
</tr>
<tr>
  <td><code>pol = 4</code></td>
  <td>vertical polarization, combines elements in vertical direction, results in N elements, <code>3gpp</code> only</td>
</tr>
<tr>
  <td><code>pol = 5</code></td>
  <td>H/V polarization, combines elements in vertical direction, results in 2N elements, <code>3gpp</code> only</td>
</tr>
<tr>
  <td><code>pol = 6</code></td>
  <td>+/-45° polarization, combines elements in vertical direction, results in 2N elements, <code>3gpp</code> only</td>
</tr>
</table><br>
   Polarization indicator is ignored when a custom pattern is provided. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>tilt</code></b><br> 
   The electric downtilt angle in [deg], Only relevant for <code>pol = 4/5/6</code>, <code>3gpp</code> only, scalar, default = 0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>spacing</code></b><br> 
   Element spacing in [λ] for <code>3gpp</code>, <code>ula</code> and <code>multibeam</code>, scalar, default = 0.5 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>Mg</code></b><br> 
   Number of nested panels in a column, <code>3gpp</code> only, scalar, default = 1 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>Ng</code></b><br> 
   Number of nested panels in a row, <code>3gpp</code> only, scalar, default = 1 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>dgv</code></b><br> 
   Panel spacing in vertical direction in [λ], <code>3gpp</code> only, scalar, default = 0.5 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>dgh</code></b><br> 
   Panel spacing in horizontal direction in [λ], <code>3gpp</code> only, scalar, default = 0.5 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>beam_az</code></b><br> 
   Azimuth beam angles (degrees), <code>multibeam</code> only, Vector of length <code>n_beams</code>. Default: <code>[0.0]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>beam_el</code></b><br> 
   Elevation beam angles (degrees), <code>multibeam</code> only, Vector of length <code>n_beams</code>. Default: <code>[0.0]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>beam_weight</code></b><br> 
   Scaling factors for each beam, <code>multibeam</code> only, The vector must have the same length as <code>beam_az</code> and <code>beam_el</code>. 
   Values are normalized so that their sum equals 1. Can be used to prioritize beams. 
   Default: <code>{1.0}</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>separate_beams</code></b><br> 
   If set to true, create a separate beam for each angle pair (ignores weights), <code>multibeam</code> only 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>apply_weights</code></b><br> 
   Switch to apply the beam-forming weights 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>pattern</code></b> (optional)<br> 
   Dictionary containing a custom pattern (default = empty) with at least the following keys: 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>e_theta_re</code></td>
  <td>Real part of e-theta field component</td>
  <td>Shape: <code>(n_elevation, n_azimuth, n_elements_c)</code></td>
</tr>
<tr>
  <td><code>e_theta_im</code></td>
  <td>Imaginary part of e-theta field component</td>
  <td>Shape: <code>(n_elevation, n_azimuth, n_elements_c)</code></td>
</tr>
<tr>
  <td><code>e_phi_re</code></td>
  <td>Real part of e-phi field component</td>
  <td>Shape: <code>(n_elevation, n_azimuth, n_elements_c)</code></td>
</tr>
<tr>
  <td><code>e_phi_im</code></td>
  <td>Imaginary part of e-phi field component</td>
  <td>Shape: <code>(n_elevation, n_azimuth, n_elements_c)</code></td>
</tr>
<tr>
  <td><code>azimuth_grid</code></td>
  <td>Azimuth angles in [rad] -pi to pi, sorted</td>
  <td>Shape: <code>(n_azimuth)</code></td>
</tr>
<tr>
  <td><code>elevation_grid</code></td>
  <td>Elevation angles in [rad], -pi/2 to pi/2, sorted</td>
  <td>Shape: <code>(n_elevation)</code></td>
</tr>
</table><br>
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>arrayant</code></b><br> 
   Dictionary containing the arrayant data with the following keys: 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>e_theta_re</code></td>
  <td>e-theta field component, real part</td>
  <td>Shape: <code>(n_elevation, n_azimuth, n_elements)</code></td>
</tr>
<tr>
  <td><code>e_theta_im</code></td>
  <td>e-theta field component, imaginary part</td>
  <td>Shape: <code>(n_elevation, n_azimuth, n_elements)</code></td>
</tr>
<tr>
  <td><code>e_phi_re</code></td>
  <td>e-phi field component, real part</td>
  <td>Shape: <code>(n_elevation, n_azimuth, n_elements)</code></td>
</tr>
<tr>
  <td><code>e_phi_im</code></td>
  <td>e-phi field component, imaginary part</td>
  <td>Shape: <code>(n_elevation, n_azimuth, n_elements)</code></td>
</tr>
<tr>
  <td><code>azimuth_grid</code></td>
  <td>Azimuth angles in [rad] -pi to pi, sorted</td>
  <td>Shape: <code>(n_azimuth)</code></td>
</tr>
<tr>
  <td><code>elevation_grid</code></td>
  <td>Elevation angles in [rad], -pi/2 to pi/2, sorted</td>
  <td>Shape: <code>(n_elevation)</code></td>
</tr>
<tr>
  <td><code>element_pos</code></td>
  <td>Antenna element (x,y,z) positions</td>
  <td>Shape: <code>(3, n_elements)</code></td>
</tr>
<tr>
  <td><code>coupling_re</code></td>
  <td>Coupling matrix, real part</td>
  <td>Shape: <code>(n_elements, n_ports)</code></td>
</tr>
<tr>
  <td><code>coupling_im</code></td>
  <td>Coupling matrix, imaginary part</td>
  <td>Shape: <code>(n_elements, n_ports)</code></td>
</tr>
<tr>
  <td><code>center_freq</code></td>
  <td>Center frequency in [Hz], optional, default = 0.3 GHz</td>
  <td>Scalar</td>
</tr>
<tr>
  <td><code>name</code></td>
  <td>Name of the array antenna object</td>
  <td>String</td>
</tr>
</table><br>
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="interpolate"></a>
<b>interpolate</b> - Interpolate array antenna field patterns
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">This function interpolates polarimetric antenna field patterns for a given set of azimuth and 
   elevation angles. It supports both single-frequency arrayants (3D pattern fields) and multi-frequency 
   arrayants (4D pattern fields). The function auto-detects the input format by inspecting the 
   dimensionality of the <code>e_theta_re</code> field (3D = single-frequency, 4D = multi-frequency). 
</li><li style="margin-bottom: 0.4em;">For multi-frequency inputs, the function interpolates both spatially (azimuth/elevation) and across 
   frequency, producing output fields with an additional frequency dimension. Target frequencies for 
   the multi-frequency path are specified via the <code>frequency</code> parameter. The options <code>dist</code> and 
   <code>local_angles</code> are only available for the single-frequency path without <code>frequency</code>. 
</li><li style="margin-bottom: 0.4em;">If a single-frequency arrayant (3D patterns) is used together with the <code>frequency</code> parameter, the 
   function performs spatial interpolation once and replicates the 2D result across all requested 
   frequencies, yielding 3D output of shape <code>(n_out, n_ang, n_freq_out)</code>. This allows uniform output 
   shapes regardless of whether the underlying arrayant is frequency-dependent or not. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
from quadriga_lib import arrayant

# Minimal example (single-frequency, 3D patterns)
vr,vi,hr,hi = arrayant.interpolate(arrayant, azimuth, elevation)

# Output as complex type
v,h = arrayant.interpolate(arrayant, azimuth, elevation, complex=1)

# Generate projected distance (single-frequency only)
vr,vi,hr,hi,dist = arrayant.interpolate(arrayant, azimuth, elevation, dist=1)
v,h,dist = arrayant.interpolate(arrayant, azimuth, elevation, complex=1, dist=1)

# Additional inputs
vr,vi,hr,hi = arrayant.interpolate(arrayant, azimuth, elevation, element, orientation, element_pos)

# Output angles in antenna-local coordinates (single-frequency only)
vr,vi,hr,hi,az_local,el_local,gamma = arrayant.interpolate(arrayant, azimuth, elevation, orientation=ori, local_angles=1)

# Multi-frequency interpolation (4D patterns)
vr,vi,hr,hi = arrayant.interpolate(speaker, azimuth, elevation, frequency=freqs)
v,h = arrayant.interpolate(speaker, azimuth, elevation, frequency=freqs, complex=1)

# Single-frequency arrayant with frequency duplication (output is 3D, duplicated across freqs)
vr,vi,hr,hi = arrayant.interpolate(ant, azimuth, elevation, frequency=freqs)
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>arrayant</code></b> (required)<br> 
   Dictionary containing array antenna data. Pattern fields may be 3D (single-frequency) or 
   4D (multi-frequency, 4th dimension = frequency). The following keys are expected: 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>e_theta_re</code></td>
  <td>Real part of e-theta field component</td>
  <td>Shape: <code>(n_elevation, n_azimuth, n_elements)</code> or <code>(n_elevation, n_azimuth, n_elements, n_freq)</code></td>
</tr>
<tr>
  <td><code>e_theta_im</code></td>
  <td>Imaginary part of e-theta field component</td>
  <td>Shape: <code>(n_elevation, n_azimuth, n_elements)</code> or <code>(n_elevation, n_azimuth, n_elements, n_freq)</code></td>
</tr>
<tr>
  <td><code>e_phi_re</code></td>
  <td>Real part of e-phi field component</td>
  <td>Shape: <code>(n_elevation, n_azimuth, n_elements)</code> or <code>(n_elevation, n_azimuth, n_elements, n_freq)</code></td>
</tr>
<tr>
  <td><code>e_phi_im</code></td>
  <td>Imaginary part of e-phi field component</td>
  <td>Shape: <code>(n_elevation, n_azimuth, n_elements)</code> or <code>(n_elevation, n_azimuth, n_elements, n_freq)</code></td>
</tr>
<tr>
  <td><code>azimuth_grid</code></td>
  <td>Azimuth angles in [rad] -pi to pi, sorted</td>
  <td>Shape: <code>(n_azimuth)</code></td>
</tr>
<tr>
  <td><code>elevation_grid</code></td>
  <td>Elevation angles in [rad], -pi/2 to pi/2, sorted</td>
  <td>Shape: <code>(n_elevation)</code></td>
</tr>
<tr>
  <td><code>element_pos</code></td>
  <td>Antenna element (x,y,z) positions, optional</td>
  <td>Shape: <code>(3, n_elements)</code></td>
</tr>
<tr>
  <td><code>center_freq</code></td>
  <td>Center frequency in [Hz], optional</td>
  <td>Scalar or 1D array <code>(n_freq)</code></td>
</tr>
</table><br>
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>azimuth</code></b> (required)<br> 
   Azimuth angles in [rad] for which the field pattern should be interpolated. Values must be between -pi and pi. 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td>Option 1:</td>
  <td>Use the same angles for all antenna elements (planar wave approximation)</td>
</tr>
<tr>
  <td></td>
  <td>Shape: <code>(1, n_ang)</code></td>
</tr>
<tr>
  <td>Option 2:</td>
  <td>Provide different angles for each array element (e.g. for spherical waves)</td>
</tr>
<tr>
  <td></td>
  <td>Shape: <code>(n_out, n_ang)</code></td>
</tr>
</table><br>
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>elevation</code></b> (required)<br> 
   Elevation angles in [rad] for which the field pattern should be interpolated. Values must be between -pi/2 and pi/2. 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td>Option 1:</td>
  <td>Use the same angles for all antenna elements (planar wave approximation)</td>
</tr>
<tr>
  <td></td>
  <td>Shape: <code>(1, n_ang)</code></td>
</tr>
<tr>
  <td>Option 2:</td>
  <td>Provide different angles for each array element (e.g. for spherical waves)</td>
</tr>
<tr>
  <td></td>
  <td>Shape: <code>[n_out, n_ang)</code></td>
</tr>
</table><br>
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>element</code></b> (optional)<br> 
   The element indices for which the interpolation should be done. Optional parameter. Values must 
   be between 0 and n_elements-1. It is possible to duplicate elements, i.e. by passing <code>[1,1,2]</code>. 
   If this parameter is not provided (or an empty array is passed), <code>i_element</code> is initialized 
   to <code>[0:n_elements-1]</code>. In this case, <code>n_out = n_elements</code>. 
   Shape: <code>(1, n_out)</code> or <code>(n_out, 1)</code> or empty <code>()</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>orientation</code></b> (optional)<br> 
   This (optional) 3-element vector describes the orientation of the array antenna or of individual 
   array elements using Euler angles in [rad]. 
   Shape: <code>(3, 1)</code> or <code>(3, n_out)</code> or <code>(3, 1, n_ang)</code> or <code>(3, n_out, n_ang)</code> or empty <code>()</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>element_pos</code></b> (optional)<br> 
   Alternative positions of the array antenna elements in local cartesian coordinates (using units of [m]). 
   If this parameter is not given, element positions from <code>arrayant</code> are used. If the <code>arrayant</code> has no 
   positions, they are initialized to [0,0,0]. For example, when duplicating the first element by setting 
   <code>element = [1,1]</code>, different element positions can be set for the two elements in the output. 
   Shape: <code>(3, n_out)</code> or empty <code>()</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>frequency</code></b> (optional)<br> 
   Target frequencies in [Hz] for multi-frequency interpolation. When the input arrayant has 4D 
   pattern fields, each requested frequency is interpolated between the two bracketing entries; 
   out-of-range frequencies are clamped to the nearest entry. When the input arrayant has 3D 
   pattern fields, the spatial interpolation is performed once and the result is duplicated across 
   all requested frequencies. In both cases, the output shape gains a frequency dimension 
   <code>(n_out, n_ang, n_freq_out)</code>. If empty, no frequency dimension is added (single-frequency 
   path returns 2D outputs). The options <code>dist</code> and <code>local_angles</code> are not available when 
   <code>frequency</code> is provided. 
   Shape: <code>(n_freq_out)</code> or empty <code>()</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>complex</code></b> (optional flag)<br> 
   If set to 1, output is returned in complex notation. This reduces performance due to additional 
   copies of the data in memory. Default: 0, false 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>dist</code></b> (optional flag)<br> 
   Switch to calculate the effective distances for phase calculation. Only available for single-frequency 
   arrayants (3D patterns). Default: 0, false 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>local_angles</code></b> (optional flag)<br> 
   Switch to return the angles in antenna-local coordinates. These differ from the input when the 
   orientation of the antenna is adjusted. Only available for single-frequency arrayants (3D patterns). 
   Default: 0, false 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>fast_access</code></b> (optional flag)<br> 
   If arrayant data is provided as numpy.ndarray of type double in Fortran-contiguous (column-major) 
   order, <code>arrayant_interpolate</code> can access the Python memory directly without a conversion of the 
   data. This will increase performance and is done by default. If the data is not in the correct 
   format, a conversion is done in the background. Setting <code>fast_access</code> to 1 will skip the conversion 
   and throw an error if the arrayant data is not correctly formatted. Only applies to the single- 
   frequency path. Default: 0, false (convert) 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Derived inputs:</i></b><br><table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>n_azimuth</code></td>
  <td>Number of azimuth angles in the field pattern</td>
</tr>
<tr>
  <td><code>n_elevation</code></td>
  <td>Number of elevation angles in the field pattern</td>
</tr>
<tr>
  <td><code>n_elements</code></td>
  <td>Number of antenna elements in the field pattern of the array antenna</td>
</tr>
<tr>
  <td><code>n_ang</code></td>
  <td>Number of interpolation angles</td>
</tr>
<tr>
  <td><code>n_out</code></td>
  <td>Number of antenna elements in the generated output (may differ from n_elements)</td>
</tr>
<tr>
  <td><code>n_freq</code></td>
  <td>Number of frequency entries in the multi-frequency arrayant (4D input only)</td>
</tr>
<tr>
  <td><code>n_freq_out</code></td>
  <td>Number of target frequencies (multi-frequency path only)</td>
</tr>
</table><br>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments (single-frequency path):</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>vr</code></b><br> 
   Real part of the interpolated e-theta (vertical) field component. Shape <code>(n_out, n_ang)</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>vi</code></b><br> 
   Imaginary part of the interpolated e-theta (vertical) field component. Shape <code>(n_out, n_ang)</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>hr</code></b><br> 
   Real part of the interpolated e-phi (horizontal) field component. Shape <code>(n_out, n_ang)</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>hi</code></b><br> 
   Imaginary part of the interpolated e-phi (horizontal) field component. Shape <code>(n_out, n_ang)</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>dist</code></b> (optional)<br> 
   The effective distances between the antenna elements when seen from the direction of the 
   incident path. The distance is calculated by a projection of the array positions on the normal 
   plane of the incident path. This is needed for calculating the phase of the antenna response. 
   Only returned when <code>dist</code> flag is set to 1. Shape <code>(n_out, n_ang)</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>azimuth_loc</code></b> (optional)<br> 
   The azimuth angles in [rad] for the local antenna coordinate system, i.e., after applying the 
   'orientation'. If no orientation vector is given, these angles are identical to the input 
   azimuth angles. Only returned when <code>local_angles</code> flag is set to 1. Shape <code>(n_out, n_ang)</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>elevation_loc</code></b> (optional)<br> 
   The elevation angles in [rad] for the local antenna coordinate system, i.e., after applying the 
   'orientation'. If no orientation vector is given, these angles are identical to the input 
   elevation angles. Only returned when <code>local_angles</code> flag is set to 1. Shape <code>(n_out, n_ang)</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>gamma</code></b> (optional)<br> 
   Polarization rotation angles in [rad]. Only returned when <code>local_angles</code> flag is set to 1. 
   Shape <code>(n_out, n_ang)</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments (multi-frequency path):</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>vr</code></b><br> 
   Real part of the interpolated e-theta (vertical) field component. Shape <code>(n_out, n_ang, n_freq_out)</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>vi</code></b><br> 
   Imaginary part of the interpolated e-theta (vertical) field component. Shape <code>(n_out, n_ang, n_freq_out)</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>hr</code></b><br> 
   Real part of the interpolated e-phi (horizontal) field component. Shape <code>(n_out, n_ang, n_freq_out)</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>hi</code></b><br> 
   Imaginary part of the interpolated e-phi (horizontal) field component. Shape <code>(n_out, n_ang, n_freq_out)</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>v</code></b> (complex mode)<br> 
   Complex-valued interpolated e-theta (vertical) field component. Shape <code>(n_out, n_ang, n_freq_out)</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>h</code></b> (complex mode)<br> 
   Complex-valued interpolated e-phi (horizontal) field component. Shape <code>(n_out, n_ang, n_freq_out)</code> 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="qdant_read"></a>
<b>qdant_read</b> - Reads array antenna data from QDANT files
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">The QuaDRiGa array antenna exchange format (QDANT) is a file format used to store antenna pattern 
   data in XML. This function reads pattern data from the specified file. 
</li><li style="margin-bottom: 0.4em;">Supports both single-entry and multi-entry (multi-frequency) reading: 
</li><li style="margin-bottom: 0.4em;"><b>Single-entry (id &ge; 1):</b> Reads one antenna entry from the file. Pattern fields are returned as 
   3D arrays <code>(n_el, n_az, n_elem)</code>. This is the default behavior. 
</li><li style="margin-bottom: 0.4em;"><b>Multi-entry (id = 0):</b> Reads all antenna entries from the file and returns them as a single 
   multi-frequency arrayant dict. Pattern fields are returned as 4D arrays 
   <code>(n_el, n_az, n_elem, n_freq)</code>, center frequencies as a 1D array, and coupling matrices as 3D 
   arrays if they vary across entries. This is the inverse of <code>qdant_write</code> with 4D input. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
from quadriga_lib import arrayant

# Read a single antenna entry (default: first entry)
data = arrayant.qdant_read('antenna.qdant')
data = arrayant.qdant_read('antenna.qdant', id=2)

# Read all entries as multi-frequency arrayant (4D patterns)
data = arrayant.qdant_read('speaker.qdant', id=0)
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>fn</code></b><br> 
   Filename of the QDANT file, string 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>id</code></b> (optional)<br> 
   ID of the antenna to be read from the file. Default: <code>1</code> (read first entry). 
   Set to <code>0</code> to read all entries as a multi-frequency arrayant. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>data</code></b><br> 
   Dictionary containing the data in the QDANT file with the following keys: 
</li></ul>
 
  For single-entry (id &ge; 1): 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>e_theta_re</code></td>
  <td>e-theta field component, real part</td>
  <td>Shape: <code>(n_el, n_az, n_elem)</code></td>
</tr>
<tr>
  <td><code>e_theta_im</code></td>
  <td>e-theta field component, imaginary part</td>
  <td>Shape: <code>(n_el, n_az, n_elem)</code></td>
</tr>
<tr>
  <td><code>e_phi_re</code></td>
  <td>e-phi field component, real part</td>
  <td>Shape: <code>(n_el, n_az, n_elem)</code></td>
</tr>
<tr>
  <td><code>e_phi_im</code></td>
  <td>e-phi field component, imaginary part</td>
  <td>Shape: <code>(n_el, n_az, n_elem)</code></td>
</tr>
<tr>
  <td><code>azimuth_grid</code></td>
  <td>Azimuth angles in [rad], -pi to pi, sorted</td>
  <td>Shape: <code>(n_azimuth)</code></td>
</tr>
<tr>
  <td><code>elevation_grid</code></td>
  <td>Elevation angles in [rad], -pi/2 to pi/2, sorted</td>
  <td>Shape: <code>(n_elevation)</code></td>
</tr>
<tr>
  <td><code>element_pos</code></td>
  <td>Antenna element (x,y,z) positions</td>
  <td>Shape: <code>(3, n_elements)</code></td>
</tr>
<tr>
  <td><code>coupling_re</code></td>
  <td>Coupling matrix, real part</td>
  <td>Shape: <code>(n_elements, n_ports)</code></td>
</tr>
<tr>
  <td><code>coupling_im</code></td>
  <td>Coupling matrix, imaginary part</td>
  <td>Shape: <code>(n_elements, n_ports)</code></td>
</tr>
<tr>
  <td><code>center_freq</code></td>
  <td>Center frequency in [Hz]</td>
  <td>Scalar</td>
</tr>
<tr>
  <td><code>name</code></td>
  <td>Name of the array antenna object</td>
  <td>String</td>
</tr>
<tr>
  <td><code>layout</code></td>
  <td>Layout of multiple array antennas</td>
  <td>Matrix</td>
</tr>
</table><br>
 
  For multi-entry (id = 0): 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>e_theta_re</code></td>
  <td>e-theta field component, real part</td>
  <td>Shape: <code>(n_el, n_az, n_elem, n_freq)</code></td>
</tr>
<tr>
  <td><code>e_theta_im</code></td>
  <td>e-theta field component, imaginary part</td>
  <td>Shape: <code>(n_el, n_az, n_elem, n_freq)</code></td>
</tr>
<tr>
  <td><code>e_phi_re</code></td>
  <td>e-phi field component, real part</td>
  <td>Shape: <code>(n_el, n_az, n_elem, n_freq)</code></td>
</tr>
<tr>
  <td><code>e_phi_im</code></td>
  <td>e-phi field component, imaginary part</td>
  <td>Shape: <code>(n_el, n_az, n_elem, n_freq)</code></td>
</tr>
<tr>
  <td><code>azimuth_grid</code></td>
  <td>Azimuth angles in [rad], -pi to pi, sorted</td>
  <td>Shape: <code>(n_azimuth)</code></td>
</tr>
<tr>
  <td><code>elevation_grid</code></td>
  <td>Elevation angles in [rad], -pi/2 to pi/2, sorted</td>
  <td>Shape: <code>(n_elevation)</code></td>
</tr>
<tr>
  <td><code>element_pos</code></td>
  <td>Antenna element (x,y,z) positions</td>
  <td>Shape: <code>(3, n_elements)</code></td>
</tr>
<tr>
  <td><code>coupling_re</code></td>
  <td>Coupling matrix, real part</td>
  <td>Shape: <code>(n_elem, n_ports)</code> or <code>(n_elem, n_ports, n_freq)</code></td>
</tr>
<tr>
  <td><code>coupling_im</code></td>
  <td>Coupling matrix, imaginary part</td>
  <td>Shape: <code>(n_elem, n_ports)</code> or <code>(n_elem, n_ports, n_freq)</code></td>
</tr>
<tr>
  <td><code>center_freq</code></td>
  <td>Center frequencies in [Hz]</td>
  <td>Shape: <code>(n_freq)</code></td>
</tr>
<tr>
  <td><code>name</code></td>
  <td>Name of the array antenna object</td>
  <td>String</td>
</tr>
<tr>
  <td><code>layout</code></td>
  <td>Layout of multiple array antennas</td>
  <td>Matrix</td>
</tr>
</table><br>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>See also:</i></b><br><ul><li style="margin-bottom: 0.4em;"><a href="#qdant_write">qdant_write</a> (for writing QDANT data) 
</li><li style="margin-bottom: 0.4em;">QuaDRiGa Array Antenna Exchange Format  (<a href="formats.html#6cab4884">QDANT</a>) 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="qdant_write"></a>
<b>qdant_write</b> - Writes array antenna data to QDANT files
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">The QuaDRiGa array antenna exchange format (QDANT) is a file format used to store antenna pattern 
   data in XML. This function writes pattern data to the specified file. 
</li><li style="margin-bottom: 0.4em;">Supports both single-frequency arrayants (3D pattern fields) and multi-frequency arrayants 
   (4D pattern fields). The function auto-detects the format by inspecting the dimensionality of 
   <code>e_theta_re</code> (3D = single, 4D = multi). 
</li><li style="margin-bottom: 0.4em;"><b>Single-frequency:</b> Writes one antenna entry to the file. The <code>id</code> parameter controls where the 
   entry is placed. Multiple antennas can be stored in the same file by calling this function 
   repeatedly with different IDs. 
</li><li style="margin-bottom: 0.4em;"><b>Multi-frequency:</b> Writes all frequency entries as sequential IDs (1-based) to the file. The file 
   is overwritten if it already exists. A layout matrix is created automatically. The <code>id</code> and <code>layout</code> 
   parameters are ignored for multi-frequency inputs. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
from quadriga_lib import arrayant

# Single-frequency: write with optional ID
id_in_file = arrayant.qdant_write('antenna.qdant', ant)
id_in_file = arrayant.qdant_write('antenna.qdant', ant, id=2)

# Multi-frequency (4D patterns): writes all frequencies sequentially
arrayant.qdant_write('speaker.qdant', speaker)
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>fn</code></b> [1]<br> 
   Filename of the QDANT file, string 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>arrayant</code></b> [2] (optional)<br> 
   Dictionary containing the arrayant data. Pattern fields may be 3D (single-frequency) or 
   4D (multi-frequency, 4th dimension = frequency). The following keys are expected: 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>e_theta_re</code></td>
  <td>e-theta field component, real part</td>
  <td>Shape: <code>(n_el, n_az, n_elem)</code> or <code>(n_el, n_az, n_elem, n_freq)</code></td>
</tr>
<tr>
  <td><code>e_theta_im</code></td>
  <td>e-theta field component, imaginary part</td>
  <td>Shape: <code>(n_el, n_az, n_elem)</code> or <code>(n_el, n_az, n_elem, n_freq)</code></td>
</tr>
<tr>
  <td><code>e_phi_re</code></td>
  <td>e-phi field component, real part</td>
  <td>Shape: <code>(n_el, n_az, n_elem)</code> or <code>(n_el, n_az, n_elem, n_freq)</code></td>
</tr>
<tr>
  <td><code>e_phi_im</code></td>
  <td>e-phi field component, imaginary part</td>
  <td>Shape: <code>(n_el, n_az, n_elem)</code> or <code>(n_el, n_az, n_elem, n_freq)</code></td>
</tr>
<tr>
  <td><code>azimuth_grid</code></td>
  <td>Azimuth angles in [rad], -pi to pi, sorted</td>
  <td>Shape: <code>(n_azimuth)</code></td>
</tr>
<tr>
  <td><code>elevation_grid</code></td>
  <td>Elevation angles in [rad], -pi/2 to pi/2, sorted</td>
  <td>Shape: <code>(n_elevation)</code></td>
</tr>
<tr>
  <td><code>element_pos</code></td>
  <td>Antenna element (x,y,z) positions, optional</td>
  <td>Shape: <code>(3, n_elements)</code></td>
</tr>
<tr>
  <td><code>coupling_re</code></td>
  <td>Coupling matrix, real part, optional</td>
  <td>Shape: <code>(n_elem, n_ports)</code> or <code>(n_elem, n_ports, n_freq)</code></td>
</tr>
<tr>
  <td><code>coupling_im</code></td>
  <td>Coupling matrix, imaginary part, optional</td>
  <td>Shape: <code>(n_elem, n_ports)</code> or <code>(n_elem, n_ports, n_freq)</code></td>
</tr>
<tr>
  <td><code>center_freq</code></td>
  <td>Center frequency in [Hz], optional</td>
  <td>Scalar or 1D array <code>(n_freq)</code></td>
</tr>
<tr>
  <td><code>name</code></td>
  <td>Name of the array antenna object, optional</td>
  <td>String</td>
</tr>
</table><br>
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>id</code></b> [3] (optional, single-frequency only)<br> 
   ID of the antenna to be written to the file, optional, Default: Max-ID in existing file + 1. 
   Ignored for multi-frequency inputs. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>layout</code></b> [4] (optional, single-frequency only)<br> 
   Layout of multiple array antennas. Must only contain element ids that are present in the file. 
   Ignored for multi-frequency inputs. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Argument:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>id_in_file</code></b><br> 
   For single-frequency: ID of the antenna in the file after writing. 
   For multi-frequency: always returns 0 (all entries are written sequentially starting at ID 1). 
</li></ul>
 
# See also: 
<ul><li style="margin-bottom: 0.4em;"><a href="#qdant_read">qdant_read</a> (for reading QDANT data) 
</li><li style="margin-bottom: 0.4em;">QuaDRiGa Array Antenna Exchange Format  (<a href="formats.html#6cab4884">QDANT</a>) 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="rotate_pattern"></a>
<b>rotate_pattern</b> - Rotates antenna patterns
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">This function transforms the radiation patterns of array antenna elements, allowing for 
   precise rotations around the three principal axes (x, y, z) of the local Cartesian coordinate system. 
   The 3 rotations are applied in the order: 1. rotation around the x-axis (bank angle); 
   2. rotation around the y-axis (tilt angle), 3. rotation around the z-axis (heading angle). 
</li><li style="margin-bottom: 0.4em;">Supports both single-frequency arrayants (3D pattern fields) and multi-frequency arrayants 
   (4D pattern fields). For multi-frequency inputs, the rotation is applied consistently across all 
   frequency entries. The function auto-detects the format by inspecting the dimensionality of 
   <code>e_theta_re</code> (3D = single, 4D = multi). 
</li><li style="margin-bottom: 0.4em;"><b>Note on usage modes for multi-frequency:</b> Grid adjustment (usage 0 and 1) is not supported for 
   multi-frequency arrayants because all frequency entries must share the same angular grid. The multi- 
   frequency path automatically maps usage 0 → 3 (pattern + polarization, no grid adjust) and 
   usage 1 → 4 (pattern only, no grid adjust). Usage 2 (polarization only) works identically in both 
   paths. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
from quadriga_lib import arrayant

# Single-frequency: rotate all elements by 45 deg bank
arrayant_out = arrayant.rotate_pattern(ant, x_deg=45.0)

# Single-frequency: rotate only elements 0 and 1 (0-based)
arrayant_out = arrayant.rotate_pattern(ant, z_deg=90.0, element=[0, 1])

# Multi-frequency (4D patterns): same interface
speaker_out = arrayant.rotate_pattern(speaker, y_deg=10.0)
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>arrayant</code></b><br> 
   Dictionary containing the arrayant data. Pattern fields may be 3D (single-frequency) or 
   4D (multi-frequency, 4th dimension = frequency). The following keys are expected: 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>e_theta_re</code></td>
  <td>e-theta field component, real part</td>
  <td>Shape: <code>(n_el, n_az, n_elem)</code> or <code>(n_el, n_az, n_elem, n_freq)</code></td>
</tr>
<tr>
  <td><code>e_theta_im</code></td>
  <td>e-theta field component, imaginary part</td>
  <td>Shape: <code>(n_el, n_az, n_elem)</code> or <code>(n_el, n_az, n_elem, n_freq)</code></td>
</tr>
<tr>
  <td><code>e_phi_re</code></td>
  <td>e-phi field component, real part</td>
  <td>Shape: <code>(n_el, n_az, n_elem)</code> or <code>(n_el, n_az, n_elem, n_freq)</code></td>
</tr>
<tr>
  <td><code>e_phi_im</code></td>
  <td>e-phi field component, imaginary part</td>
  <td>Shape: <code>(n_el, n_az, n_elem)</code> or <code>(n_el, n_az, n_elem, n_freq)</code></td>
</tr>
<tr>
  <td><code>azimuth_grid</code></td>
  <td>Azimuth angles in [rad], -pi to pi, sorted</td>
  <td>Shape: <code>(n_azimuth)</code></td>
</tr>
<tr>
  <td><code>elevation_grid</code></td>
  <td>Elevation angles in [rad], -pi/2 to pi/2, sorted</td>
  <td>Shape: <code>(n_elevation)</code></td>
</tr>
<tr>
  <td><code>element_pos</code></td>
  <td>Antenna element (x,y,z) positions, optional</td>
  <td>Shape: <code>(3, n_elements)</code></td>
</tr>
<tr>
  <td><code>coupling_re</code></td>
  <td>Coupling matrix, real part, optional</td>
  <td>Shape: <code>(n_elem, n_ports)</code> or <code>(n_elem, n_ports, n_freq)</code></td>
</tr>
<tr>
  <td><code>coupling_im</code></td>
  <td>Coupling matrix, imaginary part, optional</td>
  <td>Shape: <code>(n_elem, n_ports)</code> or <code>(n_elem, n_ports, n_freq)</code></td>
</tr>
<tr>
  <td><code>center_freq</code></td>
  <td>Center frequency in [Hz], optional</td>
  <td>Scalar or 1D array <code>(n_freq)</code></td>
</tr>
<tr>
  <td><code>name</code></td>
  <td>Name of the array antenna object, optional</td>
  <td>String</td>
</tr>
</table><br>
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>x_deg</code></b> (optional)<br> 
   The rotation angle around x-axis (bank angle) in [degrees]. Default: <code>0.0</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>y_deg</code></b> (optional)<br> 
   The rotation angle around y-axis (tilt angle) in [degrees]. Default: <code>0.0</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>z_deg</code></b> (optional)<br> 
   The rotation angle around z-axis (heading angle) in [degrees]. Default: <code>0.0</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>usage</code></b> (optional)<br> 
   The optional parameter 'usage' can limit the rotation procedure either to the pattern or polarization. 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>usage = 0</code></td>
  <td>Rotate both, pattern and polarization, adjusts sampling grid (default; multi-freq: no grid adjust)</td>
</tr>
<tr>
  <td><code>usage = 1</code></td>
  <td>Rotate only pattern, adjusts sampling grid (multi-freq: no grid adjust)</td>
</tr>
<tr>
  <td><code>usage = 2</code></td>
  <td>Rotate only polarization</td>
</tr>
<tr>
  <td><code>usage = 3</code></td>
  <td>Rotate both, but do not adjust the sampling grid</td>
</tr>
<tr>
  <td><code>usage = 4</code></td>
  <td>Rotate only pattern, do not adjust the sampling grid</td>
</tr>
</table><br>
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>element</code></b> (optional)<br> 
   The element indices for which the pattern should be transformed. Optional parameter. Values must 
   be between 0 and n_elements-1 (0-based). If this parameter is not provided (or an empty array is 
   passed), all elements will be rotated by the same angles. Shape: <code>(n_elements)</code> or empty <code>()</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>arrayant_out</code></b><br> 
   Dictionary containing the arrayant data with the rotated patterns. Output format matches the 
   input format (3D for single-frequency, 4D for multi-frequency). 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="generate_speaker"></a>
<b>generate_speaker</b> - Generates a parametric loudspeaker directivity model
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>This function generates frequency-dependent loudspeaker radiation patterns by combining a driver 
directivity model with an enclosure radiation modifier and a Butterworth-style bandpass frequency 
response. Returns a multi-frequency arrayant dictionary where the pattern fields are 4D arrays 
(the 4th dimension is frequency) and <code>center_freq</code> is a 1D array of frequency samples in Hz. 
 
Multi-driver speakers (e.g. two-way systems) are modelled by generating each driver separately and 
combining them via <code>arrayant_concat_multi</code>. Crossover behavior emerges naturally from overlapping 
bandpass responses.<br><br> 
 
Three driver types are supported: 
<ul><li style="margin-bottom: 0.4em;"><b><code>piston</code></b>: Circular piston in a baffle using the classical Bessel J1 formula. Transitions from 
   omnidirectional at low ka to progressively narrower beaming at high ka. 
</li><li style="margin-bottom: 0.4em;"><b><code>horn</code></b>: Separable cosine-power directivity with frequency-dependent pattern control. Below the 
   horn control frequency, the pattern blends toward omnidirectional. 
</li><li style="margin-bottom: 0.4em;"><b><code>omni</code></b>: Frequency-independent omnidirectional pattern (suitable for subwoofers).<br><br> 
</li></ul>
 
Four enclosure radiation types modify the base driver pattern: 
<ul><li style="margin-bottom: 0.4em;"><b><code>monopole</code></b>: No modification (4π radiation). Appropriate for subwoofers in free space. 
</li><li style="margin-bottom: 0.4em;"><b><code>hemisphere</code></b>: Sealed box on a finite baffle with frequency-dependent baffle step transition. 
</li><li style="margin-bottom: 0.4em;"><b><code>dipole</code></b>: Open baffle / planar speaker with figure-8 pattern. 
</li><li style="margin-bottom: 0.4em;"><b><code>cardioid</code></b>: Monopole + dipole combination with null at the rear.<br><br> 
</li></ul>
 
The frequency response follows a Butterworth-style bandpass filter. If no frequency vector is 
provided, third-octave band center frequencies are auto-generated covering the range from one band 
below the lower cutoff to one band above the upper cutoff, clipped to 20–20000 Hz.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
from quadriga_lib import arrayant

# Default piston driver (4-inch, 80 Hz – 12 kHz)
speaker = arrayant.generate_speaker()

# Horn tweeter with custom coverage
speaker = arrayant.generate_speaker(
    driver_type='horn',
    radius=0.025,
    lower_cutoff=1500.0,
    upper_cutoff=20000.0,
    radiation_type='hemisphere',
    hor_coverage=90.0,
    ver_coverage=60.0
)

# Omnidirectional subwoofer with steep rolloff
speaker = arrayant.generate_speaker(
    driver_type='omni',
    radius=0.165,
    lower_cutoff=30.0,
    upper_cutoff=300.0,
    lower_rolloff_slope=24.0,
    upper_rolloff_slope=24.0,
    sensitivity=90.0,
    radiation_type='monopole'
)

# Piston driver at specific frequencies
import numpy as np
speaker = arrayant.generate_speaker(
    frequencies=np.array([100.0, 500.0, 1000.0, 5000.0, 10000.0]),
    angular_resolution=5.0
)
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>driver_type</code></b><br> 
   Driver directivity model, string. Supported values: <code>"piston"</code> (cone/dome via Bessel function), 
   <code>"horn"</code> (cosine-power with frequency-dependent pattern control), <code>"omni"</code> (omnidirectional 
   subwoofer). Default: <code>"piston"</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>radius</code></b><br> 
   Effective radiating radius in meters, scalar. For <code>"piston"</code>: cone or dome radius. For <code>"horn"</code>: 
   mouth radius (pattern control frequency auto-derived if not specified). Default: <code>0.05</code> (~4-inch driver) 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>lower_cutoff</code></b><br> 
   Lower −3 dB frequency of the bandpass response in Hz, scalar. Default: <code>80.0</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>upper_cutoff</code></b><br> 
   Upper −3 dB frequency of the bandpass response in Hz, scalar. Default: <code>12000.0</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>lower_rolloff_slope</code></b><br> 
   Low-frequency rolloff slope in dB per octave, scalar. Butterworth order = slope / 6 
   (e.g. 12 dB/oct = 2nd order). Default: <code>12.0</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>upper_rolloff_slope</code></b><br> 
   High-frequency rolloff slope in dB per octave, scalar. Default: <code>12.0</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>sensitivity</code></b><br> 
   On-axis sensitivity in dB SPL at 1W/1m, scalar. Scales amplitude linearly relative to 85 dB 
   reference. Default: <code>85.0</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>radiation_type</code></b><br> 
   Enclosure radiation modifier, string. Supported values: <code>"monopole"</code>, <code>"hemisphere"</code>, 
   <code>"dipole"</code>, <code>"cardioid"</code>. Default: <code>"hemisphere"</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>hor_coverage</code></b><br> 
   Horizontal coverage angle in degrees, scalar. Horn driver only. 0 = auto (90°). Default: <code>0.0</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>ver_coverage</code></b><br> 
   Vertical coverage angle in degrees, scalar. Horn driver only. 0 = auto (60°). Default: <code>0.0</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>horn_control_freq</code></b><br> 
   Horn pattern control frequency in Hz, scalar. 0 = auto-derived from mouth radius. Default: <code>0.0</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>baffle_width</code></b><br> 
   Enclosure baffle width in meters, scalar. Piston driver only (used for baffle step model). 
   Default: <code>0.15</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>baffle_height</code></b><br> 
   Enclosure baffle height in meters, scalar. Piston driver only. Default: <code>0.25</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>frequencies</code></b><br> 
   Frequency sample points in Hz, 1D numpy array. If empty, third-octave bands are auto-generated. 
   Default: empty (auto) 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>angular_resolution</code></b><br> 
   Angular grid resolution in degrees, scalar. Used to generate azimuth and elevation grids. 
   Default: <code>5.0</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Argument:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>speaker</code></b><br> 
   Dictionary containing the multi-frequency arrayant data with the following keys: 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>e_theta_re</code></td>
  <td>e-theta field component, real part</td>
  <td>Shape: <code>(n_elevation, n_azimuth, n_elements, n_freq)</code></td>
</tr>
<tr>
  <td><code>e_theta_im</code></td>
  <td>e-theta field component, imaginary part</td>
  <td>Shape: <code>(n_elevation, n_azimuth, n_elements, n_freq)</code></td>
</tr>
<tr>
  <td><code>e_phi_re</code></td>
  <td>e-phi field component, real part</td>
  <td>Shape: <code>(n_elevation, n_azimuth, n_elements, n_freq)</code></td>
</tr>
<tr>
  <td><code>e_phi_im</code></td>
  <td>e-phi field component, imaginary part</td>
  <td>Shape: <code>(n_elevation, n_azimuth, n_elements, n_freq)</code></td>
</tr>
<tr>
  <td><code>azimuth_grid</code></td>
  <td>Azimuth angles in [rad], −π to π, sorted</td>
  <td>Shape: <code>(n_azimuth)</code></td>
</tr>
<tr>
  <td><code>elevation_grid</code></td>
  <td>Elevation angles in [rad], −π/2 to π/2</td>
  <td>Shape: <code>(n_elevation)</code></td>
</tr>
<tr>
  <td><code>element_pos</code></td>
  <td>Antenna element (x,y,z) positions</td>
  <td>Shape: <code>(3, n_elements)</code></td>
</tr>
<tr>
  <td><code>coupling_re</code></td>
  <td>Coupling matrix, real part</td>
  <td>Shape: <code>(n_elements, n_ports)</code> or <code>(n_elements, n_ports, n_freq)</code></td>
</tr>
<tr>
  <td><code>coupling_im</code></td>
  <td>Coupling matrix, imaginary part</td>
  <td>Shape: <code>(n_elements, n_ports)</code> or <code>(n_elements, n_ports, n_freq)</code></td>
</tr>
<tr>
  <td><code>center_freq</code></td>
  <td>Frequency samples in Hz</td>
  <td>Shape: <code>(n_freq)</code> - 1D array</td>
</tr>
<tr>
  <td><code>name</code></td>
  <td>Name of the array antenna object</td>
  <td>String</td>
</tr>
</table><br>
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="get_channels_planar"></a>
<b>get_channels_planar</b> - Calculate channel coefficients for planar waves
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>In this function, the wireless propagation channel between a transmitter and a receiver is calculated, 
based on a single transmit and receive position. Additionally, interaction points with the environment, 
which are derived from either Ray Tracing or Geometric Stochastic Models such as QuaDRiGa, are 
considered. The calculation is performed under the assumption of planar wave propagation. For accurate 
execution of this process, several pieces of input data are required:<br><br> 
 
<ul><li style="margin-bottom: 0.4em;">The 3D Cartesian (local) coordinates of both the transmitter and the receiver. 
</li><li style="margin-bottom: 0.4em;">The azimuth/elevation departure and arrval angles. 
</li><li style="margin-bottom: 0.4em;">The polarization transfer matrix for each propagation path. 
</li><li style="margin-bottom: 0.4em;">Antenna models for both the transmitter and the receiver. 
</li><li style="margin-bottom: 0.4em;">The orientations of the antennas. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
from quadriga_lib import arrayant

coeff_re, coeff_im, delays, rx_Doppler = arrayant.get_channels_planar( ant_tx, ant_rx, 
    aod, eod, aoa, eoa, path_gain, path_length, M, tx_pos, tx_orientation, rx_pos, rx_orientation, 
    center_freq, use_absolute_delays, add_fake_los_path );
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>ant_tx</code></b> (required)<br> 
   Dictionary containing the transmit (TX) arrayant data with the following keys: 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>e_theta_re</code></td>
  <td>e-theta field component, real part</td>
  <td>Shape: <code>(n_elevation_tx, n_azimuth_tx, n_elements_tx)</code></td>
</tr>
<tr>
  <td><code>e_theta_im</code></td>
  <td>e-theta field component, imaginary part</td>
  <td>Shape: <code>(n_elevation_tx, n_azimuth_tx, n_elements_tx)</code></td>
</tr>
<tr>
  <td><code>e_phi_re</code></td>
  <td>e-phi field component, real part</td>
  <td>Shape: <code>(n_elevation_tx, n_azimuth_tx, n_elements_tx)</code></td>
</tr>
<tr>
  <td><code>e_phi_im</code></td>
  <td>e-phi field component, imaginary part</td>
  <td>Shape: <code>(n_elevation_tx, n_azimuth_tx, n_elements_tx)</code></td>
</tr>
<tr>
  <td><code>azimuth_grid</code></td>
  <td>Azimuth angles in [rad], -pi to pi, sorted</td>
  <td>Shape: <code>(n_azimuth_tx)</code></td>
</tr>
<tr>
  <td><code>elevation_grid</code></td>
  <td>Elevation angles in [rad], -pi/2 to pi/2, sorted</td>
  <td>Shape: <code>(n_elevation_tx)</code></td>
</tr>
<tr>
  <td><code>element_pos</code></td>
  <td>Antenna element (x,y,z) positions, optional</td>
  <td>Shape: <code>(3, n_elements_tx)</code></td>
</tr>
<tr>
  <td><code>coupling_re</code></td>
  <td>Coupling matrix, real part, optional</td>
  <td>Shape: <code>(n_elements_tx, n_ports_tx)</code></td>
</tr>
<tr>
  <td><code>coupling_im</code></td>
  <td>Coupling matrix, imaginary part, optional</td>
  <td>Shape: <code>(n_elements_tx, n_ports_tx)</code></td>
</tr>
</table><br>
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>ant_rx</code></b> (required)<br> 
   Dictionary containing the receive (RX) arrayant data with the following keys: 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>e_theta_re</code></td>
  <td>e-theta field component, real part</td>
  <td>Shape: <code>(n_elevation_rx, n_azimuth_rx, n_elements_rx)</code></td>
</tr>
<tr>
  <td><code>e_theta_im</code></td>
  <td>e-theta field component, imaginary part</td>
  <td>Shape: <code>(n_elevation_rx, n_azimuth_rx, n_elements_rx)</code></td>
</tr>
<tr>
  <td><code>e_phi_re</code></td>
  <td>e-phi field component, real part</td>
  <td>Shape: <code>(n_elevation_rx, n_azimuth_rx, n_elements_rx)</code></td>
</tr>
<tr>
  <td><code>e_phi_im</code></td>
  <td>e-phi field component, imaginary part</td>
  <td>Shape: <code>(n_elevation_rx, n_azimuth_rx, n_elements_rx)</code></td>
</tr>
<tr>
  <td><code>azimuth_grid</code></td>
  <td>Azimuth angles in [rad], -pi to pi, sorted</td>
  <td>Shape: <code>(n_azimuth_rx)</code></td>
</tr>
<tr>
  <td><code>elevation_grid</code></td>
  <td>Elevation angles in [rad], -pi/2 to pi/2, sorted</td>
  <td>Shape: <code>(n_elevation_rx)</code></td>
</tr>
<tr>
  <td><code>element_pos</code></td>
  <td>Antenna element (x,y,z) positions, optional</td>
  <td>Shape: <code>(3, n_elements_rx)</code></td>
</tr>
<tr>
  <td><code>coupling_re</code></td>
  <td>Coupling matrix, real part, optional</td>
  <td>Shape: <code>(n_elements_rx, n_ports_rx)</code></td>
</tr>
<tr>
  <td><code>coupling_im</code></td>
  <td>Coupling matrix, imaginary part, optional</td>
  <td>Shape: <code>(n_elements_rx, n_ports_rx)</code></td>
</tr>
</table><br>
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>aod</code></b> (required)<br> 
   Departure azimuth angles in [rad], Shape: <code>( n_path )</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>eod</code></b> (required)<br> 
   Departure elevation angles in [rad], Shape: <code>( n_path )</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>aoa</code></b> (required)<br> 
   Arrival azimuth angles in [rad], Shape: <code>( n_path )</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>eoa</code></b> (required)<br> 
   Arrival elevation angles in [rad], Shape: <code>( n_path )</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>path_gain</code></b> (required)<br> 
   Path gain (linear scale), Shape: <code>( n_path )</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>path_length</code></b> (required)<br> 
   Total path length in meters, Shape: <code>( n_path )</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>M</code></b> (required)<br> 
   Polarization transfer matrix, interleaved complex values (ReVV, ImVV, ReVH, ImVH, ReHV, ImHV, ReHH, ImHH), 
   Shape: <code>( 8, n_path )</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>tx_pos</code></b> (required)<br> 
   Transmitter position in 3D Cartesian coordinates; Shape: <code>(3)</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>tx_orientation</code></b> (required)<br> 
   3-element vector describing the orientation of the transmit antenna in Euler angles (bank, tilt, heading), 
   Shape: <code>(3,1)</code> or <code>(1,3)</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>rx_pos</code></b> (required)<br> 
   Receiver position in 3D Cartesian coordinates, Shape: <code>(3)</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>rx_orientation</code></b> (required)]<br> 
   3-element vector describing the orientation of the receive antenna in Euler angles, 
   Shape: <code>(3)</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>center_freq</code></b> (optional)<br> 
   Center frequency in [Hz]; optional; If the value is not provided or set to 0, phase calculation 
   in coefficients is disabled, i.e. that path length has not influence on the results. This can be 
   used to calculate the antenna response for a specific angle and polarization. Scalar value 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>use_absolute_delays</code></b> (optional)<br> 
   If true, the LOS delay is included for all paths; Default is <code>false</code>, i.e. delays are normalized 
   to the LOS delay. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>add_fake_los_path</code></b> (optional)<br> 
   If true, adds a zero-power LOS path as the first path in case where no LOS path was present. 
   Default: <code>false</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Derived inputs:</i></b><br><table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>n_azimuth_tx</code></td>
  <td>Number of azimuth angles in the TX antenna pattern</td>
</tr>
<tr>
  <td><code>n_elevation_tx</code></td>
  <td>Number of elevation angles in the TX antenna pattern</td>
</tr>
<tr>
  <td><code>n_elements_tx</code></td>
  <td>Number of physical antenna elements in the TX array antenna</td>
</tr>
<tr>
  <td><code>n_ports_tx</code></td>
  <td>Number of ports (after coupling) in the TX array antenna</td>
</tr>
<tr>
  <td><code>n_azimuth_rx</code></td>
  <td>Number of azimuth angles in the RX antenna pattern</td>
</tr>
<tr>
  <td><code>n_elevation_rx</code></td>
  <td>Number of elevation angles in the RX antenna pattern</td>
</tr>
<tr>
  <td><code>n_elements_rx</code></td>
  <td>Number of physical antenna elements in the RX array antenna</td>
</tr>
<tr>
  <td><code>n_ports_rx</code></td>
  <td>Number of ports (after coupling) in the RX array antenna</td>
</tr>
<tr>
  <td><code>n_path</code></td>
  <td>Number of propagation paths</td>
</tr>
</table><br>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>coeff_re</code></b><br> 
   Channel coefficients, real part, Shape: <code>( n_ports_tx, n_ports_rx, n_path )</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>coeff_im</code></b><br> 
   Channel coefficients, imaginary part, Shape: <code>( n_ports_tx, n_ports_rx, n_path )</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>delays</code></b><br> 
   Propagation delay in seconds, Shape: <code>( n_ports_tx, n_ports_rx, n_path )</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>rx_Doppler</code></b><br> 
   Doppler weights for moving RX, Shape: <code>( 1, n_path )</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Caveat:</i></b><br><ul><li style="margin-bottom: 0.4em;">Input data is directly accessed from Python memory, without copying if it is provided in 
   <b>double</b> precision and is in F-contiguous (column-major) order 
</li><li style="margin-bottom: 0.4em;">Other formats (e.g. single precision inputs or C-contiguous (row-major) order) will be converted 
   to double automatically, causing additional computation steps. 
</li><li style="margin-bottom: 0.4em;">To improve performance of repeated computations (e.g. in loops), consider preparing the data 
   accordingly to avoid unecessary computations. 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="get_channels_spherical"></a>
<b>get_channels_spherical</b> - Calculate channel coefficients from path data and antenna patterns
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>In this function, the wireless propagation channel between a transmitter and a receiver is calculated, 
based on a single transmit and receive position. Additionally, interaction points with the environment, 
which are derived from either Ray Tracing or Geometric Stochastic Models such as QuaDRiGa, are 
considered. The calculation is performed under the assumption of spherical wave propagation. For accurate 
execution of this process, several pieces of input data are required:<br><br> 
 
<ul><li style="margin-bottom: 0.4em;">The 3D Cartesian (local) coordinates of both the transmitter and the receiver. 
</li><li style="margin-bottom: 0.4em;">The specific interaction positions of the propagation paths within the environment. 
</li><li style="margin-bottom: 0.4em;">The polarization transfer matrix for each propagation path. 
</li><li style="margin-bottom: 0.4em;">Antenna models for both the transmitter and the receiver. 
</li><li style="margin-bottom: 0.4em;">The orientations of the antennas. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
from quadriga_lib import arrayant

# Return only coefficients and delays
coeff_re, coeff_im, delays = arrayant.get_channels_spherical( ant_tx, ant_rx, 
    fbs_pos, lbs_pos, path_gain, path_length, M, tx_pos, tx_orientation, rx_pos, rx_orientation, 
    center_freq, use_absolute_delays, add_fake_los_path );

# Return additional departure and arrival angles
coeff_re, coeff_im, delays, aod, eod, aoa, eoa = arrayant.get_channels_spherical( ant_tx, ant_rx, 
    fbs_pos, lbs_pos, path_gain, path_length, M, tx_pos, tx_orientation, rx_pos, rx_orientation, 
    center_freq, use_absolute_delays, add_fake_los_path, angles=1 );
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>ant_tx</code></b> (required)<br> 
   Dictionary containing the transmit (TX) arrayant data with the following keys: 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>e_theta_re</code></td>
  <td>e-theta field component, real part</td>
  <td>Shape: <code>(n_elevation_tx, n_azimuth_tx, n_elements_tx)</code></td>
</tr>
<tr>
  <td><code>e_theta_im</code></td>
  <td>e-theta field component, imaginary part</td>
  <td>Shape: <code>(n_elevation_tx, n_azimuth_tx, n_elements_tx)</code></td>
</tr>
<tr>
  <td><code>e_phi_re</code></td>
  <td>e-phi field component, real part</td>
  <td>Shape: <code>(n_elevation_tx, n_azimuth_tx, n_elements_tx)</code></td>
</tr>
<tr>
  <td><code>e_phi_im</code></td>
  <td>e-phi field component, imaginary part</td>
  <td>Shape: <code>(n_elevation_tx, n_azimuth_tx, n_elements_tx)</code></td>
</tr>
<tr>
  <td><code>azimuth_grid</code></td>
  <td>Azimuth angles in [rad], -pi to pi, sorted</td>
  <td>Shape: <code>(n_azimuth_tx)</code></td>
</tr>
<tr>
  <td><code>elevation_grid</code></td>
  <td>Elevation angles in [rad], -pi/2 to pi/2, sorted</td>
  <td>Shape: <code>(n_elevation_tx)</code></td>
</tr>
<tr>
  <td><code>element_pos</code></td>
  <td>Antenna element (x,y,z) positions, optional</td>
  <td>Shape: <code>(3, n_elements_tx)</code></td>
</tr>
<tr>
  <td><code>coupling_re</code></td>
  <td>Coupling matrix, real part, optional</td>
  <td>Shape: <code>(n_elements_tx, n_ports_tx)</code></td>
</tr>
<tr>
  <td><code>coupling_im</code></td>
  <td>Coupling matrix, imaginary part, optional</td>
  <td>Shape: <code>(n_elements_tx, n_ports_tx)</code></td>
</tr>
</table><br>
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>ant_rx</code></b> (required)<br> 
   Dictionary containing the receive (RX) arrayant data with the following keys: 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>e_theta_re</code></td>
  <td>e-theta field component, real part</td>
  <td>Shape: <code>(n_elevation_rx, n_azimuth_rx, n_elements_rx)</code></td>
</tr>
<tr>
  <td><code>e_theta_im</code></td>
  <td>e-theta field component, imaginary part</td>
  <td>Shape: <code>(n_elevation_rx, n_azimuth_rx, n_elements_rx)</code></td>
</tr>
<tr>
  <td><code>e_phi_re</code></td>
  <td>e-phi field component, real part</td>
  <td>Shape: <code>(n_elevation_rx, n_azimuth_rx, n_elements_rx)</code></td>
</tr>
<tr>
  <td><code>e_phi_im</code></td>
  <td>e-phi field component, imaginary part</td>
  <td>Shape: <code>(n_elevation_rx, n_azimuth_rx, n_elements_rx)</code></td>
</tr>
<tr>
  <td><code>azimuth_grid</code></td>
  <td>Azimuth angles in [rad], -pi to pi, sorted</td>
  <td>Shape: <code>(n_azimuth_rx)</code></td>
</tr>
<tr>
  <td><code>elevation_grid</code></td>
  <td>Elevation angles in [rad], -pi/2 to pi/2, sorted</td>
  <td>Shape: <code>(n_elevation_rx)</code></td>
</tr>
<tr>
  <td><code>element_pos</code></td>
  <td>Antenna element (x,y,z) positions, optional</td>
  <td>Shape: <code>(3, n_elements_rx)</code></td>
</tr>
<tr>
  <td><code>coupling_re</code></td>
  <td>Coupling matrix, real part, optional</td>
  <td>Shape: <code>(n_elements_rx, n_ports_rx)</code></td>
</tr>
<tr>
  <td><code>coupling_im</code></td>
  <td>Coupling matrix, imaginary part, optional</td>
  <td>Shape: <code>(n_elements_rx, n_ports_rx)</code></td>
</tr>
</table><br>
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>fbs_pos</code></b> (required)<br> 
   First interaction point of the rays and the environment, Shape: <code>( 3, n_path )</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>lbs_pos</code></b> (required)<br> 
   Last interaction point of the rays and the environment; For single-bounce models, this must be 
   identical to <code>fbs_pos</code>, Shape: <code>( 3, n_path )</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>path_gain</code></b> (required)<br> 
   Path gain (linear scale), Shape: <code>( n_path )</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>path_length</code></b> (required)<br> 
   Total path length in meters, Shape: <code>( n_path )</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>M</code></b> (required)<br> 
   Polarization transfer matrix, interleaved complex values (ReVV, ImVV, ReVH, ImVH, ReHV, ImHV, ReHH, ImHH), 
   Shape: <code>( 8, n_path )</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>tx_pos</code></b> (required)<br> 
   Transmitter position in 3D Cartesian coordinates; Shape: <code>(3)</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>tx_orientation</code></b> (required)<br> 
   3-element vector describing the orientation of the transmit antenna in Euler angles (bank, tilt, heading), 
   Shape: <code>(3,1)</code> or <code>(1,3)</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>rx_pos</code></b> (required)<br> 
   Receiver position in 3D Cartesian coordinates, Shape: <code>(3)</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>rx_orientation</code></b> (required)]<br> 
   3-element vector describing the orientation of the receive antenna in Euler angles, 
   Shape: <code>(3)</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>center_freq</code></b> (optional)<br> 
   Center frequency in [Hz]; optional; If the value is not provided or set to 0, phase calculation 
   in coefficients is disabled, i.e. that path length has not influence on the results. This can be 
   used to calculate the antenna response for a specific angle and polarization. Scalar value 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>use_absolute_delays</code></b> (optional)<br> 
   If true, the LOS delay is included for all paths; Default is <code>false</code>, i.e. delays are normalized 
   to the LOS delay. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>add_fake_los_path</code></b> (optional)<br> 
   If true, adds a zero-power LOS path as the first path in case where no LOS path was present. 
   Default: <code>false</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>angles</code></b> (optional flag)<br> 
   Switch to return the angles in antenna-local coordinates. Default: 0, false 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Derived inputs:</i></b><br><table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>n_azimuth_tx</code></td>
  <td>Number of azimuth angles in the TX antenna pattern</td>
</tr>
<tr>
  <td><code>n_elevation_tx</code></td>
  <td>Number of elevation angles in the TX antenna pattern</td>
</tr>
<tr>
  <td><code>n_elements_tx</code></td>
  <td>Number of physical antenna elements in the TX array antenna</td>
</tr>
<tr>
  <td><code>n_ports_tx</code></td>
  <td>Number of ports (after coupling) in the TX array antenna</td>
</tr>
<tr>
  <td><code>n_azimuth_rx</code></td>
  <td>Number of azimuth angles in the RX antenna pattern</td>
</tr>
<tr>
  <td><code>n_elevation_rx</code></td>
  <td>Number of elevation angles in the RX antenna pattern</td>
</tr>
<tr>
  <td><code>n_elements_rx</code></td>
  <td>Number of physical antenna elements in the RX array antenna</td>
</tr>
<tr>
  <td><code>n_ports_rx</code></td>
  <td>Number of ports (after coupling) in the RX array antenna</td>
</tr>
<tr>
  <td><code>n_path</code></td>
  <td>Number of propagation paths</td>
</tr>
</table><br>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>coeff_re</code></b><br> 
   Channel coefficients, real part, Shape: <code>( n_ports_rx, n_ports_tx, n_path )</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>coeff_im</code></b><br> 
   Channel coefficients, imaginary part, Shape: <code>( n_ports_rx, n_ports_tx, n_path )</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>delays</code></b><br> 
   Propagation delay in seconds, Shape: <code>( n_ports_rx, n_ports_tx, n_path )</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>aod</code></b> (optional)<br> 
   Azimuth of Departure angles in [rad], Shape: <code>( n_ports_rx, n_ports_tx, n_path )</code>, 
   Only returned when <code>angles</code> flag is set to 1. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>eod</code></b> (optional)<br> 
   Elevation of Departure angles in [rad], Shape: <code>( n_ports_rx, n_ports_tx, n_path )</code>, 
   Only returned when <code>angles</code> flag is set to 1. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>aoa</code></b> (optional)<br> 
   Azimuth of Arrival angles in [rad], Shape: <code>( n_ports_rx, n_ports_tx, n_path )</code>, 
   Only returned when <code>angles</code> flag is set to 1. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>eoa</code></b> (optional)<br> 
   Elevation of Arrival angles in [rad], Shape: <code>( n_ports_rx, n_ports_tx, n_path )</code>, 
   Only returned when <code>angles</code> flag is set to 1. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Caveat:</i></b><br><ul><li style="margin-bottom: 0.4em;">Input data is directly accessed from Python memory, without copying if it is provided in 
   <b>double</b> precision and is in F-contiguous (column-major) order 
</li><li style="margin-bottom: 0.4em;">Other formats (e.g. single precision inputs or C-contiguous (row-major) order) will be converted 
   to double automatically, causing additional computation steps. 
</li><li style="margin-bottom: 0.4em;">To improve performance of repeated computations (e.g. in loops), consider preparing the data 
   accordingly to avoid unecessary computations. 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div>
<hr class="greyline">
<hr class="greyline">
<br>
<br>
<a name="eab50272"></a>
<font size=+1><b>Channel functions</b></font>
<br>
<br>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="baseband_freq_response"></a>
<b>baseband_freq_response</b> - Transforms the channel into frequency domain and returns the frequency response
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
from quadriga_lib import channel
hmat = channel.baseband_freq_response( coeff, delay, bandwidth, carriers, pilot_grid, snap );
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>coeff</code></b><br> 
   Channel coefficients, complex-valued, List of length <code>n_snap</code>,  
   Each list item is an munpy.ndarray of Shape <code>( n_rx, n_tx, n_path )</code> where <code>n_path</code> can be different  
   for each snapshot. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>delay</code></b><br> 
   Propagation delay in seconds, List of length <code>n_snap</code>,  
   Each list item is an munpy.ndarray of Shape <code>( n_rx, n_tx, n_path )</code> or <code>( 1, 1, n_path )</code> where  
   <code>n_path</code> can be different for each snapshot. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>bandwidth</code></b><br> 
   The baseband bandwidth in [Hz], scalar 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>carriers</code></b> (optional)<br> 
   Number of carriers, equally spaced across the bandwidth. The first entry of the generated spectrum 
   is equal to the center frequency f0. The spectrum is generated from f0 to f0+bandwidth. This 
   argument is only evaluated if <code>pilot_grid</code> is not provided. Default value = 128 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>pilot_grid</code></b> (optional)<br> 
   Sub-carrier positions relative to the bandwidth. The carrier positions are given relative to the 
   bandwidth where '0' is the begin of the spectrum (i.e., the center frequency f0) and '1' is 
   equal to f0+bandwidth. To obtain the channel frequency response centered around f0, the 
   input variable 'pilot_grid' must be set to '(-N/2:N/2)/N', where N is the number of sub- 
   carriers. Vector of length: <code>( n_carriers )</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>snap</code></b> (optional)<br> 
   Snapshot indices for which the frequency response should be generated (1-based index). If this 
   variable is not given, all snapshots are processed. Length: <code>( n_out )</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Argument:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>hmat</code></b><br> 
   Freq. domain channel matrices (H), complex-valued, Shape <code>( n_rx, n_tx, n_carriers, n_out )</code> 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="channel_export_obj_file"></a>
<b>channel_export_obj_file</b> - Export path data to a Wavefront OBJ file for visualization in Blender
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>This function exports path data to a Wavefront OBJ file, which can be used for visualization in 3D 
software such as Blender. It supports various colormaps for color-coding the paths based on their 
gain values. In addition, the function allows you to control the maximum number of paths displayed, 
set gain thresholds for color-coding and selection.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
from quadriga_lib import channel

channel.channel_export_obj_file( fn, max_no_paths, gain_max, gain_min, colormap, radius_max,
    radius_min, n_edges, rx_position, tx_position, no_interact, interact_coord, center_freq,
    coeff, i_snap )
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>fn</code></b><br> 
   Filename of the OBJ file, string, required 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>max_no_paths</code></b> (optional)<br> 
   Maximum number of paths to be shown, optional, default: 0 = export all above <code>gain_min</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>gain_max</code></b> (optional)<br> 
   Maximum path gain in dB (only for color-coding), optional, default = -60.0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>gain_min</code></b> (optional)<br> 
   Minimum path gain in dB (for color-coding and path selection), optional, default = -140.0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>colormap</code></b> (optional)<br> 
   Colormap for the visualization, string, supported are 'jet', 'parula', 'winter', 'hot', 'turbo', 
   'copper', 'spring', 'cool', 'gray', 'autumn', 'summer', optional, default = 'jet' 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>radius_max</code></b> (optional)<br> 
   Maximum tube radius in meters, optional, default = 0.05 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>radius_min</code></b> (optional)<br> 
   Minimum tube radius in meters, optional, default = 0.01 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>n_edges</code></b> (optional)<br> 
   Number of vertices in the circle building the tube, must be >= 3, optional, default = 5 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>rx_position</code></b><br> 
   Receiver positions, required, size <code>[3, n_snap]</code> or <code>[3, 1]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>tx_position</code></b><br> 
   Transmitter positions, required, size <code>[3, n_snap]</code> or <code>[3, 1]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>no_interact</code></b><br> 
   Number interaction points of paths with the environment, required, uint32, Size <code>[n_path, n_snap]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>interact_coord</code></b><br> 
   Interaction coordinates, required, Size <code>[3, max(sum(no_interact)), n_snap]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>center_freq</code></b><br> 
   Center frequency in [Hz], required, Size <code>[n_snap, 1]</code> or scalar 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>coeff</code></b><br> 
   Channel coefficients, complex valued, required only if <code>path_polarization</code> is not given, 
   Size <code>[n_rx, n_tx, n_path, n_snap]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>i_snap</code></b><br> (optional) 
   Snapshot indices, optional, 0-based, range [0 ... n_snap - 1] 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="get_ieee_indoor"></a>
<b>get_ieee_indoor</b> - Generate indoor MIMO channel realizations for IEEE TGn/TGac/TGax/TGah models
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Generates one or multiple indoor channel realizations based on IEEE TGn/TGac/TGax/TGah model definitions. 
</li><li style="margin-bottom: 0.4em;">2D model: no elevation angles are used; azimuth angles and planar motion are considered. 
</li><li style="margin-bottom: 0.4em;">For 3D antenna models (default models from arrayant <a href="#generate">generate</a>), only the azimuth cut at <code>elevation_grid = 0</code> is used 
</li><li style="margin-bottom: 0.4em;">Supports channel model types <code>A, B, C, D, E, F</code> (as defined by TGn) via <code>ChannelType</code>. 
</li><li style="margin-bottom: 0.4em;">Can generate MU-MIMO channels (<code>n_users &gt; 1</code>) with per-user distances/floors and optional angle 
   offsets according to TGac. 
</li><li style="margin-bottom: 0.4em;">Optional time evolution via <code>observation_time</code>, <code>update_rate</code>, and mobility parameters. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
from quadriga_lib import channel

chan = channel.get_ieee_indoor(ap_array, sta_array, ChannelType, CarrierFreq_Hz, 
   tap_spacing_s, n_users, observation_time, update_rate, speed_station_kmh, speed_env_kmh, 
   Dist_m, n_floors, uplink, offset_angles, n_subpath, Doppler_effect, seed,
   KF_linear, XPR_NLOS_linear, SF_std_dB_LOS, SF_std_dB_NLOS, dBP_m );
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>ap_array:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>ap_array</code></b><br> 
   Dictionary containing the access point array antenna with <code>n_tx</code> elements (= ports after element coupling) 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>e_theta_re</code></td>
  <td>e-theta field component, real part</td>
  <td>Shape: <code>(n_elevation_ap, n_azimuth_ap, n_elements_ap)</code></td>
</tr>
<tr>
  <td><code>e_theta_im</code></td>
  <td>e-theta field component, imaginary part</td>
  <td>Shape: <code>(n_elevation_ap, n_azimuth_ap, n_elements_ap)</code></td>
</tr>
<tr>
  <td><code>e_phi_re</code></td>
  <td>e-phi field component, real part</td>
  <td>Shape: <code>(n_elevation_ap, n_azimuth_ap, n_elements_ap)</code></td>
</tr>
<tr>
  <td><code>e_phi_im</code></td>
  <td>e-phi field component, imaginary part</td>
  <td>Shape: <code>(n_elevation_ap, n_azimuth_ap, n_elements_ap)</code></td>
</tr>
<tr>
  <td><code>azimuth_grid</code></td>
  <td>Azimuth angles in [rad], -pi to pi, sorted</td>
  <td>Shape: <code>(n_azimuth_ap)</code></td>
</tr>
<tr>
  <td><code>elevation_grid</code></td>
  <td>Elevation angles in [rad], -pi/2 to pi/2, sorted</td>
  <td>Shape: <code>(n_elevation_ap)</code></td>
</tr>
<tr>
  <td><code>element_pos</code></td>
  <td>Antenna element (x,y,z) positions, optional</td>
  <td>Shape: <code>(3, n_elements_ap)</code></td>
</tr>
<tr>
  <td><code>coupling_re</code></td>
  <td>Coupling matrix, real part, optional</td>
  <td>Shape: <code>(n_elements_ap, n_ports_ap)</code></td>
</tr>
<tr>
  <td><code>coupling_im</code></td>
  <td>Coupling matrix, imaginary part, optional</td>
  <td>Shape: <code>(n_elements_ap, n_ports_ap)</code></td>
</tr>
</table><br>
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>sta_array</code></b><br> 
   Dictionary containing the mobile station array antenna with <code>n_rx</code> elements (= ports after element coupling) 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>e_theta_re</code></td>
  <td>e-theta field component, real part</td>
  <td>Shape: <code>(n_elevation_sta, n_azimuth_sta, n_elements_sta)</code></td>
</tr>
<tr>
  <td><code>e_theta_im</code></td>
  <td>e-theta field component, imaginary part</td>
  <td>Shape: <code>(n_elevation_sta, n_azimuth_sta, n_elements_sta)</code></td>
</tr>
<tr>
  <td><code>e_phi_re</code></td>
  <td>e-phi field component, real part</td>
  <td>Shape: <code>(n_elevation_sta, n_azimuth_sta, n_elements_sta)</code></td>
</tr>
<tr>
  <td><code>e_phi_im</code></td>
  <td>e-phi field component, imaginary part</td>
  <td>Shape: <code>(n_elevation_sta, n_azimuth_sta, n_elements_sta)</code></td>
</tr>
<tr>
  <td><code>azimuth_grid</code></td>
  <td>Azimuth angles in [rad], -pi to pi, sorted</td>
  <td>Shape: <code>(n_azimuth_sta)</code></td>
</tr>
<tr>
  <td><code>elevation_grid</code></td>
  <td>Elevation angles in [rad], -pi/2 to pi/2, sorted</td>
  <td>Shape: <code>(n_elevation_sta)</code></td>
</tr>
<tr>
  <td><code>element_pos</code></td>
  <td>Antenna element (x,y,z) positions, optional</td>
  <td>Shape: <code>(3, n_elements_sta)</code></td>
</tr>
<tr>
  <td><code>coupling_re</code></td>
  <td>Coupling matrix, real part, optional</td>
  <td>Shape: <code>(n_elements_sta, n_ports_sta)</code></td>
</tr>
<tr>
  <td><code>coupling_im</code></td>
  <td>Coupling matrix, imaginary part, optional</td>
  <td>Shape: <code>(n_elements_sta, n_ports_sta)</code></td>
</tr>
</table><br>
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code><b>ChannelType</b></code><br> 
   Channel model type as defined by TGn. String. Supported: <code>A, B, C, D, E, F</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code><b>CarrierFreq_Hz</b> = 5.25e9</code> (optional)<br> 
   Carrier frequency in Hz. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code><b>tap_spacing_s</b> = 10e-9</code> (optional)<br> 
   Tap spacing in seconds. Must be equal to <code>10 ns / 2^k</code> (TGn default = <code>10e-9</code>). 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code><b>n_users</b> = 1</code> (optional)<br> 
   Number of users (only for TGac, TGah). Output struct array length equals <code>n_users</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code><b>observation_time</b> = 0</code> (optional)<br> 
   Channel observation time in seconds. <code>0</code> creates a static channel. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code><b>update_rate</b> = 1e-3</code> (optional)<br> 
   Channel update interval in seconds (only relevant when <code>observation_time &gt; 0</code>). 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code><b>speed_station_kmh</b> = 0</code> (optional)<br> 
   Station movement speed in km/h. Movement direction is <code>AoA_offset</code>. Only relevant when <code>observation_time &gt; 0</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code><b>speed_env_kmh</b> = 1.2</code> (optional)<br> 
   Environment movement speed in km/h. Default <code>1.2</code> for TGn, use <code>0.089</code> for TGac. Only relevant when <code>observation_time &gt; 0</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>vector <b>Dist_m</b> = [4.99]</code> (optional)<br> 
   TX-to-RX distance(s) in meters. Length <code>n_users</code> or length <code>1</code> (same distance for all users). 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code>vector <b>n_floors</b> = [0]</code> (optional)<br> 
   Number of floors for TGah model (per user), up to 4 floors. Length <code>n_users</code> or length <code>1</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code><b>uplink</b> = false</code> (optional)<br> 
   Channel direction flag. Default is downlink; set to <code>true</code> to generate reverse (uplink) direction. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code><b>offset_angles</b> = []</code> (optional)<br> 
   Offset angles in degree for MU-MIMO channels. Empty uses model defaults (TGac auto for <code>n_users &gt; 1</code>). 
   Shape <code>[4, n_users]</code> with rows: <code>AoD LOS, AoD NLOS, AoA LOS, AoA NLOS</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code><b>n_subpath</b> = 20</code> (optional)<br> 
   Number of sub-paths per path/cluster used for Laplacian angular spread mapping. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code><b>Doppler_effect</b> = 50</code> (optional)<br> 
   Special Doppler effects: models <code>D, E</code> (fluorescent lights, value = mains freq.) and <code>F</code> (moving vehicle speed in km/h). 
   Use <code>0</code> to disable. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code><b>seed</b> = -1</code> (optional)<br> 
   Numeric seed for repeatability. <code>-1</code> disables the fixed seed and uses the system random device. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code><b>KF_linear</b> = NAN</code> (optional)<br> 
   Overwrites the model-specific KF-value. If this parameter is NAN (default) or negative, model defaults are used: 
   A/B/C (KF = 1 for d < dBP, 0 otherwise); D (KF = 2 for d < dBP, 0 otherwise); E/F (KF = 4 for d < dBP, 0 otherwise). 
   KF is applied to the first tap only. Breakpoint distance is ignored for <code>KF_linear &gt;= 0</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code><b>XPR_NLOS_linear</b> = NAN</code> (optional)<br> 
   Overwrites the model-specific Cross-polarization ratio. If this parameter is NAN (default) or negative, 
   the model default of 2 (3 dB) is used. XPR is applied to all NLOS taps. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code><b>SF_std_dB_LOS</b> = NAN</code> (optional)<br> 
   Overwrites the model-specific shadow fading for LOS channels. If this parameter is NAN (default), 
   the model default of 3 dB is used. <code>SF_std_dB_LOS</code> is applied to all LOS channels, where the 
   AP-STA distance d < dBP. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code><b>SF_std_dB_NLOS</b> = NAN</code> (optional)<br> 
   Overwrites the model-specific shadow fading for LOS channels. If this parameter is NAN (default), 
   the model defaults are A/B: 4 dB, C/D: 5 dB, E/F: 6 dB. <code>SF_std_dB_NLOS</code> is applied to all NLOS channels, 
   where the AP-STA distance d >= dBP. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code><b>dBP_m</b> = NAN</code> (optional)<br> 
   Overwrites the model-specific breakpoint distance. If this parameter is NAN (default) or negative, 
   the model defaults are A/B/C: 5 m, D: 10 m, E: 20 m, F: 30 m. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Returns:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>chan</code></b><br> 
   List of length <code>n_users</code> containing dictionaries of channel data with the following keys. 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>name</code></td>
  <td>Channel name</td>
  <td>String</td>
</tr>
<tr>
  <td><code>tx_position</code></td>
  <td>Transmitter positions (AP for downlink, STA for uplink)</td>
  <td>Shape: <code>(3, 1)</code> or <code>(3, n_snap)</code></td>
</tr>
<tr>
  <td><code>rx_position</code></td>
  <td>Receiver positions (STA for downlink, AP for uplink)</td>
  <td>Shape: <code>(3, 1)</code> or <code>(3, n_snap)</code></td>
</tr>
<tr>
  <td><code>tx_orientation</code></td>
  <td>Transmitter orientation, Euler angles (AP for downlink, STA for uplink)</td>
  <td>Shape: <code>(3, 1)</code> or <code>(3, n_snap)</code></td>
</tr>
<tr>
  <td><code>rx_orientation</code></td>
  <td>Receiver orientation, Euler angles (STA for downlink, AP for uplink)</td>
  <td>Shape: <code>(3, 1)</code> or <code>(3, n_snap)</code></td>
</tr>
<tr>
  <td><code>coeff</code></td>
  <td>Channel coefficients, complex valued</td>
  <td>list of <code>[n_rx, n_tx, n_path_s]</code></td>
</tr>
<tr>
  <td><code>delay</code></td>
  <td>Propagation delays in seconds</td>
  <td>list of <code>[n_rx, n_tx, n_path_s]</code></td>
</tr>
<tr>
  <td><code>path_gain</code></td>
  <td>Path gain before antenna, linear scale</td>
  <td>list of <code>[n_path_s]</code></td>
</tr>
</table><br>
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="hdf5_create_file"></a>
<b>hdf5_create_file</b> - Create a new HDF5 channel file with a custom storage layout
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>Quadriga-Lib offers an HDF5-based method for storing and managing channel data. A key feature of this 
library is its ability to organize multiple channels within a single HDF5 file while enabling access 
to individual data sets without the need to read the entire file. In this system, channels can be 
structured in a multi-dimensional array. For instance, the first dimension might represent the Base 
Station (BS), the second the User Equipment (UE), and the third the frequency. However, it is important 
to note that the dimensions of the storage layout must be defined when the file is initially created 
and cannot be altered thereafter. The function <code>quadriga_lib.channel.hdf5_create_file</code> is used to create an 
empty file with a predetermined custom storage layout.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
from quadriga_lib import channel
channel.hdf5_create_file( fn, nx, ny, nz, nw )
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>fn</code></b><br> 
   Filename of the HDF5 file, string 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>nx</code></b> (optional)<br> 
   Number of elements on the x-dimension, Default = 65536 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>ny</code></b> (optional)<br> 
   Number of elements on the x-dimension, Default = 1 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>nz</code></b> (optional)<br> 
   Number of elements on the x-dimension, Default = 1 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>nw</code></b> (optional)<br> 
   Number of elements on the x-dimension, Default = 1 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="hdf5_read_channel"></a>
<b>hdf5_read_channel</b> - Reads channel data from HDF5 files
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>Quadriga-Lib provides an HDF5-based solution for storing and organizing channel data. This data 
comprises various well-defined sets, including channel coefficients, positions of transmitters and 
receivers, as well as path data that reflects the interaction of radio waves with the environment. 
Typically, these datasets are multi-dimensional, encompassing data for <code>n_rx</code> receive antennas, 
<code>n_tx</code> transmit antennas, <code>n_path</code> propagation paths, and <code>n_snap</code> snapshots. Snapshots are 
particularly useful for recording data across different locations (such as along a trajectory) or 
various frequencies. It is important to note that not all datasets include all these dimensions.<br><br> 
 
The library also supports the addition of extra datasets of any type or shape, which can be useful 
for incorporating descriptive data or analysis results. To facilitate data access, the function 
<code>quadriga_lib.channel.hdf5_read_channel</code> is designed to read both structured and unstructured data from the 
file.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
from quadriga_lib import channel
data = channel.hdf5_read_channel( fn, ix, iy, iz, iw, snap )
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>fn</code></b><br> 
   Filename of the HDF5 file, string 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>ix</code></b><br> 
   Storage index for x-dimension, Default = 0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>iy</code></b><br> 
   Storage index for y-dimension, Default = 0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>iz</code></b><br> 
   Storage index for z-dimension, Default = 0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>iw</code></b><br> 
   Storage index for w-dimension, Default = 0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>snap</code></b> (optional)<br> 
   Snapshot range, 0-based notation; optional; vector, default: empty = read all 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>data</code></b><br> 
   Dictionary containing the data in the HDF file with the following keys: 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>par</code></td>
  <td>Dictionary of unstructured data</td>
  <td>Variable</td>
</tr>
<tr>
  <td><code>rx_position</code></td>
  <td>Receiver positions</td>
  <td><code>[3, n_snap]</code> or <code>[3, 1]</code></td>
</tr>
<tr>
  <td><code>tx_position</code></td>
  <td>Transmitter positions</td>
  <td><code>[3, n_snap]</code> or <code>[3, 1]</code></td>
</tr>
<tr>
  <td><code>coeff</code></td>
  <td>Channel coefficients, complex valued</td>
  <td>list of <code>[n_rx, n_tx, n_path_s]</code></td>
</tr>
<tr>
  <td><code>delay</code></td>
  <td>Propagation delays in seconds</td>
  <td>list of <code>[n_rx, n_tx, n_path_s]</code> or <code>[1, 1, n_path_s]</code></td>
</tr>
<tr>
  <td><code>center_freq</code></td>
  <td>Center frequency in [Hz]</td>
  <td><code>[n_snap]</code> or scalar</td>
</tr>
<tr>
  <td><code>name</code></td>
  <td>Name of the channel</td>
  <td>String</td>
</tr>
<tr>
  <td><code>initial_pos</code></td>
  <td>Index of reference position, 1-based</td>
  <td>uint32, scalar</td>
</tr>
<tr>
  <td><code>path_gain</code></td>
  <td>Path gain before antenna, linear scale</td>
  <td>list of <code>[n_path_s]</code></td>
</tr>
<tr>
  <td><code>path_length</code></td>
  <td>Path length from TX to RX phase center in m</td>
  <td>list of <code>[n_path_s]</code></td>
</tr>
<tr>
  <td><code>polarization</code></td>
  <td>Polarization transfer function, complex valued</td>
  <td>list of <code>[4, n_path_s]</code></td>
</tr>
<tr>
  <td><code>path_angles</code></td>
  <td>Departure and arrival angles {AOD, EOD, AOA, EOA} in rad</td>
  <td>list of <code>[n_path, 4_s]</code></td>
</tr>
<tr>
  <td><code>path_fbs_pos</code></td>
  <td>First-bounce scatterer positions</td>
  <td>list of <code>[3, n_path_s]</code></td>
</tr>
<tr>
  <td><code>path_lbs_pos</code></td>
  <td>Last-bounce scatterer positions</td>
  <td>list of <code>[3, n_path_s]</code></td>
</tr>
<tr>
  <td><code>no_interact</code></td>
  <td>Number interaction points of paths with the environment</td>
  <td>uint32, list of <code>[n_path_s]</code></td>
</tr>
<tr>
  <td><code>interact_coord</code></td>
  <td>Interaction coordinates</td>
  <td>list of <code>[3, max(sum(no_interact))]</code></td>
</tr>
<tr>
  <td><code>rx_orientation</code></td>
  <td>Receiver orientation</td>
  <td><code>[3, n_snap]</code> or <code>[3]</code></td>
</tr>
<tr>
  <td><code>tx_orientation</code></td>
  <td>Transmitter orientation</td>
  <td><code>[3, n_snap]</code> or <code>[3]</code></td>
</tr>
</table><br>
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Caveat:</i></b><br><ul><li style="margin-bottom: 0.4em;">Only datasets that are present in the HDF file are returned in the dictionary. 
</li><li style="margin-bottom: 0.4em;">Although the data is stored in single precision, it is converted to double precision by default. 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="hdf5_read_dset"></a>
<b>hdf5_read_dset</b> - Read a single unstructured dataset from an HDF5 file
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>Quadriga-Lib offers a solution based on HDF5 for storing and organizing channel data. In addition 
to structured datasets, the library facilitates the inclusion of extra datasets of various types 
and shapes. This feature is particularly beneficial for integrating descriptive data or analysis 
results. The function <code>quadriga_lib.channel.hdf5_read_dset</code> retrieves a single unstructured dataset. 
The output type of the function is defined by the datatype in the file. An empty matrix is returned 
if the dataset does not exist in the file.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
from quadriga_lib import channel
dset = channel.hdf5_read_dset( fn, ix, iy, iz, iw, name )
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>fn</code></b><br> 
   Filename of the HDF5 file, string 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>ix</code></b><br> 
   Storage index for x-dimension, Default = 0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>iy</code></b><br> 
   Storage index for y-dimension, Default = 0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>iz</code></b><br> 
   Storage index for z-dimension, Default = 0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>iw</code></b><br> 
   Storage index for w-dimension, Default = 0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>name</code></b><br> 
   Name of the dataset; String 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Argument:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>dset</code></b><br> 
   Output data. Type and size is defined by the dataspace in the file 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Caveat:</i></b><br><ul><li style="margin-bottom: 0.4em;">Only datasets that are present in the HDF file are returned in the dictionary. 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="hdf5_read_dset_names"></a>
<b>hdf5_read_dset_names</b> - Read the names of unstructured data fields from an HDF5 file
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>Quadriga-Lib offers a solution based on HDF5 for storing and organizing channel data. In addition 
to structured datasets, the library facilitates the inclusion of extra datasets of various types 
and shapes. This feature is particularly beneficial for integrating descriptive data or analysis 
results. Users can add any number of such unstructured datasets, each identified by a unique 
dataset name. The function <code>quadriga_lib.channel.hdf5_read_dset_names</code> retrieves the names of all  
these datasets, returning them as a list of strings.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
from quadriga_lib import channel
names = channel.hdf5_read_dset_names( fn, ix, iy, iz, iw );
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>fn</code></b><br> 
   Filename of the HDF5 file, string 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>ix</code></b><br> 
   Storage index for x-dimension, Default = 0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>iy</code></b><br> 
   Storage index for y-dimension, Default = 0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>iz</code></b><br> 
   Storage index for z-dimension, Default = 0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>iw</code></b><br> 
   Storage index for w-dimension, Default = 0 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Argument:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>names</code></b><br> 
   List of names of all these at the given location in the files; Cell array of strings 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="hdf5_read_layout"></a>
<b>hdf5_read_layout</b> - Read the storage layout of channel data inside an HDF5 file
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>Quadriga-Lib provides an HDF5-based solution for the storage and organization of channel data. A 
notable feature of this library is its capacity to manage multiple channels within a single HDF5 
file. In this framework, channels can be arranged in a multi-dimensional array format. 
 
The function <code>quadriga_lib.channel.hdf5_read_layout</code> is designed to read the storage layout from an 
existing file. Furthermore, it also generates an array that marks the locations within the layout 
where data already exists. This functionality aids in efficiently managing and accessing channel 
data within the HDF5 file structure.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
from quadriga_lib import channel
storage_dims, has_data = channel.hdf5_read_layout( fn )
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Argument:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>fn</code></b><br> 
   Filename of the HDF5 file, string 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>storage_dims</code></b><br> 
   Size of the dimensions of the storage space, vector with 4 elements, i.e. <code>[nx,ny,nz,nw]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>has_data</code></b><br> 
   Array indicating if data exists (value 1) or not (value 0); uint32; Size: <code>[nx,ny,nz,nw]</code> 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="hdf5_reshape_layout"></a>
<b>hdf5_reshape_layout</b> - Reshapes the storage layout inside an existing HDF5 file
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>Quadriga-Lib provides an HDF5-based solution for the storage and organization of channel data. A 
notable feature of this library is its capacity to manage multiple channels within a single HDF5 
file. In this framework, channels can be arranged in a multi-dimensional array format. 
Once an HDF5 file has been created, the number of channels in the storage layout is fixed. 
However, it is possible to reshape the layout using <code>quadriga_lib.channel.hdf5_reshape_layout</code>.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
from quadriga_lib import channel
channel.hdf5_reshape_layout( fn, storage_dims );
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>fn</code></b><br> 
   Filename of the HDF5 file, string 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>nx</code></b> (optional)<br> 
   Number of elements on the x-dimension, Default = 65536 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>ny</code></b> (optional)<br> 
   Number of elements on the x-dimension, Default = 1 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>nz</code></b> (optional)<br> 
   Number of elements on the x-dimension, Default = 1 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>nw</code></b> (optional)<br> 
   Number of elements on the x-dimension, Default = 1 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="hdf5_write_channel"></a>
<b>hdf5_write_channel</b> - Writes channel data to HDF5 files
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>Quadriga-Lib provides an HDF5-based solution for storing and organizing channel data. This function 
can be used to write structured and unstructured data to an HDF5 file.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
from quadriga_lib import channel

storage_dims = channel.hdf5_write_channel( fn, ix, iy, iz, iw, par, rx_pos, tx_pos, ...
   coeff, delay, center_freq, name, initial_pos, path_gain, path_length, ...
   polarization, path_angles, path_fbs_pos, path_lbs_pos, no_interact, interact_coord, ...
   rx_orientation, tx_orientation )
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>fn</code></b><br> 
   Filename of the HDF5 file, string 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>ix</code></b><br> 
   Storage index for x-dimension, Default = 0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>iy</code></b><br> 
   Storage index for y-dimension, Default = 0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>iz</code></b><br> 
   Storage index for z-dimension, Default = 0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>iw</code></b><br> 
   Storage index for w-dimension, Default = 0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>par</code></b><br> 
   Dictionary of unstructured data, can be empty if no unstructured data should be written 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b>Structured data:</b> (double precision)<br> 
   Each snapshot may have a different number of paths <code>n_path_s</code>. Variable-length data is provided as lists. 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>rx_pos</code></td>
  <td>Receiver positions</td>
  <td><code>[3, n_snap]</code> or <code>[3, 1]</code></td>
</tr>
<tr>
  <td><code>tx_pos</code></td>
  <td>Transmitter positions</td>
  <td><code>[3, n_snap]</code> or <code>[3, 1]</code></td>
</tr>
<tr>
  <td><code>coeff</code></td>
  <td>Channel coefficients, complex valued</td>
  <td>list of <code>[n_rx, n_tx, n_path_s]</code></td>
</tr>
<tr>
  <td><code>delay</code></td>
  <td>Propagation delays in seconds</td>
  <td>list of <code>[n_rx, n_tx, n_path_s]</code> or <code>[1, 1, n_path_s]</code></td>
</tr>
<tr>
  <td><code>center_freq</code></td>
  <td>Center frequency in [Hz]</td>
  <td><code>[n_snap]</code> or scalar</td>
</tr>
<tr>
  <td><code>name</code></td>
  <td>Name of the channel</td>
  <td>String</td>
</tr>
<tr>
  <td><code>initial_pos</code></td>
  <td>Index of reference position, 1-based</td>
  <td>uint32, scalar</td>
</tr>
<tr>
  <td><code>path_gain</code></td>
  <td>Path gain before antenna, linear scale</td>
  <td>list of <code>[n_path_s]</code></td>
</tr>
<tr>
  <td><code>path_length</code></td>
  <td>Path length from TX to RX phase center in m</td>
  <td>list of <code>[n_path_s]</code></td>
</tr>
<tr>
  <td><code>polarization</code></td>
  <td>Polarization transfer function, complex valued</td>
  <td>list of <code>[4, n_path_s]</code></td>
</tr>
<tr>
  <td><code>path_angles</code></td>
  <td>Departure and arrival angles {AOD, EOD, AOA, EOA} in rad</td>
  <td>list of <code>[n_path, 4_s]</code></td>
</tr>
<tr>
  <td><code>path_fbs_pos</code></td>
  <td>First-bounce scatterer positions</td>
  <td>list of <code>[3, n_path_s]</code></td>
</tr>
<tr>
  <td><code>path_lbs_pos</code></td>
  <td>Last-bounce scatterer positions</td>
  <td>list of <code>[3, n_path_s]</code></td>
</tr>
<tr>
  <td><code>no_interact</code></td>
  <td>Number interaction points of paths with the environment</td>
  <td>uint32, list of <code>[n_path_s]</code></td>
</tr>
<tr>
  <td><code>interact_coord</code></td>
  <td>Interaction coordinates</td>
  <td>list of <code>[3, max(sum(no_interact))]</code></td>
</tr>
<tr>
  <td><code>rx_orientation</code></td>
  <td>Transmitter orientation</td>
  <td><code>[3, n_snap]</code> or <code>[3]</code></td>
</tr>
<tr>
  <td><code>tx_orientation</code></td>
  <td>Receiver orientation</td>
  <td><code>[3, n_snap]</code> or <code>[3]</code></td>
</tr>
</table><br>
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>storage_dims</code></b><br> 
   Size of the dimensions of the storage space, vector with 4 elements, i.e. <code>[nx,ny,nz,nw]</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Caveat:</i></b><br><ul><li style="margin-bottom: 0.4em;">If the file exists already, the new data is added to the exisiting file 
</li><li style="margin-bottom: 0.4em;">If a new file is created, a storage layout is created to store the location of datasets in the file 
</li><li style="margin-bottom: 0.4em;">For <code>location = [ix]</code> storage layout is <code>[65536,1,1,1]</code> or <code>[ix,1,1,1]</code> if (<code>ix &gt; 65536</code>) 
</li><li style="margin-bottom: 0.4em;">For <code>location = [ix,iy]</code> storage layout is <code>[1024,64,1,1]</code> 
</li><li style="margin-bottom: 0.4em;">For <code>location = [ix,iy,iz]</code> storage layout is <code>[256,16,16,1]</code> 
</li><li style="margin-bottom: 0.4em;">For <code>location = [ix,iy,iz,iw]</code> storage layout is <code>[128,8,8,8]</code> 
</li><li style="margin-bottom: 0.4em;">You can create a custom storage layout by creating the file first using "<code>hdf5_create_file</code>" 
</li><li style="margin-bottom: 0.4em;">You can reshape the storage layout by using "<code>hdf5_reshape_storage</code>", but the total number of elements must not change 
</li><li style="margin-bottom: 0.4em;">Inputs can be empty or missing. 
</li><li style="margin-bottom: 0.4em;">All structured data is written in single precision (but can can be provided as single or double) 
</li><li style="margin-bottom: 0.4em;">Unstructured datatypes are maintained in the HDF file 
</li><li style="margin-bottom: 0.4em;">Supported unstructured types: string, double, float, (u)int32, (u)int64 
</li><li style="margin-bottom: 0.4em;">Supported unstructured size: up to 3 dimensions 
</li><li style="margin-bottom: 0.4em;">Storage order of the unstructured data is maintained 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="hdf5_write_dset"></a>
<b>hdf5_write_dset</b> - Writes unstructured data to a HDF5 file
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>Quadriga-Lib offers a solution based on HDF5 for storing and organizing channel data. In addition 
to structured datasets, the library facilitates the inclusion of extra datasets of various types 
and shapes. This feature is particularly beneficial for integrating descriptive data or analysis 
results. The function <code>quadriga_lib.channel.hdf5_write_dset</code> writes a single unstructured dataset.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
from quadriga_lib import channel
channel.hdf5_write_dset( fn, ix, iy, iz, iw, name, data );
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>fn</code></b><br> 
   Filename of the HDF5 file, string 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>ix</code></b><br> 
   Storage index for x-dimension, Default = 0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>iy</code></b><br> 
   Storage index for y-dimension, Default = 0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>iz</code></b><br> 
   Storage index for z-dimension, Default = 0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>iw</code></b><br> 
   Storage index for w-dimension, Default = 0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>name</code></b><br> 
   Name of the dataset; String 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>data</code></b><br> 
   Data to be written 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Caveat:</i></b><br><ul><li style="margin-bottom: 0.4em;">Throws an error if dataset already exists at this location 
</li><li style="margin-bottom: 0.4em;">Throws an error if file does not exist (use hdf5_create_file) 
</li><li style="margin-bottom: 0.4em;">Supported types: string, double, float, (u)int32, (u)int64 
</li><li style="margin-bottom: 0.4em;">Supported size: up to 3 dimensions 
</li><li style="margin-bottom: 0.4em;">Storage order is maintained 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="qrt_file_parse"></a>
<b>qrt_file_parse</b> - Read metadata from a QRT file
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
from quadriga_lib import channel

# Separate outputs
no_cir, no_orig, no_dest, no_freq, cir_offset, orig_names, dest_names, version, fGHz, cir_pos, cir_orientation, orig_pos, orig_orientation = channel.qrt_file_parse( fn )

# Output as tuple
data = channel.qrt_file_parse( fn )
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Argument:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>fn</code></b><br> 
   Filename of the QRT file, string 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>no_cir</code></b><br> 
   Number of channel snapshots per origin point 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>no_orig</code></b><br> 
   Number of origin points (e.g., TXs) 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>no_dest</code></b><br> 
   Number of destinations (RX) 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>no_freq</code></b><br> 
   Number of frequencies 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>cir_offset</code></b><br> 
   CIR offset for each destination 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>orig_names</code></b><br> 
   Names of the origin points (TXs), list of strings 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>dest_names</code></b><br> 
   Names of the destination points (RXs), list of strings 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>version</code></b><br> 
   QRT file version 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>fGHz</code></b><br> 
   Center frequency in GHz as stored in the QRT file, numpy array of floats 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>cir_pos</code></b><br> 
   CIR positions in Cartesian coordinates, numpy array of shape [no_cir, 3] 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>cir_orientation</code></b><br> 
   CIR orientation in Euler angles in rad, numpy array of shape [no_cir, 3] 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>orig_pos</code></b><br> 
   Origin (TX) positions in Cartesian coordinates, numpy array of shape [no_orig, 3] 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>orig_orientation</code></b><br> 
   Origin (TX) orientations in Euler angles in rad, numpy array of shape [no_orig, 3] 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="qrt_file_read"></a>
<b>qrt_file_read</b> - Read ray-tracing data from QRT file
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
from quadriga_lib import channel
data = channel.qrt_file_read( fn, i_cir, i_orig, downlink )
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>fn</code></b><br> 
   Filename of the QRT file, string 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>cir</code></b><br> 
   Snapshot index in the file, Default = 0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>orig</code></b><br> 
   Origin index (for downlink Origin = TX), Default = 0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>downlink</code></b><br> 
   Switch for uplink / downlink direction, Default = true (downlink) 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>normalize_M</code></b><br> 
    Switch for different normalization options: 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td>0</td>
  <td>M as in QRT file, path_gain as FSPL (no normalization)</td>
</tr>
<tr>
  <td>1</td>
  <td>M has sum-column power is 2, path_gain is FSPL + material losses (default)</td>
</tr>
</table><br>
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>data</code></b><br> 
   Dictionary containing the data in the HDF file with the following keys: 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>center_freq</code></td>
  <td>Center frequency in [Hz]</td>
  <td>Length <code>[n_freq]</code></td>
</tr>
<tr>
  <td><code>tx_pos</code></td>
  <td>Transmitter position</td>
  <td>Length <code>[3]</code></td>
</tr>
<tr>
  <td><code>tx_orientation</code></td>
  <td>Transmitter orientation, Euler angles, rad</td>
  <td>Length <code>[3]</code></td>
</tr>
<tr>
  <td><code>rx_pos</code></td>
  <td>Receiver position</td>
  <td>Length <code>[3]</code></td>
</tr>
<tr>
  <td><code>rx_orientation</code></td>
  <td>Receiver orientation, Euler angles, rad</td>
  <td>Length <code>[3]</code></td>
</tr>
<tr>
  <td><code>fbs_pos</code></td>
  <td>First-bounce scatterer positions</td>
  <td>Size <code>[3, n_path]</code></td>
</tr>
<tr>
  <td><code>lbs_pos</code></td>
  <td>Last-bounce scatterer positions</td>
  <td>Size <code>[3, n_path]</code></td>
</tr>
<tr>
  <td><code>path_gain</code></td>
  <td>Path gain before antenna, linear scale</td>
  <td>Size <code>[n_path, n_freq]</code></td>
</tr>
<tr>
  <td><code>path_length</code></td>
  <td>Path length from TX to RX phase center in m</td>
  <td>Length <code>[n_path]</code></td>
</tr>
<tr>
  <td><code>M</code></td>
  <td>Polarization transfer function, interleaved complex</td>
  <td>Size <code>[8, n_path, n_freq]</code> or <code>[2, n_path, n_freq]</code></td>
</tr>
<tr>
  <td><code>aod</code></td>
  <td>Departure azimuth angles in [rad]</td>
  <td>Length <code>[n_path]</code></td>
</tr>
<tr>
  <td><code>eod</code></td>
  <td>Departure elevation angles in [rad]</td>
  <td>Length <code>[n_path]</code></td>
</tr>
<tr>
  <td><code>aoa</code></td>
  <td>Arrival azimuth angles in [rad]</td>
  <td>Length <code>[n_path]</code></td>
</tr>
<tr>
  <td><code>eoa</code></td>
  <td>Arrival elevation angles in [rad]</td>
  <td>Length <code>[n_path]</code></td>
</tr>
<tr>
  <td><code>path_coord</code></td>
  <td>Interaction coordinates</td>
  <td>List of <code>[3, n_int_s]</code></td>
</tr>
</table><br>
</li></ul>
</li>
</ul>
<div class="pagebreak"></div>
<hr class="greyline">
<hr class="greyline">
<br>
<br>
<a name="b11e2d16"></a>
<font size=+1><b>Miscellaneous / Tools</b></font>
<br>
<br>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="cart2geo"></a>
<b>cart2geo</b> - Transform Cartesian (x,y,z) coordinates to Geographic (az, el, length) coordinates
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>This function transforms Cartesian (x,y,z) coordinates to Geographic (azimuth, elevation, length) 
coordinates. A geographic coordinate system is a three-dimensional reference system that locates 
points on the surface of a sphere. A point has three coordinate values: azimuth, elevation and length 
where azimuth and elevation measure angles. In the geographic coordinate system, the elevation angle 
θ = 90° points to the zenith and θ = 0° points to the horizon.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
import quadriga_lib
geo_coords = quadriga_lib.tools.cart2geo(cart_coords)
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Argument:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>cart_coords</code></b><br> 
   Cartesian coordinates (x,y,z), Shape: <code>(3, n_row, n_col)</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>geo_coords</code></b><br> 
   Geographic coordinates, Shape: <code>(3, n_row, n_col)</code><br> 
   First row: Azimuth angles in [rad], values between -pi and pi.<br> 
   Second row: Elevation angles in [rad], values between -pi/2 and pi/2.<br> 
   Third row: Vector length, i.e. the distance from the origin to the point defined by x,y,z. 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="components"></a>
<b>components</b> - Returns the version numbers of all quadriga-lib sub-components
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
components = quadriga_lib.components()
</pre>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="version"></a>
<b>version</b> - Returns the quadriga-lib version number
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
version = quadriga_lib.version();
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Caveat:</i></b><br><ul><li style="margin-bottom: 0.4em;">If Quadriga-Lib was compiled with AVX2 support and the CPU supports intrinsic AVX2 instructions, 
   an suffix <code>_AVX2</code> is added after the version number 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="write_png"></a>
<b>write_png</b> - Write data to a PNG file
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Converts input data into a color-coded PNG file for visualization 
</li><li style="margin-bottom: 0.4em;">Support optional selection of a colormap, as well a minimum and maximum value limits 
</li><li style="margin-bottom: 0.4em;">Uses the <a href="https://github.com/lvandeve/lodepng">LodePNG</a> library for PNG writing 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Declaration:</i></b><br><pre>
import quadriga_lib

quadriga_lib.tools.write_png( fn, data, colormap, min_val, max_val, log_transform )
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>fn</code></b><br> 
   Filename of the PNG file, string, required 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>data</code></b><br> 
   Data matrix, required, size <code>[N, M]</code>  
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>colormap</code></b> (optional)<br> 
   Colormap for the visualization, string, supported are 'jet', 'parula', 'winter', 'hot', 'turbo', 
   'copper', 'spring', 'cool', 'gray', 'autumn', 'summer', optional, default = 'jet' 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>min_val</code></b> (optional)<br> 
   Minimum value. Values below this value will have be encoded with the color of the smallest value. 
   If <code>NAN</code> is provided (default), the lowest values is determined from the data. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>max_val</code></b> (optional)<br> 
   Maximum value. Values above this value will have be encoded with the color of the largest value. 
   If <code>NAN</code> is provided (default), the largest values is determined from the data. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code><b>log_transform</b></code> (optional)<br> 
   If enabled, the <code>data</code> values are transformed to the log-domain (<code>10*log10(data)</code>) before processing. 
   Default: false (disabled) 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div>
<hr class="greyline">
<hr class="greyline">
<br>
<br>
<a name="2c1fd9e4"></a>
<font size=+1><b>Site-Specific Simulation Tools</b></font>
<br>
<br>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="icosphere"></a>
<b>icosphere</b> - Construct a geodesic polyhedron (icosphere), a convex polyhedron made from triangles
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>An icosphere is constructed by subdividing faces of an icosahedron, a polyhedron with 20 faces, 
12 vertices and 30 edges, and then projecting the new vertices onto the surface of a sphere. The 
resulting mesh has 6 triangles at each vertex, except for 12 vertices which have 5 triangles. 
The approximate equilateral triangles have roughly the same edge length and surface area.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
from quadriga_lib import RTtools
center, length, vert, direction = RTtools.icosphere( no_div, radius, direction_xyz )
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>no_div</code></b><br> 
   Number of divisions per edge of the generating icosahedron. The resulting number of faces is 
   equal to <code>no_face = 20 · no_div^2</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>radius</code></b><br> 
   Radius of the sphere in meters 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>direction_xyz</code></b><br> 
   Direction format indicator: 0 = Spherical (default), 1 = Cartesian 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments (tuple containing 4 values):</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>center</code></b><br> 
   Position of the center point of each triangle; Shape: <code>( no_face, 3 )</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>length</code></b><br> 
   Length of the vector pointing from the origin to the center point. This number is smaller than 
   1 since the triangles are located inside the unit sphere; Shape: <code>( no_face )</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>vert</code></b><br> 
   The 3 vectors pointing from the center point to the vertices of each triangle; the values are 
   in the order <code>[ v1x, v1y, v1z, v2x, v2y, v2z, v3x, v3y, v3z ]</code>; Shape: <code>( no_face, 9 )</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>direction</code></b><br> 
   The directions of the vertex-rays. If the format indicator <code>direction_xyz</code> is set to <code>0</code>, the 
   output is in geographic coordinates (azimuth and elevation angle in rad); the values are in the 
   order <code>( v1az, v1el, v2az, v2el, v3az, v3el ]</code>;Shape: <code>( no_face, 6 )</code> If the format indicator 
   <code>direction_xyz</code> is set to <code>1</code>, the output is in Cartesian coordinates and the values are in the 
   order <code>[ v1x, v1y, v1z, v2x, v2y, v2z, v3x, v3y, v3z  ]</code>; Shape: <code>( no_face, 9 )</code> 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="mitsuba_xml_file_write"></a>
<b>mitsuba_xml_file_write</b> - Write geometry and material data to a Mitsuba 3 XML scene file.
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>Converts a triangular surface mesh into the XML format understood by <b>Mitsuba 3</b> 
<a href="https://www.mitsuba-renderer.org">www.mitsuba-renderer.org</a>. 
The generated file can be loaded directly by <b>NVIDIA Sionna RT</b> for differentiable radio-propagation 
simulations.<br><br> 
 
<ul><li style="margin-bottom: 0.4em;">Converts a 3D geometry mesh into Mitsuba 3 XML format for use with rendering tools. 
</li><li style="margin-bottom: 0.4em;">Enables exporting models from <code>quadriga-lib</code> to be used with <b>Mitsuba 3</b> or <b>Sionna RT</b>: 
</li><li style="margin-bottom: 0.4em;"><a href="https://www.mitsuba-renderer.org">Mitsuba 3</a>: Research-oriented retargetable rendering system. 
</li><li style="margin-bottom: 0.4em;"><a href="https://developer.nvidia.com/sionna">NVIDIA Sionna</a>: Hardware-accelerated differentiable ray tracer for wireless propagation, built on Mitsuba 3. 
</li><li style="margin-bottom: 0.4em;">Supports grouping faces into named objects and assigning materials by name. 
</li><li style="margin-bottom: 0.4em;">Optionally maps materials to ITU default presets used by Sionna RT. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
from quadriga_lib import RTtools
RTtools.mitsuba_xml_file_write( fn, vert_list, face_ind, obj_id, mtl_id, obj_names, mtl_names, bsdf, map_to_itu )
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>fn</code></b><br> 
   Output file name (including path and <code>.xml</code> extension). 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>vert_list</code></b><br> 
   Vertex list, size <code>[n_vert, 3]</code>, each row is a vertex (x, y, z) in Cartesian coordinates [m]. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>face_ind</code></b><br> 
   Face indices (0-based), size <code>[n_mesh, 3]</code>, each row defines a triangle via vertex indices. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>obj_id</code></b> (input)<br> 
   Object indices (1-based), size <code>[n_mesh]</code>. Assigns each triangle to an object. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>mtl_id</code></b> (input)<br> 
   Material indices (1-based), size <code>[n_mesh]</code>. Assigns each triangle to a material. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>obj_names</code></b><br> 
   List of object names. Length must be equal to <code>max(obj_ind)</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>mtl_names</code></b><br> 
   List of material names. Length must be equal to <code>max(mtl_ind)</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code><b>bsdf</b> = []</code> (optional input)<br> 
   Material reflectivity data (BSDF parameters), size <code>[len(mtl_names), 17]</code>. If omitted, the <code>null</code> BSDF is used. 
   Note that Sionna RT ignores all BSDF parameters. They are only used by the Mitsuma rendering system. 
   See <a href="#obj_file_read">obj_file_read</a> for a definition of the data fields. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code><b>map_to_itu</b> = false</code> (optional input)<br> 
   If true, maps material names to ITU-defined presets used by Sionna RT. Default: <code>false</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>See also:</i></b><br><ul><li style="margin-bottom: 0.4em;"><a href="#obj_file_read">obj_file_read</a> 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="obj_file_read"></a>
<b>obj_file_read</b> - Reads a triangulated 3D polygon mesh from a Wavefront OBJ file
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>The function imports a polygon mesh from an OBJ file. The OBJ file format is a straightforward data 
format, representing 3D geometry. It details the position of each vertex and defines polygons as lists 
of these vertices. By default, vertices are arranged in a counter-clockwise order, eliminating the 
need for explicit declaration of face normals. When exporting the mesh from software like Blender, 
it's essential to triangulate the mesh and include material definitions. If the material name 
exists in the material database, the function loads the corresponding properties. 
Otherwise, it defaults to using standard properties.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
from quadriga_lib import RTtools

# Return as separate variables
mesh, mtl_prop, vert_list, face_ind, obj_ind, mtl_ind, obj_names, mtl_names, bsdf = RTtools.obj_file_read( fn )

# Return as tuple with 8 elements
data = RTtools.obj_file_read( fn )

# Use a custom material definition file
data = RTtools.obj_file_read( fn, materials_csv )
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>fn</code></b><br> 
   Filename of the OBJ file, string 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>materials_csv</code></b> (optional)<br> 
    Path to optional CSV file containing custom material properties. If empty, default ITU-R P.2040-3  
    materials are used. CSV format: Header row with columns 'name', 'a', 'b', 'c', 'd', 'att' (order can vary). 
    Each row defines a material with: name (string), electromagnetic parameters a,b,c,d (doubles),  
    and additional attenuation att (dB). Relative permittivity: eta = a * f_GHz^b; Conductivity:  
    sigma = c * f_GHz^d 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>mesh</code></b>, <code>data[0]</code><br> 
   Vertices of the triangular mesh in global Cartesian coordinates. Each face is described by 3 points 
   in 3D-space. Hence, a face has 9 values in the order [ v1x, v1y, v1z, v2x, v2y, v2z, v3x, v3y, v3z ]; <br> 
   Size: <code>[ no_mesh, 9 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>mtl_prop</code></b>, <code>data[1]</code><br> 
   Material properties of each mesh element; If no material is defined for an object, the properties 
   for vacuum are used. Size: <code>[ no_mesh, 5 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>vert_list</code></b>, <code>data[2]</code><br> 
   List of vertices found in the OBJ file; Size: <code>[ no_vert, 3 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>face_ind</code></b>, <code>data[3]</code><br> 
   Triangular faces are defined by three vertices. Vertex indices match the corresponding vertex elements 
   of the previously defined <code>vert_list</code> (<b>0-based</b>). <br> 
   uint32; Size: <code>[ no_mesh, 3 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>obj_id</code></b>, <code>data[4]</code><br> 
   Mesh elements in the OBJ file can be grouped into objects (e.g. 12 triangles define the walls of a 
   cube). Each object is identified by a unique ID (<b>1-based</b> index of <code>obj_names</code>). <br> 
   uint32; Size: <code>[ no_mesh, 1 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>mtl_id</code></b>, <code>data[5]</code><br> 
   Each mesh element gets assigned a material and each unique material gets assigned an ID (<b>1-based</b>  
   index of <code>mtl_names</code>). Different faces of an object can have different materials. If no material is  
   defined in the OBJ file, the id is set to <code>0</code> and no entry is made in <code>mtl_names</code>. <br> 
   uint32; Size: <code>[ no_mesh, 1 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>obj_names</code></b>, <code>data[6]</code><br> 
   Names of the objects in the OBJ file; List of strings 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>mtl_names</code></b>, <code>data[7]</code><br> 
   Names of the materials in the OBJ file; List of strings 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>bsdf</code></b>, <code>data[8]</code><br> 
   Principled BSDF (Bidirectional Scattering Distribution Function) values extracted from the 
   .MTL file. Size <code>[mtl_names.size(), 17]</code>. Values are: 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td>0</td>
  <td>Base Color Red</td>
  <td>Range 0-1</td>
  <td>Default = 0.8</td>
</tr>
<tr>
  <td>1</td>
  <td>Base Color Green</td>
  <td>Range 0-1</td>
  <td>Default = 0.8</td>
</tr>
<tr>
  <td>2</td>
  <td>Base Color Blue</td>
  <td>Range 0-1</td>
  <td>Default = 0.8</td>
</tr>
<tr>
  <td>3</td>
  <td>Transparency (alpha)</td>
  <td>Range 0-1</td>
  <td>Default = 1.0 (fully opaque)</td>
</tr>
<tr>
  <td>4</td>
  <td>Roughness</td>
  <td>Range 0-1</td>
  <td>Default = 0.5</td>
</tr>
<tr>
  <td>5</td>
  <td>Metallic</td>
  <td>Range 0-1</td>
  <td>Default = 0.0</td>
</tr>
<tr>
  <td>6</td>
  <td>Index of refraction (IOR)</td>
  <td>Range 0-4</td>
  <td>Default = 1.45</td>
</tr>
<tr>
  <td>7</td>
  <td>Specular Adjustment to the IOR</td>
  <td>Range 0-1</td>
  <td>Default = 0.5 (no adjustment)</td>
</tr>
<tr>
  <td>8</td>
  <td>Emission Color Red</td>
  <td>Range 0-1</td>
  <td>Default = 0.0</td>
</tr>
<tr>
  <td>9</td>
  <td>Emission Color Green</td>
  <td>Range 0-1</td>
  <td>Default = 0.0</td>
</tr>
<tr>
  <td>10</td>
  <td>Emission Color Blue</td>
  <td>Range 0-1</td>
  <td>Default = 0.0</td>
</tr>
<tr>
  <td>11</td>
  <td>Sheen</td>
  <td>Range 0-1</td>
  <td>Default = 0.0</td>
</tr>
<tr>
  <td>12</td>
  <td>Clearcoat</td>
  <td>Range 0-1</td>
  <td>Default = 0.0</td>
</tr>
<tr>
  <td>13</td>
  <td>Clearcoat roughness</td>
  <td>Range 0-1</td>
  <td>Default = 0.0</td>
</tr>
<tr>
  <td>14</td>
  <td>Anisotropic</td>
  <td>Range 0-1</td>
  <td>Default = 0.0</td>
</tr>
<tr>
  <td>15</td>
  <td>Anisotropic rotation</td>
  <td>Range 0-1</td>
  <td>Default = 0.0</td>
</tr>
<tr>
  <td>16</td>
  <td>Transmission</td>
  <td>Range 0-1</td>
  <td>Default = 0.0</td>
</tr>
</table><br>
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Material properties:</i></b><br>Each material is defined by its electrical properties. Radio waves that interact with a building will 
produce losses that depend on the electrical properties of the building materials, the material 
structure and the frequency of the radio wave. The fundamental quantities of interest are the electrical 
permittivity (ϵ) and the conductivity (σ). A simple regression model for the frequency dependence is 
obtained by fitting measured values of the permittivity and the conductivity at a number of frequencies. 
The five parameters returned in <code>mtl_prop</code> then are: 
 
<ul><li style="margin-bottom: 0.4em;">Real part of relative permittivity at f = 1 GHz (a) 
</li><li style="margin-bottom: 0.4em;">Frequency dependence of rel. permittivity (b) such that ϵ = a · f^b 
</li><li style="margin-bottom: 0.4em;">Conductivity at f = 1 GHz (c) 
</li><li style="margin-bottom: 0.4em;">Frequency dependence of conductivity (d) such that σ = c· f^d 
</li><li style="margin-bottom: 0.4em;">Fixed attenuation in dB applied to each transition 
</li></ul>
 
A more detailed explanation together with a derivation can be found in ITU-R P.2040. The following 
list of material is currently supported and the material can be selected by using the <code>usemtl</code> tag 
in the OBJ file. When using Blender, the simply assign a material with that name to an object or face. 
In addition, custom properties can be set by assigning adding the 5 properties after the material 
name, separated by <code>:</code>, e.g.: 
 
<pre>
usemtl custom::2.1:0.1:0.1:0.5:20
</pre>
 
The following materials are defined by default: 
 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <th>Name</th>
  <th>a</th>
  <th>b</th>
  <th>c</th>
  <th>d</th>
  <th>Att</th>
  <th>max fGHz</th>
  <th></th>
</tr>
<tr>
  <td>vacuum / air</td>
  <td>1.0</td>
  <td>0.0</td>
  <td>0.0</td>
  <td>0.0</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>textiles</td>
  <td>1.5</td>
  <td>0.0</td>
  <td>5e-5</td>
  <td>0.62</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>plastic</td>
  <td>2.44</td>
  <td>0.0</td>
  <td>2.33e-5</td>
  <td>1.0</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>ceramic</td>
  <td>6.5</td>
  <td>0.0</td>
  <td>0.0023</td>
  <td>1.32</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>sea_water</td>
  <td>80.0</td>
  <td>-0.25</td>
  <td>4.0</td>
  <td>0.58</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>sea_ice</td>
  <td>3.2</td>
  <td>-0.022</td>
  <td>1.1</td>
  <td>1.5</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>water</td>
  <td>80.0</td>
  <td>-0.18</td>
  <td>0.6</td>
  <td>1.52</td>
  <td>0.0</td>
  <td>20</td>
  <td></td>
</tr>
<tr>
  <td>water_ice</td>
  <td>3.17</td>
  <td>-0.005</td>
  <td>5.6e-5</td>
  <td>1.7</td>
  <td>0.0</td>
  <td>20</td>
  <td></td>
</tr>
<tr>
  <td>itu_concrete</td>
  <td>5.24</td>
  <td>0.0</td>
  <td>0.0462</td>
  <td>0.7822</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>itu_brick</td>
  <td>3.91</td>
  <td>0.0</td>
  <td>0.0238</td>
  <td>0.16</td>
  <td>0.0</td>
  <td>40</td>
  <td></td>
</tr>
<tr>
  <td>itu_plasterboard</td>
  <td>2.73</td>
  <td>0.0</td>
  <td>0.0085</td>
  <td>0.9395</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>itu_wood</td>
  <td>1.99</td>
  <td>0.0</td>
  <td>0.0047</td>
  <td>1.0718</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>itu_glass</td>
  <td>6.31</td>
  <td>0.0</td>
  <td>0.0036</td>
  <td>1.3394</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>itu_ceiling_board</td>
  <td>1.48</td>
  <td>0.0</td>
  <td>0.0011</td>
  <td>1.075</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>itu_chipboard</td>
  <td>2.58</td>
  <td>0.0</td>
  <td>0.0217</td>
  <td>0.78</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>itu_plywood</td>
  <td>2.71</td>
  <td>0.0</td>
  <td>0.33</td>
  <td>0.0</td>
  <td>0.0</td>
  <td>40</td>
  <td></td>
</tr>
<tr>
  <td>itu_marble</td>
  <td>7.074</td>
  <td>0.0</td>
  <td>0.0055</td>
  <td>0.9262</td>
  <td>0.0</td>
  <td>60</td>
  <td></td>
</tr>
<tr>
  <td>itu_floorboard</td>
  <td>3.66</td>
  <td>0.0</td>
  <td>0.0044</td>
  <td>1.3515</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>itu_metal</td>
  <td>1.0</td>
  <td>0.0</td>
  <td>1.0e7</td>
  <td>0.0</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>itu_very_dry_ground</td>
  <td>3.0</td>
  <td>0.0</td>
  <td>0.00015</td>
  <td>2.52</td>
  <td>0.0</td>
  <td>10</td>
  <td></td>
</tr>
<tr>
  <td>itu_medium_dry_ground</td>
  <td>15.0</td>
  <td>-0.1</td>
  <td>0.035</td>
  <td>1.63</td>
  <td>0.0</td>
  <td>10</td>
  <td></td>
</tr>
<tr>
  <td>itu_wet_ground</td>
  <td>30.0</td>
  <td>-0.4</td>
  <td>0.15</td>
  <td>1.3</td>
  <td>0.0</td>
  <td>10</td>
  <td></td>
</tr>
<tr>
  <td>itu_vegetation</td>
  <td>1.0</td>
  <td>0.0</td>
  <td>1.0e-4</td>
  <td>1.1</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>irr_glass</td>
  <td>6.27</td>
  <td>0.0</td>
  <td>0.0043</td>
  <td>1.1925</td>
  <td>23.0</td>
  <td>100</td>
  <td></td>
</tr>
</table><br>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="point_cloud_aabb"></a>
<b>point_cloud_aabb</b> - Calculates the axis-aligned bounding box (AABB) for a 3D point cloud or a set of sub-clouds
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>The axis-aligned bounding box (AABB) of a set of points is the smallest bounding box whose edges 
are parallel to the Cartesian coordinate axes and that fully contains all points in the set. 
This function computes the AABB for either: 
<ul><li style="margin-bottom: 0.4em;">an entire point cloud, or 
</li><li style="margin-bottom: 0.4em;">multiple sub-clouds defined by their starting indices. 
</li></ul>
 
For each cloud, the function returns the minimum and maximum extents along the x, y, and z 
dimensions, producing a matrix where each row corresponds to one sub-cloud’s bounding box. When 
SIMD-friendly alignment is required, the output is zero-padded to the nearest multiple of vec_size; 
these padding rows should be ignored if the number of sub-clouds is known externally.<br><br> 
 
If a sub_cloud_index is provided, the last index is assumed to extend to the end of the 
points matrix. This functionality is particularly useful for preprocessing in geometry analysis, 
rendering pipelines, and spatial acceleration structures such as BVHs or octrees. Sub-clouds 
can be conveniently generated using <a href="#point_cloud_segmentation">point_cloud_segmentation</a>.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
from quadriga_lib import RTtools

aabb = RTtools.point_cloud_aabb( points, sub_cloud_ind, vec_size )
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>points</code></b><br> 
   Points in 3D-Cartesian space; Size: [ n_points, 3 ] 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>sub_cloud_ind</code></b> (optional)<br> 
   Start indices of the sub-clouds in 0-based notation. If this parameter is not given, the AABB of 
   the entire point cloud is returned. Vector of length <code>[ n_sub_cloud ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>vec_size</code></b> (optional)<br> 
   Vector size for SIMD processing (e.g. 8 for AVX2, 32 for CUDA). Default value = 1. For values > 1, 
   the number of rows in the output is increased to a multiple of <code>vec_size</code>, padded with zeros. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Argument:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>aabb</code></b><br> 
   Axis-aligned bounding box of each sub-cloud. Each box is described by 6 values: 
   <code>[ x_min, x_max, y_min, y_max, z_min, z_max ]</code>; Size: <code>[ n_sub_cloud, 6 ]</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>See also:</i></b><br><ul><li style="margin-bottom: 0.4em;"><a href="#point_cloud_segmentation">point_cloud_segmentation</a> (for calculating sub clouds) 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="point_cloud_segmentation"></a>
<b>point_cloud_segmentation</b> - Rearranges elements of a point cloud into smaller sub-clouds
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>This function processes a large 3D point cloud by clustering closely spaced points and recursively 
partitioning it into smaller sub-clouds, each below a specified size threshold. It minimizes the 
axis-aligned bounding box of each sub-cloud while striving to maintain a target number of points 
per cluster.<br><br> 
 
Sub-clouds are aligned to a specified SIMD vector size (e.g., for AVX or CUDA), with padding applied 
as needed. The function outputs a reorganized version of the input points (pointsR), where points 
are grouped by sub-cloud, and provides forward and reverse index maps to track the reordering. This 
organization is particularly useful for optimizing spatial processing tasks such as bounding volume 
hierarchies or GPU batch execution.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
from quadriga_lib import RTtools

# Output as tuple
data = RTtools.point_cloud_segmentation( points, target_size, vec_size )

# Unpacked outputs
points_out, sub_cloud_ind, forward_ind, reverse_ind = RTtools.point_cloud_segmentation( points, target_size, vec_size )
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>points</code></b><br> 
   Points in 3D-Cartesian space; Size: <code>[ n_points, 3 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>target_size</code></b> (optional)<br> 
   The target number of elements of each sub-cloud. Default value = 1024. For best performance, the 
   value should be around 10 * sgrt( n_points ) 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>vec_size</code></b> (optional)<br> 
   Vector size for SIMD processing (e.g. 8 for AVX2, 32 for CUDA). Default value = 1. 
   For values > 1,the number of rows for each sub-cloud in the output is increased to a multiple 
   of <code>vec_size</code>. For padding, zero-sized triangles are placed at the center of the AABB of 
   the corresponding sub-cloud. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>points_out</code></b>, <code>data[0]</code><br> 
   Points in 3D-Cartesian space; singe or double precision;  Size: <code>[ n_points_out, 3 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>sub_cloud_ind</code></b>, <code>data[1]</code><br> 
   Start indices of the sub-clouds in 0-based notation. Type: uint32; Vector of length <code>[ n_sub_cloud ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>forward_ind</code></b>, <code>data[2]</code><br> 
   Indices for mapping elements of "points_in" to "points_out"; 1-based; 
   Length: <code>[ n_points_out ]</code>; For <code>vec_size &gt; 1</code>, the added elements not contained in the input 
   are indicated by zeros. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>reverse_ind</code></b>, <code>data[3]</code><br> 
   Indices for mapping elements of "points_out" to "points"; 0-based; Length: <code>[ n_points ]</code> 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="point_inside_mesh"></a>
<b>point_inside_mesh</b> - Test whether 3D points are inside a triangle mesh using raycasting
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Uses raycasting to determine whether each 3D point lies inside a triangle mesh. 
</li><li style="margin-bottom: 0.4em;">Requires that the mesh is watertight and all normals are pointing outwards. 
</li><li style="margin-bottom: 0.4em;">For each point, multiple rays are cast in various directions. 
</li><li style="margin-bottom: 0.4em;">If any ray intersects a mesh element with a negative incidence angle, the point is classified as <b>inside</b>. 
</li><li style="margin-bottom: 0.4em;">Output can be binary (0 = outside, 1 = inside) or labeled with object indices. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
from quadriga_lib import RTtools
result = RTtools.point_inside_mesh( points, mesh, obj_ind, distance )
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code><b>points</b></code> (input)<br> 
   3D point coordinates to test, size <code>[n_points, 3]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code><b>mesh</b></code> (input)<br> 
   Triangular mesh faces. Each row represents a triangle using 3 vertices in row-major format 
   (x1,y1,z1,x2,y2,z2,x3,y3,z3), size <code>[n_mesh, 9]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code><b>obj_ind</b></code> (optional input)<br> 
   Optional object index for each mesh element (1-based), size <code>[n_mesh]</code>. If provided, the return 
   vector will contain the index of the enclosing object instead of binary values. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><code><b>distance</b></code> (optional input)<br> 
   Optional distance in meters from objects that should be considered as <i>inside</i> the object. 
   Possible range: 0 - 20 m. Using this parameter significantly increases computation time. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code><b>result</b></code><br> 
   For each point: Returns <code>0</code> if the point is outside the mesh (or all objects), <code>1</code> if inside 
   (or close to) any mesh object (if <code>obj_ind</code> not given), or returns the <b>1-based object index</b> 
   if <code>obj_ind</code> is provided. Size: <code>[n_points]</code> 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="ray_point_intersect"></a>
<b>ray_point_intersect</b> - Calculates which 3D points are intersected by volumetric ray beams
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>Unlike traditional ray tracing (rays are infinitesimal lines), <b>beam tracing</b> models rays as 
volumes. Each beam is defined by a triangular wavefront whose three vertices diverge as the 
beam propagates, capturing real-world spread (e.g., radio-wave divergence) and enabling realistic 
energy distribution across the beam’s cross-section. Because beams have volume, intersection tests 
are volumetric rather than line-to-geometry.<br><br> 
 
A ray beam is specified by: 
<ul><li style="margin-bottom: 0.4em;">An origin point. 
</li><li style="margin-bottom: 0.4em;">Three aperture vectors from the origin to the vertices of an initial triangular wavefront 
   that defines the beam’s cross-section at the origin. 
</li><li style="margin-bottom: 0.4em;">Three per-vertex direction vectors (one per vertex) that govern how each vertex, and thus the 
   triangle, diverges as the beam extends. Directions need not be normalized.<br><br> 
</li></ul>
 
What the function does 
<ul><li style="margin-bottom: 0.4em;">Tests whether each point in a 3D Cartesian point cloud lies inside any of the defined ray beams. 
</li><li style="margin-bottom: 0.4em;">For every input point, returns a list of 0-based ray indices of beams that intersect that point.<br><br> 
</li></ul>
 
Performance & usage notes 
<ul><li style="margin-bottom: 0.4em;">Optional support for pre-segmented point clouds (e.g., from <a href="#point_cloud_segmentation">point_cloud_segmentation</a>) to reduce computation. 
</li><li style="margin-bottom: 0.4em;">All internal computations use single-precision floats for speed. 
</li><li style="margin-bottom: 0.4em;">Utilizes AVX2 vectorization when supported by the CPU. 
</li><li style="margin-bottom: 0.4em;">For best accuracy, use a small tube radius and well-distributed points. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
from quadriga_lib import RTtools

hit_count, ray_ind = RTtools.ray_point_intersect( orig, trivec, tridir, points, sub_cloud_ind, target_size )
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>orig</code></b><br> 
   Ray origins in 3D Cartesian coordinates; Shape: <code>(n_ray, 3)</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>trivec</code></b><br> 
   Three vectors from each ray’s origin to the vertices of the triangular propagation tube (beam); 
   Order per row: [v1x, v1y, v1z, v2x, v2y, v2z, v3x, v3y, v3z]; Shape: <code>(n_ray, 9)</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>tridir</code></b><br> 
   Directions of the three vertex rays in Cartesian coordinates. Normalization not required. 
   Order per row: [d1x, d1y, d1z, d2x, d2y, d2z, d3x, d3y, d3z]; Shape: <code>(n_ray, 9)</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>points</code></b><br> 
   3D Cartesian coordinates of the point cloud to test. Shape: <code>(n_points, 3)</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>sub_cloud_ind</code></b> (optional)<br> 
   0-based start indices of sub-clouds used to partition points for performance. If not provided 
   (empty array), sub-clouds may be computed automatically. Passing a scalar 0 disables sub-cloud calculation. 
   Shape: (n_sub_cloud,) (strictly increasing; typically starts with 0) 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>target_size</code></b> (optional)<br> 
   Desired sub-cloud size used only if <code>sub_cloud_ind</code> is not given or empty (guides automatic segmentation). 
   If it is not given (set to 0) and <code>sub_cloud_ind</code> is empty or also not given, the optimal valued is computed  
   from the number of points. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>hit_count</code></b><br> 
   Number of ray beams that hit a point. Shape: <code>(n_points, )</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>ray_ind</code></b><br> 
   List of length n_points; each list entry is a 1-D array of 0-based ray indices that hit that point. 
   Entries may be empty if no hit was detected. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>See also:</i></b><br><ul><li style="margin-bottom: 0.4em;"><a href="#icosphere">icosphere</a> (for generating beams) 
</li><li style="margin-bottom: 0.4em;"><a href="#point_cloud_segmentation">point_cloud_segmentation</a> (for generating point cloud segments) 
</li><li style="margin-bottom: 0.4em;"><a href="#ray_triangle_intersect">ray_triangle_intersect</a> (for calculating intersection of rays and triangles) 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="ray_triangle_intersect"></a>
<b>ray_triangle_intersect</b> - Calculates the intersection of rays and triangles in three dimensions
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">This function implements the Möller–Trumbore ray-triangle intersection algorithm, known for its 
   efficiency in calculating the intersection of a ray and a triangle in three-dimensional space. 
   This method achieves its speed by eliminating the need for precomputed plane equations of the plane 
   containing the triangle. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;">For further information, refer to [Wikipedia: <a href="https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm">Möller–Trumbore intersection algorithm</a>]. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;">The algorithm defines the ray using two points: an origin and a destination. Similarly, the triangle 
   is specified by its three vertices. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;">To enhance performance, this implementation leverages AVX2 intrinsic functions and OpenMP, when 
   available, to speed up the computational process. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
from quadriga_lib import RTtools

# Output as tuple
data = RTtools.ray_triangle_intersect( orig, dest, mesh, sub_mesh_index )

# Unpacked outputs
fbs, sbs, no_interact, fbs_ind, sbs_ind = RTtools.ray_triangle_intersect( orig, dest, mesh, sub_mesh_index )
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>orig</code></b><br> 
   Ray origins in 3D Cartesian coordinates; Size: <code>[ no_ray, 3 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>dest</code></b><br> 
   Ray destinations in 3D Cartesian coordinates; Size: <code>[ no_ray, 3 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>mesh</code></b><br> 
   Vertices of the triangular mesh in global Cartesian coordinates. Each face is described by 3 points 
   in 3D-space. Hence, a face has 9 values in the order [ v1x, v1y, v1z, v2x, v2y, v2z, v3x, v3y, v3z ];  
   Size: <code>[ no_mesh, 9 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>sub_mesh_index</code></b> (optional)<br> 
   Start indices of the sub-meshes in 0-based notation. If this parameter is not given, intersections 
   are calculated for each mesh element, leading to poor performance for large meshes. 
   Vector of length <code>[ n_sub_mesh ]</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>fbs</code></b>, <code>data[0]</code><br> 
   First interaction point between the rays and the triangular mesh. If no interaction was found, the 
   FBS location is equal to <code>dest</code>. Size: <code>[ no_ray, 3 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>sbs</code></b>, <code>data[1]</code><br> 
   Second interaction point between the rays and the triangular mesh. If no interaction was found, the 
   SBS location is equal to <code>dest</code>. Size: <code>[ no_ray, 3 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>no_interact</code></b>, <code>data[2]</code><br> 
   Total number of interactions between the origin point and the destination; uint32; Length: <code>[ no_ray ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>fbs_ind</code></b>, <code>data[3]</code><br> 
   Index of the triangle that was hit by the ray at the FBS location; 1-based; uint32; Length: <code>[ no_ray ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>sbs_ind</code></b>, <code>data[4]</code><br> 
   Index of the triangle that was hit by the ray at the SBS location; 1-based; uint32; Length: <code>[ no_ray ]</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Caveat:</i></b><br><ul><li style="margin-bottom: 0.4em;">All internal computation are done in single precision to achieve an additional 2x improvement in 
   speed compared to double precision when using AVX2 intrinsic instructions 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>See also:</i></b><br><ul><li style="margin-bottom: 0.4em;"><a href="#obj_file_read">obj_file_read</a> (for loading mesh from an OBJ file) 
</li><li style="margin-bottom: 0.4em;"><a href="#icosphere">icosphere</a> (for generating beams) 
</li><li style="margin-bottom: 0.4em;"><a href="#triangle_mesh_segmentation">triangle_mesh_segmentation</a> (for calculating sub-meshes) 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="triangle_mesh_aabb"></a>
<b>triangle_mesh_aabb</b> - Calculate the axis-aligned bounding box (AABB) of a triangle mesh and its sub-meshes
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>The axis-aligned minimum bounding box (or AABB) for a given set of triangles is its minimum 
bounding box subject to the constraint that the edges of the box are parallel to the (Cartesian) 
coordinate axes. Axis-aligned bounding boxes are used as an approximate location of the set of 
triangles. In order to find intersections with the triangles (e.g. using ray tracing), the 
initial check is the intersections between the rays and the AABBs. Since it is usually a much 
less expensive operation than the check of the actual intersection (because it only requires 
comparisons of coordinates), it allows quickly excluding checks of the pairs that are far apart.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
from quadriga_lib import RTtools

aabb = RTtools.triangle_mesh_aabb( triangle_mesh, sub_mesh_index, vec_size );
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>triangle_mesh</code></b><br> 
   Vertices of the triangle mesh in global Cartesian coordinates. Each face is described by 3 
   points in 3D-space: <code>[ v1x, v1y, v1z, v2x, v2y, v2z, v3x, v3y, v3z ]</code>; Size: <code>[ n_triangles, 9 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>sub_mesh_index</code></b> (optional)<br> 
   Start indices of the sub-meshes in 0-based notation. If this parameter is not given, the AABB of 
   the entire triangle mesh is returned. Vector of length <code>[ n_sub_mesh ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>vec_size</code></b> (optional)<br> 
   Vector size for SIMD processing (e.g. 8 for AVX2, 32 for CUDA). Default value = 1. For values > 1, 
   the number of rows in the output is increased to a multiple of <code>vec_size</code>, padded with zeros. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Argument:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>aabb</code></b><br> 
   Axis-aligned bounding box of each sub-mesh. Each box is described by 6 values: 
   <code>[ x_min, x_max, y_min, y_max, z_min, z_max ]</code>; Size: <code>[ n_sub_mesh, 6 ]</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>See also:</i></b><br><ul><li style="margin-bottom: 0.4em;"><a href="#triangle_mesh_segmentation">triangle_mesh_segmentation</a> (for calculating sub-meshes) 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="triangle_mesh_segmentation"></a>
<b>triangle_mesh_segmentation</b> - Rearranges elements of a triangle mesh into smaller sub-meshes
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>This function processes the elements of a large triangle mesh by clustering those that are 
closely spaced. The resulting mesh retains the same elements but rearranges their order. 
The function aims to minimize the size of the axis-aligned bounding box around each cluster, 
referred to as a sub-mesh, while striving to maintain a specific number of elements within 
each cluster.<br><br> 
 
This approach is particularly useful in computer graphics and simulation applications where 
managing computational resources efficiently is crucial. By organizing the mesh elements into 
compact clusters, the function enhances rendering performance and accelerates computational 
tasks, such as collision detection and physics simulations. It allows for quicker processing 
and reduced memory usage, making it an essential technique in both real-time graphics rendering 
and complex simulation environments.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
from quadriga_lib import RTtools

# Output as tuple
data = RTtools.triangle_mesh_segmentation( triangles, target_size, vec_size, mtl_prop )

# Unpacked outputs
triangles_out, sub_mesh_index, mesh_index, mtl_prop_out = RTtools.triangle_mesh_segmentation( triangles, target_size, vec_size, mtl_prop )
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>triangles</code></b><br> 
   Vertices of the triangular mesh in global Cartesian coordinates. Each face is described by 3 
   points in 3D-space: <code>[ v1x, v1y, v1z, v2x, v2y, v2z, v3x, v3y, v3z ]</code>; Size: <code>[ n_triangles, 9 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>target_size</code></b> (optional)<br> 
   The target number of elements of each sub-mesh. Default value = 1024. For best performance, the 
   value should be around <code>sgrt( n_triangles )</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>vec_size</code></b> (optional)<br> 
   Vector size for SIMD processing (e.g. 8 for AVX2, 32 for CUDA). Default value = 1. 
   For values > 1,the number of rows for each sub-mesh in the output is increased to a multiple 
   of <code>vec_size</code>. For padding, zero-sized triangles are placed at the center of the AABB of 
   the corresponding sub-mesh. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>mtl_prop_in</code></b> (optional)<br> 
   Material properties of each mesh element; Size: <code>[ n_triangles, 5 ]</code> 
   If this is not provided, the corresponding <code>mtl_prop_out</code> will be empty. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>triangles_out</code></b>, <code>data[0]</code><br> 
   Vertices of the clustered mesh in global Cartesian coordinates; Size: <code>[ n_triangles_out, 9 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>sub_mesh_index</code></b>, <code>data[1]</code><br> 
   Start indices of the sub-meshes in 0-based notation. Type: int; Vector of length <code>[ n_sub_mesh ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>mesh_index</code></b>, <code>data[2]</code><br> 
   Indices for mapping elements of "triangles_in" to "triangles_out"; 1-based; 
   Length: <code>[ n_triangles_out ]</code>; For <code>vec_size &gt; 1</code>, the added elements not contained in the input 
   are indicated by zeros. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>mtl_prop_out</code></b>, <code>data[3]</code><br> 
   Material properties for the sub-divided triangle mesh elements. The values for the new faces are 
   copied from <code>mtl_prop_in</code>; Size: <code>[ n_triangles_out, 5 ]</code>; For <code>vec_size &gt; 1</code>, the added elements 
   will contain the vacuum / air material. 
</li></ul>
</li>
</ul>
    <!-- CONTENT END -->

    <br>
    <!-- <br> -->

    <div id="quadriga-lib_sf_line"></div>

  </div>

</body>

</html>