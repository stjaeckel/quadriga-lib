<!DOCTYPE html>
<html>

<head>
  <meta content="text/html;" http-equiv="Content-Type">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" href="img/quadriga-lib-q_letter64.png" type="image/png">
  <link type="text/css" rel="stylesheet" href="style2.css">
  <title>Quadriga-Lib: C++/MEX Utility library for radio channel modelling and simulations</title>
</head>
 
<body>

  <div id="quadriga-lib_header">
    <div id="quadriga-lib_header_row">
      <div id="quadriga-lib_header_cell_logo_img">
        <a href="https://arma.sourceforge.net">
          <img id="quadriga-lib_logo_img" src="img/quadriga-lib-logo80.png" alt="armadillo" align="top" border="0">
        </a>
      </div>
      <div id="quadriga-lib_header_spacer"></div>
      <div id="quadriga-lib_header_cell_logo_txt">
        <div id="quadriga-lib_logo_img2"></div><big><big><b>Quadriga-Lib</b>
          </big><br>C++/MEX Utility library for radio channel modelling and simulations</big>
      </div>
    </div>
  </div>

  <div id="quadriga-lib_menu">
    <ul class="quadriga-lib_menu">
      <li class="quadriga-lib_menu"><a class="quadriga-lib_menu" href="index.html">About</a></li>
      <li class="quadriga-lib_menu"><a class="quadriga-lib_menu" href="cpp_api.html">C++ API</a></li>
      <li class="quadriga-lib_menu"><a class="quadriga-lib_menu" href="mex_api.html">MATLAB API</a></li>
      <li class="quadriga-lib_menu"><a class="quadriga-lib_menu_selected" href="python_api.html">Python API</a></li>
      <li class="quadriga-lib_menu"><a class="quadriga-lib_menu" href="formats.html">Data Formats</a></li>
      <li class="quadriga-lib_menu"><a class="quadriga-lib_menu" href="faq.html">Questions</a></li>
      <li class="quadriga-lib_menu"><a class="quadriga-lib_menu" href="contact.html">Contact</a></li>
      <li class="quadriga-lib_menu"><a class="quadriga-lib_menu" href="download.html">Download</a></li>
    </ul>
  </div>

  <div id="quadriga-lib_content">

      <!-- CONTENT BEGIN --><big><b>Python API Documentation for Quadriga-Lib</b></big>
<br><br><br>

<b>Notes:</b>
<br>

<ul>
<li>The Quadriga-Lib Python interface of implemented using pybind11. 
Before getting started, make sure that the Python library is compiled for your system and python environment.</li>
<br>
<li>Unless otherwise stated, the Quadriga-Lib Python API reads and writes data to and from Numpy arrays in 
    double precision. Hence, you need to have numpy installed and imported in your python file.</li>
<br>    
<li>There is currently no Microsoft Windows version of the Quadriga-Lib Python interface.
    This os planned for a later stage.</li>
<br>    
<li>The Quadriga-Lib Python package is compiled into a single ".so" file located in the "lib" folder. 
To import it in Python, the "lib" folder must be on your Python path, which is usually not the case
unless you install a package using pip or conda. To import the "quadriga_lib" from a custom location,
you can do the following:
<pre>
import sys
import numpy as np

sys.path.append("/path_to/quadriga-lib/lib")
import quadriga_lib
</pre></li>


</ul>

<br> 
<b>Overview</b>
<ul>
<li><a href="#part_1">Array antenna functions</a></li>
<li><a href="#part_2">Channel functions</a></li>
<li><a href="#part_3">Miscellaneous / Tools</a></li>
<li><a href="#part_4">Site-Specific Simulation Tools</a></li>
</ul>
<br>
<a name="part_1"></a>
<b>Array antenna functions</b>
<ul>
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tbody>
<tr><td><a href="#arrayant_export_obj_file">arrayant_export_obj_file</a></td><td>Creates a Wavefront OBJ file for visualizing the shape of the antenna pattern</td></tr>
<tr><td><a href="#arrayant_qdant_read">arrayant_qdant_read</a></td><td>Reads array antenna data from QDANT files</td></tr>
</tbody>
</table>
</ul>
<br>
<a name="part_2"></a>
<b>Channel functions</b>
<ul>
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tbody>
<tr><td><a href="#baseband_freq_response">baseband_freq_response</a></td><td>Transforms the channel into frequency domain and returns the frequency response</td></tr>
<tr><td><a href="#hdf5_create_file">hdf5_create_file</a></td><td>Create a new HDF5 channel file with a custom storage layout</td></tr>
<tr><td><a href="#hdf5_read_channel">hdf5_read_channel</a></td><td>Reads channel data from HDF5 files</td></tr>
<tr><td><a href="#hdf5_read_dset_names">hdf5_read_dset_names</a></td><td>Read the names of unstructured data fields from an HDF5 file</td></tr>
<tr><td><a href="#hdf5_read_layout">hdf5_read_layout</a></td><td>Read the storage layout of channel data inside an HDF5 file</td></tr>
<tr><td><a href="#hdf5_reshape_layout">hdf5_reshape_layout</a></td><td>Reshapes the storage layout inside an existing HDF5 file</td></tr>
<tr><td><a href="#hdf5_write_channel">hdf5_write_channel</a></td><td>Writes channel data to HDF5 files</td></tr>
<tr><td><a href="#hdf5_write_dset">hdf5_write_dset</a></td><td>Writes unstructured data to a HDF5 file</td></tr>
</tbody>
</table>
</ul>
<br>
<a name="part_3"></a>
<b>Miscellaneous / Tools</b>
<ul>
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tbody>
<tr><td><a href="#cart2geo">cart2geo</a></td><td>Transform Cartesian (x,y,z) coordinates to Geographic (az, el, length) coordinates</td></tr>
<tr><td><a href="#version">version</a></td><td>Returns the quadriga-lib version number</td></tr>
</tbody>
</table>
</ul>
<br>
<a name="part_4"></a>
<b>Site-Specific Simulation Tools</b>
<ul>
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tbody>
<tr><td><a href="#icosphere">icosphere</a></td><td>Construct a geodesic polyhedron (icosphere), a convex polyhedron made from triangles</td></tr>
</tbody>
</table>
</ul>
<br>
<div class="pagebreak"></div>
<hr class="greyline">
<hr class="greyline">
<br>
<br>
<font size=+1><b>Array antenna functions</b></font>
<br>
<br>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="arrayant_export_obj_file"></a>
<b>arrayant_export_obj_file</b> - Creates a Wavefront OBJ file for visualizing the shape of the antenna pattern
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
quadriga_lib.arrayant_export_obj_file( fn, directivity_range, colormap, object_radius, icosphere_n_div, 
    e_theta, e_phi, azimuth_grid, elevation_grid, element_pos, name, i_element )
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>fn</code></b><br> 
   Filename of the OBJ file, string 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>directivity_range</code></b><br> 
   Directivity range of the antenna pattern visualization in dB 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>colormap</code></b><br> 
   Colormap for the visualization, string, supported are 'jet', 'parula', 'winter', 'hot', 'turbo',  
   'copper', 'spring', 'cool', 'gray', 'autumn', 'summer'  
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>object_radius</code></b><br> 
   Radius in meters of the exported object 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>icosphere_n_div</code></b><br> 
   Map pattern to an Icosphere with given number of subdivisions 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>e_theta</code></b><br> 
   e-theta field component, complex-valued, Size: <code>[n_elevation, n_azimuth, n_elements]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>e_phi</code></b><br> 
   e-phi field component, complex-valued, Size: <code>[n_elevation, n_azimuth, n_elements]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>azimuth_grid</code></b><br> 
   Azimuth angles in [rad] -pi to pi, sorted, Size: <code>[n_azimuth]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>elevation_grid</code></b><br> 
   Elevation angles in [rad], -pi/2 to pi/2, sorted, Size: <code>[n_elevation]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>element_pos</code></b><br> 
   Antenna element (x,y,z) positions, Size: <code>[3, n_elements]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>name</code></b><br> 
   Name of the array antenna object 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>i_element</code></b><br> 
   Antenna element indices, 0-based, empty = export all 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="arrayant_qdant_read"></a>
<b>arrayant_qdant_read</b> - Reads array antenna data from QDANT files
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>The QuaDRiGa array antenna exchange format (QDANT) is a file format used to store antenna pattern 
data in XML. This function reads pattern data from the specified file.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
data = quadriga_lib.arrayant_qdant_read( fn, id )
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>fn</code></b><br> 
   Filename of the QDANT file, string 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>id</code></b> (optional)<br> 
   ID of the antenna to be read from the file, optional, Default: Read first 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>data</code></b><br> 
   Dictionary containing the data in the QDANT file with the following keys: 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>e_theta</code></td>
  <td>e-theta field component, complex-valued</td>
  <td>Size: <code>[n_elevation, n_azimuth, n_elements]</code></td>
</tr>
<tr>
  <td><code>e_phi</code></td>
  <td>e-phi field component, complex-valued</td>
  <td>Size: <code>[n_elevation, n_azimuth, n_elements]</code></td>
</tr>
<tr>
  <td><code>azimuth_grid</code></td>
  <td>Azimuth angles in [rad] -pi to pi, sorted</td>
  <td>Size: <code>[n_azimuth]</code></td>
</tr>
<tr>
  <td><code>elevation_grid</code></td>
  <td>Elevation angles in [rad], -pi/2 to pi/2, sorted</td>
  <td>Size: <code>[n_elevation]</code></td>
</tr>
<tr>
  <td><code>element_pos</code></td>
  <td>Antenna element (x,y,z) positions, optional</td>
  <td>Size: <code>[3, n_elements]</code></td>
</tr>
<tr>
  <td><code>coupling</code></td>
  <td>Coupling matrix, complex valued</td>
  <td>Size: <code>[n_elements, n_ports]</code></td>
</tr>
<tr>
  <td><code>center_freq</code></td>
  <td>Center frequency in [Hz], optional, default = 0.3 GHz</td>
  <td>Scalar</td>
</tr>
<tr>
  <td><code>name</code></td>
  <td>Name of the array antenna object</td>
  <td>String</td>
</tr>
<tr>
  <td><code>layout</code></td>
  <td>Layout of multiple array antennas.</td>
  <td>Matrix</td>
</tr>
</table><br>
</li></ul>
</li>
</ul>
<div class="pagebreak"></div>
<hr class="greyline">
<hr class="greyline">
<br>
<br>
<font size=+1><b>Channel functions</b></font>
<br>
<br>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="baseband_freq_response"></a>
<b>baseband_freq_response</b> - Transforms the channel into frequency domain and returns the frequency response
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
hmat = quadriga_lib.baseband_freq_response( coeff, delay, bandwidth, carriers, pilot_grid, snap );
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>coeff</code></b><br> 
   Channel coefficients, complex-valued, Size: <code>[ n_rx, n_tx, n_path, n_snap ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>delay</code></b><br> 
   Propagation delay in seconds, Size: <code>[ n_rx, n_tx, n_path, n_snap ]</code> or <code>[ 1, 1, n_path, n_snap ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>bandwidth</code></b><br> 
   The baseband bandwidth in [Hz], scalar 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>carriers</code></b> (optional)<br> 
   Number of carriers, equally spaced across the bandwidth. The first entry of the generated spectrum  
   is equal to the center frequency f0. The spectrum is generated from f0 to f0+bandwidth. This 
   argument is only evaluated if <code>pilot_grid</code> is not provided. Default value = 128 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>pilot_grid</code></b> (optional)<br> 
   Sub-carrier positions relative to the bandwidth. The carrier positions are given relative to the 
   bandwidth where '0' is the begin of the spectrum (i.e., the center frequency f0) and '1' is 
   equal to f0+bandwidth. To obtain the channel frequency response centered around f0, the 
   input variable 'pilot_grid' must be set to '(-N/2:N/2)/N', where N is the number of sub- 
   carriers. Vector of length: <code>[ n_carriers ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>snap</code></b> (optional)<br> 
   Snapshot indices for which the frequency response should be generated (1-based index). If this 
   variable is not given, all snapshots are processed. Length: <code>[ n_out ]</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Argument:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>hmat</code></b><br> 
   Freq. domain channel matrices (H), complex-valued, Size <code>[ n_rx, n_tx, n_carriers, n_out ]</code> 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="hdf5_create_file"></a>
<b>hdf5_create_file</b> - Create a new HDF5 channel file with a custom storage layout
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>Quadriga-Lib offers an HDF5-based method for storing and managing channel data. A key feature of this 
library is its ability to organize multiple channels within a single HDF5 file while enabling access 
to individual data sets without the need to read the entire file. In this system, channels can be 
structured in a multi-dimensional array. For instance, the first dimension might represent the Base 
Station (BS), the second the User Equipment (UE), and the third the frequency. However, it is important 
to note that the dimensions of the storage layout must be defined when the file is initially created 
and cannot be altered thereafter. The function <code>quadriga_lib.hdf5_create_file</code> is used to create an 
empty file with a predetermined custom storage layout.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
quadriga_lib.hdf5_create_file( fn, nx, ny, nz, nw )
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>fn</code></b><br> 
   Filename of the HDF5 file, string 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>nx</code></b> (optional)<br> 
   Number of elements on the x-dimension, Default = 65536 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>ny</code></b> (optional)<br> 
   Number of elements on the x-dimension, Default = 1 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>nz</code></b> (optional)<br> 
   Number of elements on the x-dimension, Default = 1 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>nw</code></b> (optional)<br> 
   Number of elements on the x-dimension, Default = 1 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="hdf5_read_channel"></a>
<b>hdf5_read_channel</b> - Reads channel data from HDF5 files
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>Quadriga-Lib provides an HDF5-based solution for storing and organizing channel data. This data 
comprises various well-defined sets, including channel coefficients, positions of transmitters and 
receivers, as well as path data that reflects the interaction of radio waves with the environment. 
Typically, these datasets are multi-dimensional, encompassing data for <code>n_rx</code> receive antennas, 
<code>n_tx</code> transmit antennas, <code>n_path</code> propagation paths, and <code>n_snap</code> snapshots. Snapshots are 
particularly useful for recording data across different locations (such as along a trajectory) or 
various frequencies. It is important to note that not all datasets include all these dimensions.<br><br> 
 
The library also supports the addition of extra datasets of any type or shape, which can be useful 
for incorporating descriptive data or analysis results. To facilitate data access, the function 
<code>quadriga_lib.hdf5_read_channel</code> is designed to read both structured and unstructured data from the 
file.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
data = quadriga_lib.hdf5_read_channel( fn, ix, iy, iz, iw, snap );
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>fn</code></b><br> 
   Filename of the HDF5 file, string 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>ix</code></b><br> 
   Storage index for x-dimension, Default = 0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>iy</code></b><br> 
   Storage index for y-dimension, Default = 0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>iz</code></b><br> 
   Storage index for z-dimension, Default = 0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>iw</code></b><br> 
   Storage index for w-dimension, Default = 0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>snap</code></b> (optional)<br> 
   Snapshot range, 0-based notation; optional; vector, default: empty = read all 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>data</code></b><br> 
   Dictionary containing the data in the HDF file with the following keys: 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>par</code></td>
  <td>Dictionary of unstructured data</td>
  <td>Variable</td>
</tr>
<tr>
  <td><code>rx_position</code></td>
  <td>Receiver positions</td>
  <td><code>[3, n_snap]</code> or <code>[3, 1]</code></td>
</tr>
<tr>
  <td><code>tx_position</code></td>
  <td>Transmitter positions</td>
  <td><code>[3, n_snap]</code> or <code>[3, 1]</code></td>
</tr>
<tr>
  <td><code>coeff</code></td>
  <td>Channel coefficients, complex valued</td>
  <td><code>[n_rx, n_tx, n_path, n_snap]</code></td>
</tr>
<tr>
  <td><code>delay</code></td>
  <td>Propagation delays in seconds</td>
  <td><code>[n_rx, n_tx, n_path, n_snap]</code> or <code>[1, 1, n_path, n_snap]</code></td>
</tr>
<tr>
  <td><code>center_freq</code></td>
  <td>Center frequency in [Hz]</td>
  <td><code>[n_snap, 1]</code> or scalar</td>
</tr>
<tr>
  <td><code>name</code></td>
  <td>Name of the channel</td>
  <td>String</td>
</tr>
<tr>
  <td><code>initial_pos</code></td>
  <td>Index of reference position, 0-based</td>
  <td>uint32, scalar</td>
</tr>
<tr>
  <td><code>path_gain</code></td>
  <td>Path gain before antenna, linear scale</td>
  <td><code>[n_path, n_snap]</code></td>
</tr>
<tr>
  <td><code>path_length</code></td>
  <td>Path length from TX to RX phase center in m</td>
  <td><code>[n_path, n_snap]</code></td>
</tr>
<tr>
  <td><code>polarization</code></td>
  <td>Polarization transfer function, complex valued</td>
  <td><code>[4, n_path, n_snap]</code></td>
</tr>
<tr>
  <td><code>path_angles</code></td>
  <td>Departure and arrival angles {AOD, EOD, AOA, EOA} in rad</td>
  <td><code>[n_path, 4, n_snap]</code></td>
</tr>
<tr>
  <td><code>path_fbs_pos</code></td>
  <td>First-bounce scatterer positions</td>
  <td><code>[3, n_path, n_snap]</code></td>
</tr>
<tr>
  <td><code>path_lbs_pos</code></td>
  <td>Last-bounce scatterer positions</td>
  <td><code>[3, n_path, n_snap]</code></td>
</tr>
<tr>
  <td><code>no_interact</code></td>
  <td>Number interaction points of paths with the environment</td>
  <td>uint32, <code>[n_path, n_snap]</code></td>
</tr>
<tr>
  <td><code>interact_coord</code></td>
  <td>Interaction coordinates</td>
  <td><code>[3, max(sum(no_interact)), n_snap]</code></td>
</tr>
<tr>
  <td><code>rx_orientation</code></td>
  <td>Transmitter orientation</td>
  <td><code>[3, n_snap]</code> or <code>[3, 1]</code></td>
</tr>
<tr>
  <td><code>tx_orientation</code></td>
  <td>Receiver orientation</td>
  <td><code>[3, n_snap]</code> or <code>[3, 1]</code></td>
</tr>
</table><br>
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Caveat:</i></b><br><ul><li style="margin-bottom: 0.4em;">Only datasets that are present in the HDF file are returned in the dictionary. 
</li><li style="margin-bottom: 0.4em;">Although the data is stored in single precision, it is converted to double precision by default. 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="hdf5_read_dset_names"></a>
<b>hdf5_read_dset_names</b> - Read the names of unstructured data fields from an HDF5 file
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>Quadriga-Lib offers a solution based on HDF5 for storing and organizing channel data. In addition 
to structured datasets, the library facilitates the inclusion of extra datasets of various types 
and shapes. This feature is particularly beneficial for integrating descriptive data or analysis 
results. Users can add any number of such unstructured datasets, each identified by a unique 
dataset name. The function <code>quadriga_lib.hdf5_read_dset_names</code> retrieves the names of all these 
datasets, returning them as a list of strings.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
names = quadriga_lib.hdf5_read_dset_names( fn, ix, iy, iz, iw );
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>fn</code></b><br> 
   Filename of the HDF5 file, string 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>ix</code></b><br> 
   Storage index for x-dimension, Default = 0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>iy</code></b><br> 
   Storage index for y-dimension, Default = 0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>iz</code></b><br> 
   Storage index for z-dimension, Default = 0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>iw</code></b><br> 
   Storage index for w-dimension, Default = 0 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Argument:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>names</code></b><br> 
   List of names of all these at the given location in the files; Cell array of strings 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="hdf5_read_layout"></a>
<b>hdf5_read_layout</b> - Read the storage layout of channel data inside an HDF5 file
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>Quadriga-Lib provides an HDF5-based solution for the storage and organization of channel data. A 
notable feature of this library is its capacity to manage multiple channels within a single HDF5 
file. In this framework, channels can be arranged in a multi-dimensional array format. 
 
The function <code>quadriga_lib.hdf5_read_layout</code> is designed to read the storage layout from an 
existing file. Furthermore, it also generates an array that marks the locations within the layout 
where data already exists. This functionality aids in efficiently managing and accessing channel 
data within the HDF5 file structure.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
storage_dims, has_data = quadriga_lib.hdf5_read_layout( fn )
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Argument:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>fn</code></b><br> 
   Filename of the HDF5 file, string 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>storage_dims</code></b><br> 
   Size of the dimensions of the storage space, vector with 4 elements, i.e. <code>[nx,ny,nz,nw]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>has_data</code></b><br> 
   Array indicating if data exists (value 1) or not (value 0); uint32; Size: <code>[nx,ny,nz,nw]</code> 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="hdf5_reshape_layout"></a>
<b>hdf5_reshape_layout</b> - Reshapes the storage layout inside an existing HDF5 file
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>Quadriga-Lib provides an HDF5-based solution for the storage and organization of channel data. A  
notable feature of this library is its capacity to manage multiple channels within a single HDF5  
file. In this framework, channels can be arranged in a multi-dimensional array format. 
Once an HDF5 file has been created, the number of channels in the storage layout is fixed.  
However, it is possible to reshape the layout using <code>quadriga_lib.hdf5_reshape_layout</code>.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
quadriga_lib.hdf5_reshape_layout( fn, storage_dims );
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>fn</code></b><br> 
   Filename of the HDF5 file, string 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>nx</code></b> (optional)<br> 
   Number of elements on the x-dimension, Default = 65536 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>ny</code></b> (optional)<br> 
   Number of elements on the x-dimension, Default = 1 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>nz</code></b> (optional)<br> 
   Number of elements on the x-dimension, Default = 1 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>nw</code></b> (optional)<br> 
   Number of elements on the x-dimension, Default = 1 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="hdf5_write_channel"></a>
<b>hdf5_write_channel</b> - Writes channel data to HDF5 files
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>Quadriga-Lib provides an HDF5-based solution for storing and organizing channel data. This function 
can be used to write structured and unstructured data to an HDF5 file.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
storage_dims = quadriga_lib.hdf5_write_channel( fn, ix, iy, iz, iw, rx_position, tx_position, ...
   coeff_re, coeff_im, delay, center_freq, name, initial_pos, path_gain, path_length, ...
   path_polarization, path_angles, path_fbs_pos, path_lbs_pos, no_interact, interact_coord, ...
   rx_orientation, tx_orientation )
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>fn</code></b><br> 
   Filename of the HDF5 file, string 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>ix</code></b><br> 
   Storage index for x-dimension, Default = 0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>iy</code></b><br> 
   Storage index for y-dimension, Default = 0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>iz</code></b><br> 
   Storage index for z-dimension, Default = 0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>iw</code></b><br> 
   Storage index for w-dimension, Default = 0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>par</code></b><br> 
   Dictionary of unstructured data, can be empty if no unstructured data should be written 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b>Structured data:</b> (double precision) 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>rx_position</code></td>
  <td>Receiver positions</td>
  <td><code>[3, n_snap]</code> or <code>[3, 1]</code></td>
</tr>
<tr>
  <td><code>tx_position</code></td>
  <td>Transmitter positions</td>
  <td><code>[3, n_snap]</code> or <code>[3, 1]</code></td>
</tr>
<tr>
  <td><code>coeff</code></td>
  <td>Channel coefficients, complex valued</td>
  <td><code>[n_rx, n_tx, n_path, n_snap]</code></td>
</tr>
<tr>
  <td><code>delay</code></td>
  <td>Propagation delays in seconds</td>
  <td><code>[n_rx, n_tx, n_path, n_snap]</code> or <code>[1, 1, n_path, n_snap]</code></td>
</tr>
<tr>
  <td><code>center_freq</code></td>
  <td>Center frequency in [Hz]</td>
  <td><code>[n_snap, 1]</code> or scalar</td>
</tr>
<tr>
  <td><code>name</code></td>
  <td>Name of the channel</td>
  <td>String</td>
</tr>
<tr>
  <td><code>initial_pos</code></td>
  <td>Index of reference position, 1-based</td>
  <td>uint32, scalar</td>
</tr>
<tr>
  <td><code>path_gain</code></td>
  <td>Path gain before antenna, linear scale</td>
  <td><code>[n_path, n_snap]</code></td>
</tr>
<tr>
  <td><code>path_length</code></td>
  <td>Path length from TX to RX phase center in m</td>
  <td><code>[n_path, n_snap]</code></td>
</tr>
<tr>
  <td><code>polarization</code></td>
  <td>Polarization transfer function, complex valued</td>
  <td><code>[4, n_path, n_snap]</code></td>
</tr>
<tr>
  <td><code>path_angles</code></td>
  <td>Departure and arrival angles {AOD, EOD, AOA, EOA} in rad</td>
  <td><code>[n_path, 4, n_snap]</code></td>
</tr>
<tr>
  <td><code>path_fbs_pos</code></td>
  <td>First-bounce scatterer positions</td>
  <td><code>[3, n_path, n_snap]</code></td>
</tr>
<tr>
  <td><code>path_lbs_pos</code></td>
  <td>Last-bounce scatterer positions</td>
  <td><code>[3, n_path, n_snap]</code></td>
</tr>
<tr>
  <td><code>no_interact</code></td>
  <td>Number interaction points of paths with the environment</td>
  <td>uint32, <code>[n_path, n_snap]</code></td>
</tr>
<tr>
  <td><code>interact_coord</code></td>
  <td>Interaction coordinates</td>
  <td><code>[3, max(sum(no_interact)), n_snap]</code></td>
</tr>
<tr>
  <td><code>rx_orientation</code></td>
  <td>Transmitter orientation</td>
  <td><code>[3, n_snap]</code> or <code>[3, 1]</code></td>
</tr>
<tr>
  <td><code>tx_orientation</code></td>
  <td>Receiver orientation</td>
  <td><code>[3, n_snap]</code> or <code>[3, 1]</code></td>
</tr>
</table><br>
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>storage_dims</code></b><br> 
   Size of the dimensions of the storage space, vector with 4 elements, i.e. <code>[nx,ny,nz,nw]</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Caveat:</i></b><br><ul><li style="margin-bottom: 0.4em;">If the file exists already, the new data is added to the exisiting file 
</li><li style="margin-bottom: 0.4em;">If a new file is created, a storage layout is created to store the location of datasets in the file 
</li><li style="margin-bottom: 0.4em;">For <code>location = [ix]</code> storage layout is <code>[65536,1,1,1]</code> or <code>[ix,1,1,1]</code> if (<code>ix > 65536</code>) 
</li><li style="margin-bottom: 0.4em;">For <code>location = [ix,iy]</code> storage layout is <code>[1024,64,1,1]</code> 
</li><li style="margin-bottom: 0.4em;">For <code>location = [ix,iy,iz]</code> storage layout is <code>[256,16,16,1]</code> 
</li><li style="margin-bottom: 0.4em;">For <code>location = [ix,iy,iz,iw]</code> storage layout is <code>[128,8,8,8]</code> 
</li><li style="margin-bottom: 0.4em;">You can create a custom storage layout by creating the file first using "<code>hdf5_create_file</code>" 
</li><li style="margin-bottom: 0.4em;">You can reshape the storage layout by using "<code>hdf5_reshape_storage</code>", but the total number of elements must not change 
</li><li style="margin-bottom: 0.4em;">Inputs can be empty or missing. 
</li><li style="margin-bottom: 0.4em;">All structured data is written in single precision (but can can be provided as single or double) 
</li><li style="margin-bottom: 0.4em;">Unstructured datatypes are maintained in the HDF file 
</li><li style="margin-bottom: 0.4em;">Supported unstructured types: string, double, float, (u)int32, (u)int64 
</li><li style="margin-bottom: 0.4em;">Supported unstructured size: up to 3 dimensions 
</li><li style="margin-bottom: 0.4em;">Storage order of the unstructured data is maintained 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="hdf5_write_dset"></a>
<b>hdf5_write_dset</b> - Writes unstructured data to a HDF5 file
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>Quadriga-Lib offers a solution based on HDF5 for storing and organizing channel data. In addition 
to structured datasets, the library facilitates the inclusion of extra datasets of various types 
and shapes. This feature is particularly beneficial for integrating descriptive data or analysis 
results. The function <code>quadriga_lib.hdf5_write_dset</code> writes a single unstructured dataset.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
quadriga_lib.hdf5_write_dset( fn, ix, iy, iz, iw, name, data );
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>fn</code></b><br> 
   Filename of the HDF5 file, string 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>ix</code></b><br> 
   Storage index for x-dimension, Default = 0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>iy</code></b><br> 
   Storage index for y-dimension, Default = 0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>iz</code></b><br> 
   Storage index for z-dimension, Default = 0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>iw</code></b><br> 
   Storage index for w-dimension, Default = 0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>name</code></b><br> 
   Name of the dataset; String 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>data</code></b><br> 
   Data to be written 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Caveat:</i></b><br><ul><li style="margin-bottom: 0.4em;">Throws an error if dataset already exists at this location 
</li><li style="margin-bottom: 0.4em;">Throws an error if file does not exist (use hdf5_create_file) 
</li><li style="margin-bottom: 0.4em;">Supported types: string, double, float, (u)int32, (u)int64 
</li><li style="margin-bottom: 0.4em;">Supported size: up to 3 dimensions 
</li><li style="margin-bottom: 0.4em;">Storage order is maintained 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div>
<hr class="greyline">
<hr class="greyline">
<br>
<br>
<font size=+1><b>Miscellaneous / Tools</b></font>
<br>
<br>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="cart2geo"></a>
<b>cart2geo</b> - Transform Cartesian (x,y,z) coordinates to Geographic (az, el, length) coordinates
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>This function transforms Cartesian (x,y,z) coordinates to Geographic (azimuth, elevation, length) 
coordinates. A geographic coordinate system is a three-dimensional reference system that locates 
points on the surface of a sphere. A point has three coordinate values: azimuth, elevation and length 
where azimuth and elevation measure angles. In the geographic coordinate system, the elevation angle 
θ = 90° points to the zenith and θ = 0° points to the horizon.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
geo_coords = quadriga_lib.cart2geo(cart_coords)
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Argument:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>cart_coords</code></b><br> 
   Cartesian coordinates (x,y,z), Size: <code>[3, n_row, n_col]</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>geo_coords</code></b><br> 
   Geographic coordinates, Size: <code>[3, n_row, n_col]</code><br> 
   First row: Azimuth angles in [rad], values between -pi and pi.<br> 
   Second row: Elevation angles in [rad], values between -pi/2 and pi/2.<br> 
   Third row: Vector length, i.e. the distance from the origin to the point defined by x,y,z. 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="version"></a>
<b>version</b> - Returns the quadriga-lib version number
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
version = quadriga_lib.version;
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Caveat:</i></b><br><ul><li style="margin-bottom: 0.4em;">If Quadriga-Lib was compiled with AVX2 support and the CPU supports intrinsic AVX2 instructions, 
   an suffix <code>_AVX2</code> is added after the version number 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div>
<hr class="greyline">
<hr class="greyline">
<br>
<br>
<font size=+1><b>Site-Specific Simulation Tools</b></font>
<br>
<br>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="icosphere"></a>
<b>icosphere</b> - Construct a geodesic polyhedron (icosphere), a convex polyhedron made from triangles
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>An icosphere is constructed by subdividing faces of an icosahedron, a polyhedron with 20 faces, 
12 vertices and 30 edges, and then projecting the new vertices onto the surface of a sphere. The 
resulting mesh has 6 triangles at each vertex, except for 12 vertices which have 5 triangles. 
The approximate equilateral triangles have roughly the same edge length and surface area.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
center, length, vert, direction = quadriga_lib.icosphere( no_div, radius, direction_xyz )
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>no_div</code></b><br> 
   Number of divisions per edge of the generating icosahedron. The resulting number of faces is 
   equal to <code>no_face = 20 · no_div^2</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>radius</code></b><br> 
   Radius of the sphere in meters 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>direction_xyz</code></b><br> 
   Direction format indicator: 0 = Spherical (default), 1 = Cartesian 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments (tuple containing 4 values):</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>center</code></b><br> 
   Position of the center point of each triangle; Size: <code>[ no_face, 3 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>length</code></b><br> 
   Length of the vector pointing from the origin to the center point. This number is smaller than 
   1 since the triangles are located inside the unit sphere; <br>Size: <code>[ no_face ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>vert</code></b><br> 
   The 3 vectors pointing from the center point to the vertices of each triangle; the values are 
   in the order <code>[ v1x, v1y, v1z, v2x, v2y, v2z, v3x, v3y, v3z ]</code>; <br>Size: <code>[ no_face, 9 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>direction</code></b><br> 
   The directions of the vertex-rays. If the format indicator <code>direction_xyz</code> is set to <code>0</code>, the 
   output is in geographic coordinates (azimuth and elevation angle in rad); the values are in the 
   order <code>[ v1az, v1el, v2az, v2el, v3az, v3el ]</code>;Size: <code>[ no_face, 6 ]</code> If the format indicator 
   <code>direction_xyz</code> is set to <code>1</code>, the output is in Cartesian coordinates and the values are in the 
   order <code>[ v1x, v1y, v1z, v2x, v2y, v2z, v3x, v3y, v3z  ]</code>; Size: <code>[ no_face, 9 ]</code> 
</li></ul>
</li>
</ul>
    <!-- CONTENT END -->

    <br>
    <!-- <br> -->

    <div id="quadriga-lib_sf_line"></div>

  </div>

</body>

</html>