<!DOCTYPE html>
<html>

<head>
  <meta content="text/html;" http-equiv="Content-Type">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" href="img/quadriga-lib-q_letter64.png" type="image/png">
  <link type="text/css" rel="stylesheet" href="style2.css">
  <title>Quadriga-Lib: C++/MEX Utility library for radio channel modelling and simulations</title>
</head>
 
<body>

  <div id="quadriga-lib_header">
    <div id="quadriga-lib_header_row">
      <div id="quadriga-lib_header_cell_logo_img">
        <a href="https://arma.sourceforge.net">
          <img id="quadriga-lib_logo_img" src="img/quadriga-lib-logo80.png" alt="armadillo" align="top" border="0">
        </a>
      </div>
      <div id="quadriga-lib_header_spacer"></div>
      <div id="quadriga-lib_header_cell_logo_txt">
        <div id="quadriga-lib_logo_img2"></div><big><big><b>Quadriga-Lib</b>
          </big><br>C++/MEX Utility library for radio channel modelling and simulations</big>
      </div>
    </div>
  </div>

  <div id="quadriga-lib_menu">
    <ul class="quadriga-lib_menu">
      <li class="quadriga-lib_menu"><a class="quadriga-lib_menu" href="index.html">About</a></li>
      <li class="quadriga-lib_menu"><a class="quadriga-lib_menu" href="cpp_api.html">C++ API</a></li>
      <li class="quadriga-lib_menu"><a class="quadriga-lib_menu_selected" href="mex_api.html">MATLAB API</a></li>
      <li class="quadriga-lib_menu"><a class="quadriga-lib_menu" href="python_api.html">Python API</a></li>
      <li class="quadriga-lib_menu"><a class="quadriga-lib_menu" href="formats.html">Data Formats</a></li>
      <li class="quadriga-lib_menu"><a class="quadriga-lib_menu" href="faq.html">Questions</a></li>
      <li class="quadriga-lib_menu"><a class="quadriga-lib_menu" href="contact.html">Contact</a></li>
      <li class="quadriga-lib_menu"><a class="quadriga-lib_menu" href="download.html">Download</a></li>
    </ul>
  </div>

  <div id="quadriga-lib_content">

      <!-- CONTENT BEGIN --><big><b>MALAB / Octave API Documentation for Quadriga-Lib</b></big>
<br><br><br>

<b>Overview</b>
<ul>
<li><a href="#part_1">Array antenna functions</a></li>
<li><a href="#part_2">Channel functions</a></li>
<li><a href="#part_3">Miscellaneous / Tools</a></li>
<li><a href="#part_4">Site-Specific Simulation Tools</a></li>
</ul>
<br>
<a name="part_1"></a>
<b>Array antenna functions</b>
<ul>
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tbody>
<tr><td><a href="#arrayant_calc_directivity">arrayant_calc_directivity</a></td><td>Calculates the directivity (in dBi) of array antenna elements</td></tr>
<tr><td><a href="#arrayant_combine_pattern">arrayant_combine_pattern</a></td><td>Calculate effective radiation patterns for array antennas</td></tr>
<tr><td><a href="#arrayant_generate">arrayant_generate</a></td><td>Generates predefined array antenna models</td></tr>
<tr><td><a href="#arrayant_interpolate">arrayant_interpolate</a></td><td>Interpolate array antenna field patterns</td></tr>
<tr><td><a href="#arrayant_qdant_read">arrayant_qdant_read</a></td><td>Reads array antenna data from QDANT files</td></tr>
<tr><td><a href="#arrayant_qdant_write">arrayant_qdant_write</a></td><td>Writes array antenna data to QDANT files</td></tr>
<tr><td><a href="#arrayant_rotate_pattern">arrayant_rotate_pattern</a></td><td>Rotates antenna patterns</td></tr>
<tr><td><a href="#get_channels_spherical">get_channels_spherical</a></td><td>Calculate channel coefficients from path data and antenna patterns</td></tr>
</tbody>
</table>
</ul>
<br>
<a name="part_2"></a>
<b>Channel functions</b>
<ul>
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tbody>
<tr><td><a href="#baseband_freq_response">baseband_freq_response</a></td><td>Transforms the channel into frequency domain and returns the frequency response</td></tr>
<tr><td><a href="#channel_export_obj_file">channel_export_obj_file</a></td><td>Export path data to a Wavefront OBJ file for visualization in Blender</td></tr>
<tr><td><a href="#hdf5_create_file">hdf5_create_file</a></td><td>Create a new HDF5 channel file with a custom storage layout</td></tr>
<tr><td><a href="#hdf5_read_channel">hdf5_read_channel</a></td><td>Reads channel data from HDF5 files</td></tr>
<tr><td><a href="#hdf5_read_dset">hdf5_read_dset</a></td><td>Read a single unstructured dataset from an HDF5 file</td></tr>
<tr><td><a href="#hdf5_read_dset_names">hdf5_read_dset_names</a></td><td>Read the names of unstructured data fields from an HDF5 file</td></tr>
<tr><td><a href="#hdf5_read_layout">hdf5_read_layout</a></td><td>Read the storage layout of channel data inside an HDF5 file</td></tr>
<tr><td><a href="#hdf5_reshape_layout">hdf5_reshape_layout</a></td><td>Reshapes the storage layout inside an existing HDF5 file</td></tr>
<tr><td><a href="#hdf5_write_channel">hdf5_write_channel</a></td><td>Writes channel data to HDF5 files</td></tr>
<tr><td><a href="#hdf5_write_dset">hdf5_write_dset</a></td><td>Writes unstructured data to a HDF5 file</td></tr>
</tbody>
</table>
</ul>
<br>
<a name="part_3"></a>
<b>Miscellaneous / Tools</b>
<ul>
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tbody>
<tr><td><a href="#calc_rotation_matrix ">calc_rotation_matrix </a></td><td>Calculates a 3x3 rotation matrix from a 3-element orientation vector</td></tr>
<tr><td><a href="#cart2geo">cart2geo</a></td><td>Transform Cartesian (x,y,z) coordinates to Geographic (az, el, length) coordinates</td></tr>
<tr><td><a href="#geo2cart">geo2cart</a></td><td>Transform Geographic (az, el, length) to Cartesian (x,y,z) coordinates coordinates</td></tr>
<tr><td><a href="#version">version</a></td><td>Returns the quadriga-lib version number</td></tr>
<tr><td><a href="#interp">interp</a></td><td>2D and 1D linear interpolation.</td></tr>
</tbody>
</table>
</ul>
<br>
<a name="part_4"></a>
<b>Site-Specific Simulation Tools</b>
<ul>
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tbody>
<tr><td><a href="#generate_diffraction_paths">generate_diffraction_paths</a></td><td>Generate propagation paths for estimating the diffraction gain</td></tr>
<tr><td><a href="#icosphere">icosphere</a></td><td>Construct a geodesic polyhedron (icosphere), a convex polyhedron made from triangles</td></tr>
<tr><td><a href="#obj_file_read">obj_file_read</a></td><td>Reads a triangulated 3D polygon mesh from a Wavefront OBJ file</td></tr>
<tr><td><a href="#point_cloud_aabb">point_cloud_aabb</a></td><td>Calculate the axis-aligned bounding box (AABB) of set of points in 3D-sapce</td></tr>
<tr><td><a href="#point_cloud_segmentation">point_cloud_segmentation</a></td><td>Rearranges elements of a point cloud into smaller sub-clouds</td></tr>
<tr><td><a href="#ray_mesh_interact">ray_mesh_interact</a></td><td>Calculates interactions (reflection, transmission, refraction) of radio waves with objects</td></tr>
<tr><td><a href="#ray_point_intersect">ray_point_intersect</a></td><td>Calculates the intersection of ray beams with points in three dimensions</td></tr>
<tr><td><a href="#ray_triangle_intersect">ray_triangle_intersect</a></td><td>Calculates the intersection of rays and triangles in three dimensions</td></tr>
<tr><td><a href="#subdivide_triangles">subdivide_triangles</a></td><td>Subdivide the faces of a triangle mesh into smaller faces</td></tr>
<tr><td><a href="#triangle_mesh_aabb">triangle_mesh_aabb</a></td><td>Calculate the axis-aligned bounding box (AABB) of a triangle mesh and its sub-meshes</td></tr>
<tr><td><a href="#triangle_mesh_segmentation">triangle_mesh_segmentation</a></td><td>Rearranges elements of a triangle mesh into smaller sub-meshes</td></tr>
</tbody>
</table>
</ul>
<br>
<div class="pagebreak"></div>
<hr class="greyline">
<hr class="greyline">
<br>
<br>
<font size=+1><b>Array antenna functions</b></font>
<br>
<br>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="arrayant_calc_directivity"></a>
<b>arrayant_calc_directivity</b> - Calculates the directivity (in dBi) of array antenna elements
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>Directivity is a parameter of an antenna or which measures the degree to which the radiation emitted  
is concentrated in a single direction. It is the ratio of the radiation intensity in a given direction  
from the antenna to the radiation intensity averaged over all directions. Therefore, the directivity  
of a hypothetical isotropic radiator is 1, or 0 dBi.<br>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
directivity = quadriga_lib.arrayant_calc_directivity(e_theta_re, e_theta_im, e_phi_re, ...
    e_phi_im, azimuth_grid, elevation_grid);

directivity = quadriga_lib.arrayant_calc_directivity(e_theta_re, e_theta_im, e_phi_re, ...
    e_phi_im, azimuth_grid, elevation_grid, i_element);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Examples:</i></b><br><pre>
% Generate dipole antenna
[e_theta_re, e_theta_im, e_phi_re, e_phi_im, azimuth_grid, elevation_grid] = ...
    quadriga_lib.arrayant_generate('dipole');

% Calculate directivity 
directivity = quadriga_lib.arrayant_calc_directivity(e_theta_re, e_theta_im, e_phi_re, ...
    e_phi_im, azimuth_grid, elevation_grid);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b>Antenna data:</b> (inputs 1-6, single or double precision) 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>e_theta_re</code></td>
  <td>Real part of e-theta field component</td>
  <td>Size: <code>[n_elevation, n_azimuth, n_elements]</code></td>
</tr>
<tr>
  <td><code>e_theta_im</code></td>
  <td>Imaginary part of e-theta field component</td>
  <td>Size: <code>[n_elevation, n_azimuth, n_elements]</code></td>
</tr>
<tr>
  <td><code>e_phi_re</code></td>
  <td>Real part of e-phi field component</td>
  <td>Size: <code>[n_elevation, n_azimuth, n_elements]</code></td>
</tr>
<tr>
  <td><code>e_phi_im</code></td>
  <td>Imaginary part of e-phi field component</td>
  <td>Size: <code>[n_elevation, n_azimuth, n_elements]</code></td>
</tr>
<tr>
  <td><code>azimuth_grid</code></td>
  <td>Azimuth angles in [rad] -pi to pi, sorted</td>
  <td>Size: <code>[n_azimuth]</code></td>
</tr>
<tr>
  <td><code>elevation_grid</code></td>
  <td>Elevation angles in [rad], -pi/2 to pi/2, sorted</td>
  <td>Size: <code>[n_elevation]</code></td>
</tr>
</table><br>
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>i_element</code></b> (optional)<br>  
   Element index, 1-based. If not provided or empty, the directivity is calculated for all elements in the  
   array antenna. <br>Size: <code>[n_out]</code> or empty<br> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Argument:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>directivity</code></b><br> 
   Directivity of the antenna pattern in dBi, double precision, <br>Size: <code>[n_out]</code> or <code>[n_elements]</code> 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="arrayant_combine_pattern"></a>
<b>arrayant_combine_pattern</b> - Calculate effective radiation patterns for array antennas
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>An array antenna consists of multiple individual elements. Each element occupies a specific position  
relative to the array's phase-center, its local origin. Elements can also be inter-coupled,  
represented by a coupling matrix. By integrating the element radiation patterns, their positions,  
and the coupling weights, one can determine an effective radiation pattern observable by a receiver  
in the antenna's far field. Leveraging these effective patterns is especially beneficial in antenna  
design, beamforming applications such as in 5G systems, and in planning wireless communication  
networks in complex environments like urban areas. This streamlined approach offers a significant  
boost in computation speed when calculating MIMO channel coefficients, as it reduces the number of  
necessary operations. The function <code>arrayant_combine_pattern</code> is designed to compute these effective  
radiation patterns.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
[ e_theta_re_c, e_theta_im_c, e_phi_re_c, e_phi_im_c] = quadriga_lib.arrayant_combine_pattern( ...
    e_theta_re, e_theta_im, e_phi_re, e_phi_im, azimuth_grid, elevation_grid, element_pos, 
    coupling_re, coupling_im, center_freq);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Examples:</i></b><br>The following example creates a unified linear array of 4 dipoles, spaced at half-wavelength. The 
elements are then coupled with each other (i.e., they receive the same signal). The effective pattern 
is calculated using <code>arrayant_combine_pattern</code>. 
 
<pre>
% Generate dipole pattern
[e_theta_re, e_theta_im, e_phi_re, e_phi_im, azimuth_grid, elevation_grid, element_pos] = ...
    &lt;a href="#arrayant_generate"&gt;quadriga_lib.arrayant_generate&lt;/a&gt;('dipole');

% Duplicate 4 times
e_theta_re  = repmat(e_theta_re, [1,1,4]);
e_theta_im  = repmat(e_theta_im, [1,1,4]);
e_phi_re    = repmat(e_phi_re, [1,1,4]);
e_phi_im    = repmat(e_phi_im, [1,1,4]);
element_pos = repmat(element_pos, [1,4]);

% Set element positions and coupling matrix
element_pos(2,:) = [ -0.75, -0.25, 0.25, 0.75];  % lambda, along y-axis
coupling_re = [ 1 ; 1 ; 1 ; 1 ]/sqrt(4);

% Calculate effective pattern
[ e_theta_re_c, e_theta_im_c, e_phi_re_c, e_phi_im_c] = quadriga_lib.arrayant_combine_pattern( ...
    e_theta_re, e_theta_im, e_phi_re, e_phi_im, azimuth_grid, elevation_grid, element_pos, coupling_re);

% Plot gain
plot( azimuth_grid*180/pi, [ 10*log10( e_theta_re(91,:,1).^2 ); 10*log10( e_theta_re_c(91,:).^2 ) ]);
axis([-180 180 -20 15]); ylabel('Gain (dBi)'); xlabel('Azimth angle (deg)'); legend('Dipole','Array')

</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b>Antenna data:</b> (inputs 1-10, single or double) 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>e_theta_re</code></td>
  <td>Real part of e-theta field component</td>
  <td>Size: <code>[n_elevation, n_azimuth, n_elements]</code></td>
</tr>
<tr>
  <td><code>e_theta_im</code></td>
  <td>Imaginary part of e-theta field component</td>
  <td>Size: <code>[n_elevation, n_azimuth, n_elements]</code></td>
</tr>
<tr>
  <td><code>e_phi_re</code></td>
  <td>Real part of e-phi field component</td>
  <td>Size: <code>[n_elevation, n_azimuth, n_elements]</code></td>
</tr>
<tr>
  <td><code>e_phi_im</code></td>
  <td>Imaginary part of e-phi field component</td>
  <td>Size: <code>[n_elevation, n_azimuth, n_elements]</code></td>
</tr>
<tr>
  <td><code>azimuth_grid</code></td>
  <td>Azimuth angles in [rad] -pi to pi, sorted</td>
  <td>Size: <code>[n_azimuth]</code></td>
</tr>
<tr>
  <td><code>elevation_grid</code></td>
  <td>Elevation angles in [rad], -pi/2 to pi/2, sorted</td>
  <td>Size: <code>[n_elevation]</code></td>
</tr>
<tr>
  <td><code>element_pos</code></td>
  <td>Antenna element (x,y,z) positions, optional</td>
  <td>Size: <code>[3, n_elements]</code> or <code>[]</code></td>
</tr>
<tr>
  <td><code>coupling_re</code></td>
  <td>Real part of coupling matrix, optional</td>
  <td>Size: <code>[n_elements, n_ports]</code> or <code>[]</code></td>
</tr>
<tr>
  <td><code>coupling_im</code></td>
  <td>Imaginary part of coupling matrix, optional</td>
  <td>Size: <code>[n_elements, n_ports]</code> or <code>[]</code></td>
</tr>
<tr>
  <td><code>center_freq</code></td>
  <td>Center frequency in [Hz], optional, default = 0.3 GHz</td>
  <td>Scalar</td>
</tr>
</table><br>
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>e_theta_re_c</code></b><br> 
   Real part of the e-theta component (vertical component) of the effective array antenna.<br> 
   Size: <code>[n_elevation, n_azimuth, n_ports]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>e_theta_im_c</code></b><br> 
   Imaginary part of the e-theta component (vertical component) of the effective array antenna.<br> 
   Size: <code>[n_elevation, n_azimuth, n_ports]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>e_phi_re_c</code></b><br> 
   Real part of the e-phi component (horizontal component) of the effective array antenna.<br> 
   Size: <code>[n_elevation, n_azimuth, n_ports]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>e_phi_im_c</code></b><br> 
   Imaginary part of the e-phi component (horizontal component) of the effective array antenna.<br> 
   Size: <code>[n_elevation, n_azimuth, n_ports]</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Caveat:</i></b><br>The effective antenna has all elements at the phase center <code>[0,0,0]'</code> and has perfect isolation 
between its elements. Hence, no outputs for the effective <code>element_pos</code> and <code>coupling</code> are needed.
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="arrayant_generate"></a>
<b>arrayant_generate</b> - Generates predefined array antenna models
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>This functions can be used to generate a variety of pre-defined array antenna models, including 3GPP 
array antennas used for 5G-NR simulations. The first argument is the array type. The following input 
arguments are then specific to this type.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
% Isotropic radiator, vertical polarization, 1 deg resolution
[e_theta_re, e_theta_im, e_phi_re, e_phi_im, azimuth_grid, elevation_grid, element_pos, ...
    coupling_re, coupling_im, center_frequency, name] = quadriga_lib.arrayant_generate('omni');

% Short dipole radiating with vertical polarization, 1 deg resolution
[e_theta_re, e_theta_im, e_phi_re, e_phi_im, azimuth_grid, elevation_grid, element_pos, ...
    coupling_re, coupling_im, center_frequency, name] = quadriga_lib.arrayant_generate('dipole');

% Half-wave dipole radiating with vertical polarization, 1 deg resolution
[e_theta_re, e_theta_im, e_phi_re, e_phi_im, azimuth_grid, elevation_grid, element_pos, ...
    coupling_re, coupling_im, center_frequency, name] = quadriga_lib.arrayant_generate('half-wave-dipole');

% Cross-polarized isotropic radiator, 1 deg resolution
[e_theta_re, e_theta_im, e_phi_re, e_phi_im, azimuth_grid, elevation_grid, element_pos, ...
    coupling_re, coupling_im, center_frequency, name] = quadriga_lib.arrayant_generate('xpol');

% An antenna with a custom 3dB beam with (in degree)
[e_theta_re, e_theta_im, e_phi_re, e_phi_im, azimuth_grid, elevation_grid, element_pos, ...
    coupling_re, coupling_im, center_frequency, name] = ...
    quadriga_lib.arrayant_generate('custom', az_3dB, el_3db, rear_gain_lin );

% Antenna model for the 3GPP-NR channel model
[e_theta_re, e_theta_im, e_phi_re, e_phi_im, azimuth_grid, elevation_grid, element_pos, ...
    coupling_re, coupling_im, center_frequency, name] = ...
    quadriga_lib.arrayant_generate('3GPP', M, N, center_freq, pol, tilt, spacing, Mg, Ng, dgv, dgh );

% Antenna model for the 3GPP-NR channel model with a custom pattern
[e_theta_re, e_theta_im, e_phi_re, e_phi_im, azimuth_grid, elevation_grid, element_pos, ...
    coupling_re, coupling_im, center_frequency, name] = ...
    quadriga_lib.arrayant_generate('3GPP', M, N, center_freq, pol, tilt, spacing, Mg, Ng, dgv, dgh, ...
    e_theta_re_c, e_theta_im_c, e_phi_re_c, e_phi_im_c, azimuth_grid_c, elevation_grid_c );
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments for type 'custom':</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>az_3dB</code></b><br> 
   3dB beam width in azimuth direction in [deg], scalar 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>el_3db</code></b><br> 
   3dB beam width in elevation direction in [deg], scalar 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>rear_gain_lin</code></b><br> 
   Isotropic gain (linear scale) at the back of the antenna, scalar 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments for type '3GPP':</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>M</code></b><br> 
   Number of vertically stacked elements, scalar, default = 1 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>N</code></b><br> 
   Number of horizontally stacked elements, scalar, default = 1 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>center_freq</code></b><br> 
   The center frequency in [Hz], scalar, default = 299792458 Hz 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>pol</code></b><br> 
   Polarization indicator to be applied for each of the NM elements:<br> 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>pol = 1</code></td>
  <td>vertical polarization (default value)</td>
</tr>
<tr>
  <td><code>pol = 2</code></td>
  <td>H/V polarized elements, results in 2NM elements</td>
</tr>
<tr>
  <td><code>pol = 3</code></td>
  <td>+/-45° polarized elements, results in 2NM elements</td>
</tr>
<tr>
  <td><code>pol = 4</code></td>
  <td>vertical polarization, combines elements in vertical direction, results in N elements</td>
</tr>
<tr>
  <td><code>pol = 5</code></td>
  <td>H/V polarization, combines elements in vertical direction, results in 2N elements</td>
</tr>
<tr>
  <td><code>pol = 6</code></td>
  <td>+/-45° polarization, combines elements in vertical direction, results in 2N elements</td>
</tr>
</table><br>
   Polarization indicator is ignored when a custom pattern is provided. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>tilt</code></b><br> 
   The electric downtilt angle in [deg], Only relevant for <code>pol = 4/5/6</code>, scalar, default = 0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>spacing</code></b><br> 
   Element spacing in [λ], scalar, default = 0.5 
    
</li><li style="margin-bottom: 0.4em;"><b><code>Mg</code></b><br> 
   Number of nested panels in a column, scalar, default = 1 
    
</li><li style="margin-bottom: 0.4em;"><b><code>Ng</code></b><br> 
   Number of nested panels in a row, scalar, default = 1 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>dgv</code></b><br> 
   Panel spacing in vertical direction in [λ], scalar, default = 0.5 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>dgh</code></b><br> 
   Panel spacing in vertical horizontal in [λ], scalar, default = 0.5 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b>Antenna data for custom pattern data:</b> (inputs 11-16, double precision, optional) 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>e_theta_re_c</code></td>
  <td>Real part of e-theta field component</td>
  <td>Size: <code>[n_elevation, n_azimuth, n_elements_c]</code></td>
</tr>
<tr>
  <td><code>e_theta_im_c</code></td>
  <td>Imaginary part of e-theta field component</td>
  <td>Size: <code>[n_elevation, n_azimuth, n_elements_c]</code></td>
</tr>
<tr>
  <td><code>e_phi_re_c</code></td>
  <td>Real part of e-phi field component</td>
  <td>Size: <code>[n_elevation, n_azimuth, n_elements_c]</code></td>
</tr>
<tr>
  <td><code>e_phi_im_c</code></td>
  <td>Imaginary part of e-phi field component</td>
  <td>Size: <code>[n_elevation, n_azimuth, n_elements_c]</code></td>
</tr>
<tr>
  <td><code>azimuth_grid_c</code></td>
  <td>Azimuth angles in [rad] -pi to pi, sorted</td>
  <td>Size: <code>[n_azimuth]</code></td>
</tr>
<tr>
  <td><code>elevation_grid_c</code></td>
  <td>Elevation angles in [rad], -pi/2 to pi/2, sorted</td>
  <td>Size: <code>[n_elevation]</code></td>
</tr>
</table><br>
    
   If custom pattern data is not provided, the default 3GPP element pattern with 1 degree sampling is used. 
    
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b>Antenna data of the generated array antenna:</b> (outputs 1-11, double precision) 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>e_theta_re</code></td>
  <td>Real part of e-theta field component</td>
  <td>Size: <code>[n_elevation, n_azimuth, n_elements]</code></td>
</tr>
<tr>
  <td><code>e_theta_im</code></td>
  <td>Imaginary part of e-theta field component</td>
  <td>Size: <code>[n_elevation, n_azimuth, n_elements]</code></td>
</tr>
<tr>
  <td><code>e_phi_re</code></td>
  <td>Real part of e-phi field component</td>
  <td>Size: <code>[n_elevation, n_azimuth, n_elements]</code></td>
</tr>
<tr>
  <td><code>e_phi_im</code></td>
  <td>Imaginary part of e-phi field component</td>
  <td>Size: <code>[n_elevation, n_azimuth, n_elements]</code></td>
</tr>
<tr>
  <td><code>azimuth_grid</code></td>
  <td>Azimuth angles in [rad] -pi to pi, sorted</td>
  <td>Size: <code>[n_azimuth]</code></td>
</tr>
<tr>
  <td><code>elevation_grid</code></td>
  <td>Elevation angles in [rad], -pi/2 to pi/2, sorted</td>
  <td>Size: <code>[n_elevation]</code></td>
</tr>
<tr>
  <td><code>element_pos</code></td>
  <td>Antenna element (x,y,z) positions, optional</td>
  <td>Size: <code>[3, n_elements]</code> or <code>[]</code></td>
</tr>
<tr>
  <td><code>coupling_re</code></td>
  <td>Real part of coupling matrix, optional</td>
  <td>Size: <code>[n_elements, n_ports]</code> or <code>[]</code></td>
</tr>
<tr>
  <td><code>coupling_im</code></td>
  <td>Imaginary part of coupling matrix, optional</td>
  <td>Size: <code>[n_elements, n_ports]</code> or <code>[]</code></td>
</tr>
<tr>
  <td><code>center_freq</code></td>
  <td>Center frequency in [Hz], optional, default = 0.3 GHz</td>
  <td>Scalar</td>
</tr>
<tr>
  <td><code>name</code></td>
  <td>Name of the array antenna object</td>
  <td>String</td>
</tr>
</table><br>
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="arrayant_interpolate"></a>
<b>arrayant_interpolate</b> - Interpolate array antenna field patterns
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>This function interpolates polarimetric antenna field patterns for a given set of azimuth and 
elevation angles.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
[V_re, V_im, H_re, H_im, dist, azimuth_loc, elevation_loc, gamma] = ...
    quadriga_lib.arrayant_interpolate( e_theta_re, e_theta_im, e_phi_re, e_phi_im, ...
    azimuth_grid, elevation_grid, azimuth, elevation, i_element, orientation, element_pos )
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b>Antenna data:</b> (inputs 1-6, single or double precision) 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>e_theta_re</code></td>
  <td>Real part of e-theta field component</td>
  <td>Size: <code>[n_elevation, n_azimuth, n_elements]</code></td>
</tr>
<tr>
  <td><code>e_theta_im</code></td>
  <td>Imaginary part of e-theta field component</td>
  <td>Size: <code>[n_elevation, n_azimuth, n_elements]</code></td>
</tr>
<tr>
  <td><code>e_phi_re</code></td>
  <td>Real part of e-phi field component</td>
  <td>Size: <code>[n_elevation, n_azimuth, n_elements]</code></td>
</tr>
<tr>
  <td><code>e_phi_im</code></td>
  <td>Imaginary part of e-phi field component</td>
  <td>Size: <code>[n_elevation, n_azimuth, n_elements]</code></td>
</tr>
<tr>
  <td><code>azimuth_grid</code></td>
  <td>Azimuth angles in [rad] -pi to pi, sorted</td>
  <td>Size: <code>[n_azimuth]</code></td>
</tr>
<tr>
  <td><code>elevation_grid</code></td>
  <td>Elevation angles in [rad], -pi/2 to pi/2, sorted</td>
  <td>Size: <code>[n_elevation]</code></td>
</tr>
</table><br>
    
</li><li style="margin-bottom: 0.4em;"><b><code>azimuth</code></b><br> 
   Azimuth angles in [rad] for which the field pattern should be interpolated. Values must be 
   between -pi and pi, single or double precision. 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td>Option 1:</td>
  <td>Use the same angles for all antenna elements (planar wave approximation)</td>
</tr>
<tr>
  <td></td>
  <td>Size: <code>[1, n_ang]</code></td>
</tr>
<tr>
  <td>Option 2:</td>
  <td>Provide different angles for each array element (e.g. for spherical waves)</td>
</tr>
<tr>
  <td></td>
  <td>Size: <code>[n_out, n_ang]</code></td>
</tr>
</table><br>
    
</li><li style="margin-bottom: 0.4em;"><b><code>elevation</code></b><br> 
   Elevation angles in [rad] for which the field pattern should be interpolated. Values must be 
   between -pi/2 and pi/2, single or double precision. 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td>Option 1:</td>
  <td>Use the same angles for all antenna elements (planar wave approximation)</td>
</tr>
<tr>
  <td></td>
  <td>Size: <code>[1, n_ang]</code></td>
</tr>
<tr>
  <td>Option 2:</td>
  <td>Provide different angles for each array element (e.g. for spherical waves)</td>
</tr>
<tr>
  <td></td>
  <td>Size: <code>[n_out, n_ang]</code></td>
</tr>
</table><br>
    
</li><li style="margin-bottom: 0.4em;"><b><code>i_element</code></b><br> 
   The element indices for which the interpolation should be done. Optional parameter. Values must 
   be between 1 and n_elements. It is possible to duplicate elements, i.e. by passing <code>[1,1,2]</code>. 
   If this parameter is not provided (or an empty array is passed), <code>i_element</code> is initialized 
   to <code>[1:n_elements]</code>. In this case, <code>n_out = n_elements</code>. Allowed types: uint32 or double.<br> 
   Size: <code>[1, n_out]</code> or <code>[n_out, 1]</code> or empty <code>[]</code> 
    
</li><li style="margin-bottom: 0.4em;"><b><code>orientation</code></b><br> 
   This (optional) 3-element vector describes the orientation of the array antenna or of individual 
   array elements. The The first value describes the ”bank angle”, the second value describes the 
   ”tilt angle”, (positive values point upwards), the third value describes the bearing or ”heading 
   angle”, in mathematic sense. Values must be given in [rad]. East corresponds to 0, and the 
   angles increase counter-clockwise, so north is pi/2, south is -pi/2, and west is equal to pi. By 
   default, the orientation is <code>[0,0,0]</code>', i.e. the broadside of the antenna points at the horizon 
   towards the East. Single or double precision<br> 
   Size: <code>[3, 1]</code> or <code>[3, n_out]</code> or <code>[3, 1, n_ang]</code> or <code>[3, n_out, n_ang]</code> or empty <code>[]</code> 
    
</li><li style="margin-bottom: 0.4em;"><b><code>element_pos</code></b><br> 
   Positions of the array antenna elements in local cartesian coordinates (using units of [m]). 
   Optional parameter. If this parameter is not given, all elements are placed at the phase center 
   of the array at coordinates <code>[0,0,0]'</code>. Otherwise, positions are given for the elements in the 
   output of the interpolation function. For example, when duplicating the fist element by setting 
   <code>i_element = [1,1]</code>, different element positions can be set for the two elements in the output. 
   Single or double precision, <br>Size: <code>[3, n_out]</code> or empty <code>[]</code> 
    
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Derived inputs:</i></b><br><table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>n_azimuth</code></td>
  <td>Number of azimuth angles in the filed pattern</td>
</tr>
<tr>
  <td><code>n_elevation</code></td>
  <td>Number of elevation angles in the filed pattern</td>
</tr>
<tr>
  <td><code>n_elements</code></td>
  <td>Number of antenna elements filed pattern of the array antenna</td>
</tr>
<tr>
  <td><code>n_ang</code></td>
  <td>Number of interpolation angles</td>
</tr>
<tr>
  <td><code>n_out</code></td>
  <td>Number of antenna elements in the generated output (may differ from n_elements)</td>
</tr>
</table><br>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>V_re</code></b><br> 
   Real part of the interpolated e-theta (vertical) field component.<br> 
   Single or double precision (same as input), Size <code>[n_out, n_ang]</code> 
    
</li><li style="margin-bottom: 0.4em;"><b><code>V_im</code></b><br> 
   Imaginary part of the interpolated e-theta (vertical) field component.<br> 
   Single or double precision (same as input), Size <code>[n_out, n_ang]</code> 
    
</li><li style="margin-bottom: 0.4em;"><b><code>H_re</code></b><br> 
   Real part of the interpolated e-phi (horizontal) field component.<br> 
   Single or double precision (same as input), Size <code>[n_out, n_ang]</code> 
    
</li><li style="margin-bottom: 0.4em;"><b><code>H_im</code></b><br> 
   Imaginary part of the interpolated e-phi (horizontal) field component.<br> 
   Single or double precision (same as input), Size <code>[n_out, n_ang]</code> 
    
</li><li style="margin-bottom: 0.4em;"><b><code>dist</code></b><br> 
   The effective distances between the antenna elements when seen from the direction of the 
   incident path. The distance is calculated by an projection of the array positions on the normal 
   plane of the incident path. This is needed for calculating the phase of the antenna response.<br> 
   Single or double precision (same as input), Size <code>[n_out, n_ang]</code> 
    
</li><li style="margin-bottom: 0.4em;"><b><code>azimuth_loc</code></b><br> 
   The azimuth angles in [rad] for the local antenna coordinate system, i.e., after applying the 
   'orientation'. If no orientation vector is given, these angles are identical to the input 
   azimuth angles. Optional output.<br> 
   Single or double precision (same as input), Size <code>[n_out, n_ang]</code> 
    
</li><li style="margin-bottom: 0.4em;"><b><code>elevation_loc</code></b><br> 
   The elevation angles in [rad] for the local antenna coordinate system, i.e., after applying the 
   'orientation'. If no orientation vector is given, these angles are identical to the input 
   elevation angles. Optional output.<br> 
   Single or double precision (same as input), Size <code>[n_out, n_ang]</code> 
    
</li><li style="margin-bottom: 0.4em;"><b><code>gamma</code></b><br> 
   Polarization rotation angles in [rad]<br> 
   Single or double precision (same as input), Size <code>[n_out, n_ang]</code> 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="arrayant_qdant_read"></a>
<b>arrayant_qdant_read</b> - Reads array antenna data from QDANT files
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>The QuaDRiGa array antenna exchange format (QDANT) is a file format used to store antenna pattern 
data in XML. This function reads pattern data from the specified file.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
[e_theta_re, e_theta_im, e_phi_re, e_phi_im, azimuth_grid, elevation_grid, element_pos, coupling_re,
   coupling_im, center_freq, name, layout ] = quadriga_lib.arrayant_qdant_read( fn, id, use_single );
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>fn</code></b><br> 
   Filename of the QDANT file, string 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>id</code></b> (optional)<br> 
   ID of the antenna to be read from the file, optional, Default: Read first 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>use_single</code></b> (optional)<br> 
   Indicator if results should be returned in single precision, default = 0, returned in double precision 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b>Antenna data:</b> (outputs 1-11, single or double) 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>e_theta_re</code></td>
  <td>Real part of e-theta field component</td>
  <td>Size: <code>[n_elevation, n_azimuth, n_elements]</code></td>
</tr>
<tr>
  <td><code>e_theta_im</code></td>
  <td>Imaginary part of e-theta field component</td>
  <td>Size: <code>[n_elevation, n_azimuth, n_elements]</code></td>
</tr>
<tr>
  <td><code>e_phi_re</code></td>
  <td>Real part of e-phi field component</td>
  <td>Size: <code>[n_elevation, n_azimuth, n_elements]</code></td>
</tr>
<tr>
  <td><code>e_phi_im</code></td>
  <td>Imaginary part of e-phi field component</td>
  <td>Size: <code>[n_elevation, n_azimuth, n_elements]</code></td>
</tr>
<tr>
  <td><code>azimuth_grid</code></td>
  <td>Azimuth angles in [rad] -pi to pi, sorted</td>
  <td>Size: <code>[n_azimuth]</code></td>
</tr>
<tr>
  <td><code>elevation_grid</code></td>
  <td>Elevation angles in [rad], -pi/2 to pi/2, sorted</td>
  <td>Size: <code>[n_elevation]</code></td>
</tr>
<tr>
  <td><code>element_pos</code></td>
  <td>Antenna element (x,y,z) positions, optional</td>
  <td>Size: <code>[3, n_elements]</code> or <code>[]</code></td>
</tr>
<tr>
  <td><code>coupling_re</code></td>
  <td>Real part of coupling matrix, optional</td>
  <td>Size: <code>[n_elements, n_ports]</code> or <code>[]</code></td>
</tr>
<tr>
  <td><code>coupling_im</code></td>
  <td>Imaginary part of coupling matrix, optional</td>
  <td>Size: <code>[n_elements, n_ports]</code> or <code>[]</code></td>
</tr>
<tr>
  <td><code>center_freq</code></td>
  <td>Center frequency in [Hz], optional, default = 0.3 GHz</td>
  <td>Scalar</td>
</tr>
<tr>
  <td><code>name</code></td>
  <td>Name of the array antenna object</td>
  <td>String</td>
</tr>
</table><br>
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>layout</code></b><br> 
   Layout of multiple array antennas. Contain element ids that are present in the file 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="arrayant_qdant_write"></a>
<b>arrayant_qdant_write</b> - Writes array antenna data to QDANT files
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>The QuaDRiGa array antenna exchange format (QDANT) is a file format used to store antenna pattern  
data in XML. This function writes pattern data to the specified file.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
id_in_file = quadriga_lib.arrayant_qdant_write( fn, e_theta_re, e_theta_im, e_phi_re, e_phi_im, ...
    azimuth_grid, elevation_grid, element_pos, coupling_re, coupling_im, center_freq, name, id, layout);
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Caveat:</i></b><br><ul><li style="margin-bottom: 0.4em;">Inputs can be single or double precision, but type must match for all inputs 
</li><li style="margin-bottom: 0.4em;">Multiple array antennas can be stored in the same file using the <code>id</code> parameter. 
</li><li style="margin-bottom: 0.4em;">If writing to an exisiting file without specifying an <code>id</code>, the data gests appended at the end.   
   The output <code>id_in_file</code> identifies the location inside the file. 
</li><li style="margin-bottom: 0.4em;">An optional storage <code>layout</code> can be provided to organize data inside the file. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>fn</code></b><br> 
   Filename of the QDANT file, string 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b>Antenna data:</b> (inputs 2-12, single or double) 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>e_theta_re</code></td>
  <td>Real part of e-theta field component</td>
  <td>Size: <code>[n_elevation, n_azimuth, n_elements]</code></td>
</tr>
<tr>
  <td><code>e_theta_im</code></td>
  <td>Imaginary part of e-theta field component</td>
  <td>Size: <code>[n_elevation, n_azimuth, n_elements]</code></td>
</tr>
<tr>
  <td><code>e_phi_re</code></td>
  <td>Real part of e-phi field component</td>
  <td>Size: <code>[n_elevation, n_azimuth, n_elements]</code></td>
</tr>
<tr>
  <td><code>e_phi_im</code></td>
  <td>Imaginary part of e-phi field component</td>
  <td>Size: <code>[n_elevation, n_azimuth, n_elements]</code></td>
</tr>
<tr>
  <td><code>azimuth_grid</code></td>
  <td>Azimuth angles in [rad] -pi to pi, sorted</td>
  <td>Size: <code>[n_azimuth]</code></td>
</tr>
<tr>
  <td><code>elevation_grid</code></td>
  <td>Elevation angles in [rad], -pi/2 to pi/2, sorted</td>
  <td>Size: <code>[n_elevation]</code></td>
</tr>
<tr>
  <td><code>element_pos</code></td>
  <td>Antenna element (x,y,z) positions, optional</td>
  <td>Size: <code>[3, n_elements]</code> or <code>[]</code></td>
</tr>
<tr>
  <td><code>coupling_re</code></td>
  <td>Real part of coupling matrix, optional</td>
  <td>Size: <code>[n_elements, n_ports]</code> or <code>[]</code></td>
</tr>
<tr>
  <td><code>coupling_im</code></td>
  <td>Imaginary part of coupling matrix, optional</td>
  <td>Size: <code>[n_elements, n_ports]</code> or <code>[]</code></td>
</tr>
<tr>
  <td><code>center_freq</code></td>
  <td>Center frequency in [Hz], optional, default = 0.3 GHz</td>
  <td>Scalar</td>
</tr>
<tr>
  <td><code>name</code></td>
  <td>Name of the array antenna object</td>
  <td>String</td>
</tr>
</table><br>
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>id</code></b> (optional)<br> 
   ID of the antenna to be written to the file, optional, Default: Max-ID in existing file + 1 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>layout</code></b> (optional)<br> 
   Layout of multiple array antennas. Must only contain element ids that are present in the file. optional 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Argument:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>id_in_file</code></b><br> 
   ID of the antenna in the file after writing 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="arrayant_rotate_pattern"></a>
<b>arrayant_rotate_pattern</b> - Rotates antenna patterns
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>This MATLAB function transforms the radiation patterns of array antenna elements, allowing for 
precise rotations around the three principal axes (x, y, z) of the local Cartesian coordinate system. 
This is essential in antenna design and optimization, enabling engineers to tailor the radiation 
pattern for enhanced performance. The function also adjusts the sampling grid for non-uniformly 
sampled antennas, such as parabolic antennas with small apertures, ensuring accurate and efficient 
computations. The 3 rotations are applies in the order: 1. rotation around the x-axis (bank angle); 
2. rotation around the y-axis (tilt angle), 3. rotation around the z-axis (heading angle)
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
[ e_theta_re_r, e_theta_im_r, e_phi_re_r, e_phi_im_r, azimuth_grid_r, elevation_grid_r, element_pos_r ] = ...
    quadriga_lib.arrayant_rotate_pattern( e_theta_re, e_theta_im, e_phi_re, e_phi_im, azimuth_grid, ...
    elevation_grid, element_pos, x_deg, y_deg, z_deg, usage )
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b>Antenna data:</b> (inputs 1-7, single or double) 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>e_theta_re</code></td>
  <td>Real part of e-theta field component</td>
  <td>Size: <code>[n_elevation, n_azimuth, n_elements]</code></td>
</tr>
<tr>
  <td><code>e_theta_im</code></td>
  <td>Imaginary part of e-theta field component</td>
  <td>Size: <code>[n_elevation, n_azimuth, n_elements]</code></td>
</tr>
<tr>
  <td><code>e_phi_re</code></td>
  <td>Real part of e-phi field component</td>
  <td>Size: <code>[n_elevation, n_azimuth, n_elements]</code></td>
</tr>
<tr>
  <td><code>e_phi_im</code></td>
  <td>Imaginary part of e-phi field component</td>
  <td>Size: <code>[n_elevation, n_azimuth, n_elements]</code></td>
</tr>
<tr>
  <td><code>azimuth_grid</code></td>
  <td>Azimuth angles in [rad] -pi to pi, sorted</td>
  <td>Size: <code>[n_azimuth]</code></td>
</tr>
<tr>
  <td><code>elevation_grid</code></td>
  <td>Elevation angles in [rad], -pi/2 to pi/2, sorted</td>
  <td>Size: <code>[n_elevation]</code></td>
</tr>
<tr>
  <td><code>element_pos</code></td>
  <td>Antenna element (x,y,z) positions, optional</td>
  <td>Size: <code>[3, n_elements]</code> or <code>[]</code></td>
</tr>
</table><br>
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>x_deg</code></b><br> 
   The rotation angle around x-axis (bank angle) in [degrees] 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>y_deg</code></b><br> 
   The rotation angle around y-axis (tilt angle) in [degrees] 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>z_deg</code></b><br> 
   The rotation angle around z-axis (heading angle) in [degrees] 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>usage</code></b><br> 
   The optional parameter 'usage' can limit the rotation procedure either to the pattern or polarization. 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>usage = 0</code></td>
  <td>Rotate both, pattern and polarization, adjusts sampling grid (default)</td>
</tr>
<tr>
  <td><code>usage = 1</code></td>
  <td>Rotate only pattern, adjusts sampling grid</td>
</tr>
<tr>
  <td><code>usage = 2</code></td>
  <td>Rotate only polarization</td>
</tr>
<tr>
  <td><code>usage = 3</code></td>
  <td>Rotate both, but do not adjust the sampling grid</td>
</tr>
</table><br>
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b>Antenna data of the rotated antenna:</b> (outputs 1-7, single or double) 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>e_theta_re_r</code></td>
  <td>Real part of e-theta field component</td>
  <td>Size: <code>[n_elevation_r, n_azimuth_r, n_elements]</code></td>
</tr>
<tr>
  <td><code>e_theta_im_r</code></td>
  <td>Imaginary part of e-theta field component</td>
  <td>Size: <code>[n_elevation_r, n_azimuth_r, n_elements]</code></td>
</tr>
<tr>
  <td><code>e_phi_re_r</code></td>
  <td>Real part of e-phi field component</td>
  <td>Size: <code>[n_elevation_r, n_azimuth_r, n_elements]</code></td>
</tr>
<tr>
  <td><code>e_phi_im_r</code></td>
  <td>Imaginary part of e-phi field component</td>
  <td>Size: <code>[n_elevation_r, n_azimuth_r, n_elements]</code></td>
</tr>
<tr>
  <td><code>azimuth_grid_r</code></td>
  <td>Azimuth angles in [rad] -pi to pi, sorted</td>
  <td>Size: <code>[n_azimuth_r]</code></td>
</tr>
<tr>
  <td><code>elevation_grid_r</code></td>
  <td>Elevation angles in [rad], -pi/2 to pi/2, sorted</td>
  <td>Size: <code>[n_elevation_r]</code></td>
</tr>
<tr>
  <td><code>element_pos_r</code></td>
  <td>Antenna element (x,y,z) positions, optional</td>
  <td>Size: <code>[3, n_elements]</code></td>
</tr>
</table><br>
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="get_channels_spherical"></a>
<b>get_channels_spherical</b> - Calculate channel coefficients from path data and antenna patterns
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>In this function, the wireless propagation channel between a transmitter and a receiver is calculated,  
based on a single transmit and receive position. Additionally, interaction points with the environment,  
which are derived from either Ray Tracing or Geometric Stochastic Models such as QuaDRiGa, are  
considered. The calculation is performed under the assumption of spherical wave propagation. For accurate  
execution of this process, several pieces of input data are required:<br><br> 
 
<ul><li style="margin-bottom: 0.4em;">The 3D Cartesian (local) coordinates of both the transmitter and the receiver. 
</li><li style="margin-bottom: 0.4em;">The specific interaction positions of the propagation paths within the environment. 
</li><li style="margin-bottom: 0.4em;">The polarization transfer matrix for each propagation path. 
</li><li style="margin-bottom: 0.4em;">Antenna models for both the transmitter and the receiver. 
</li><li style="margin-bottom: 0.4em;">The orientations of the antennas. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
[ coeff_re, coeff_im, delays, aod, eod, aoa, eoa ] = quadriga_lib.get_channels_spherical( ...
    e_theta_re_tx, e_theta_im_tx, e_phi_re_tx, e_phi_im_tx, azimuth_grid_tx, elevation_grid_tx, element_pos_tx, coupling_re_tx, coupling_im_tx, ...
    e_theta_re_rx, e_theta_im_rx, e_phi_re_rx, e_phi_im_rx, azimuth_grid_rx, elevation_grid_rx, element_pos_rx, coupling_re_rx, coupling_im_rx, ...
    fbs_pos, lbs_pos, path_gain, path_length, M, tx_pos, tx_orientation, rx_pos, rx_orientation, center_freq, use_absolute_delays, add_fake_los_path );
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b>TX Antenna data:</b> (inputs 1-9, single or double) 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>e_theta_re_tx</code></td>
  <td>Real part of e-theta field component</td>
  <td>Size: <code>[n_elevation_tx, n_azimuth_tx, n_tx_elements]</code></td>
</tr>
<tr>
  <td><code>e_theta_im_tx</code></td>
  <td>Imaginary part of e-theta field component</td>
  <td>Size: <code>[n_elevation_tx, n_azimuth_tx, n_tx_elements]</code></td>
</tr>
<tr>
  <td><code>e_phi_re_tx</code></td>
  <td>Real part of e-phi field component</td>
  <td>Size: <code>[n_elevation_tx, n_azimuth_tx, n_tx_elements]</code></td>
</tr>
<tr>
  <td><code>e_phi_im_tx</code></td>
  <td>Imaginary part of e-phi field component</td>
  <td>Size: <code>[n_elevation_tx, n_azimuth_tx, n_tx_elements]</code></td>
</tr>
<tr>
  <td><code>azimuth_grid_tx</code></td>
  <td>Azimuth angles in [rad] -pi to pi, sorted</td>
  <td>Size: <code>[n_azimuth_tx]</code></td>
</tr>
<tr>
  <td><code>elevation_grid_tx</code></td>
  <td>Elevation angles in [rad], -pi/2 to pi/2, sorted</td>
  <td>Size: <code>[n_elevation_tx]</code></td>
</tr>
<tr>
  <td><code>element_pos_tx</code></td>
  <td>Antenna element (x,y,z) positions, optional</td>
  <td>Size: <code>[3, n_tx_elements]</code> or <code>[]</code></td>
</tr>
<tr>
  <td><code>coupling_re_tx</code></td>
  <td>Real part of coupling matrix, optional</td>
  <td>Size: <code>[n_tx_elements, n_tx_ports]</code> or <code>[]</code></td>
</tr>
<tr>
  <td><code>coupling_im_tx</code></td>
  <td>Imaginary part of coupling matrix, optional</td>
  <td>Size: <code>[n_tx_elements, n_tx_ports]</code> or <code>[]</code></td>
</tr>
</table><br>
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b>RX Antenna data:</b> (inputs 10-18, single or double) 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>e_theta_re_rx</code></td>
  <td>Real part of e-theta field component</td>
  <td>Size: <code>[n_elevation_rx, n_azimuth_rx, n_rx_elements]</code></td>
</tr>
<tr>
  <td><code>e_theta_im_rx</code></td>
  <td>Imaginary part of e-theta field component</td>
  <td>Size: <code>[n_elevation_rx, n_azimuth_rx, n_rx_elements]</code></td>
</tr>
<tr>
  <td><code>e_phi_re_rx</code></td>
  <td>Real part of e-phi field component</td>
  <td>Size: <code>[n_elevation_rx, n_azimuth_rx, n_rx_elements]</code></td>
</tr>
<tr>
  <td><code>e_phi_im_rx</code></td>
  <td>Imaginary part of e-phi field component</td>
  <td>Size: <code>[n_elevation_rx, n_azimuth_rx, n_rx_elements]</code></td>
</tr>
<tr>
  <td><code>azimuth_grid_rx</code></td>
  <td>Azimuth angles in [rad] -pi to pi, sorted</td>
  <td>Size: <code>[n_azimuth_rx]</code></td>
</tr>
<tr>
  <td><code>elevation_grid_rx</code></td>
  <td>Elevation angles in [rad], -pi/2 to pi/2, sorted</td>
  <td>Size: <code>[n_elevation_rx]</code></td>
</tr>
<tr>
  <td><code>element_pos_rx</code></td>
  <td>Antenna element (x,y,z) positions, optional</td>
  <td>Size: <code>[3, n_rx_elements]</code> or <code>[]</code></td>
</tr>
<tr>
  <td><code>coupling_re_rx</code></td>
  <td>Real part of coupling matrix, optional</td>
  <td>Size: <code>[n_rx_elements, n_rx_ports]</code> or <code>[]</code></td>
</tr>
<tr>
  <td><code>coupling_im_rx</code></td>
  <td>Imaginary part of coupling matrix, optional</td>
  <td>Size: <code>[n_rx_elements, n_rx_ports]</code> or <code>[]</code></td>
</tr>
</table><br>
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>fbs_pos</code></b><br> 
   First interaction point of the rays and the environment; Size: <code>[ 3, n_path ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>lbs_pos</code></b><br> 
   Last interaction point of the rays and the environment; For single-bounce models, this must be  
   identical to <code>fbs_pos</code>. Size: <code>[ 3, n_path ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>path_gain</code></b><br> 
   Path gain (linear scale); Size: <code>[ 1, n_path ]</code> or <code>[ n_path, 1 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>path_length</code></b><br> 
   Total path length in meters; If <code>path_length</code> is shorter than the shortest possible path from TX to  
   FBS to LBS to RX, it is replaced by the shortest path length. <br>Size: <code>[ 1, n_path ]</code> or <code>[ n_path, 1 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>M</code></b><br> 
   Polarization transfer matrix; interleaved complex values (ReVV, ImVV, ReVH, ImVH, ReHV, ImHV, ReHH, ImHH); 
   Size: <code>[ 8, n_path ]</code>  
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>tx_pos</code></b><br> 
   Transmitter position in 3D Cartesian coordinates; Size: <code>[3,1]</code> or <code>[1,3]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>tx_orientation</code></b><br> 
   3-element vector describing the orientation of the transmit antenna. The The first value describes  
   the ”bank angle”, the second value describes the  ”tilt angle”, (positive values point upwards),  
   the third value describes the bearing or ”heading angle”, in mathematic sense. Values must be given  
   in [rad]. East corresponds to 0, and the angles increase counter-clockwise, so north is pi/2, south  
   is -pi/2, and west is equal to pi. Single or double precision, Size: <code>[3,1]</code> or <code>[1,3]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>rx_pos</code></b><br> 
   Receiver position in 3D Cartesian coordinates; Size: <code>[3,1]</code> or <code>[1,3]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>rx_orientation</code></b><br> 
   3-element vector describing the orientation of the receive antenna. Size: <code>[3,1]</code> or <code>[1,3]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>center_freq</code></b><br> 
   Center frequency in [Hz]; optional; If the value is not provided or set to 0, phase calculation  
   in coefficients is disabled, i.e. that path length has not influence on the results. This can be  
   used to calculate the antenna response for a specific angle and polarization. Scalar value 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>use_absolute_delays</code></b> (optional)<br> 
   If true, the LOS delay is included for all paths; Default is <code>false</code>, i.e. delays are normalized 
   to the LOS delay. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>add_fake_los_path</code></b> (optional)<br> 
   If true, adds a zero-power LOS path as the first path in case where no LOS path was present. 
   Default: <code>false</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>coeff_re</code></b><br> 
   Channel coefficients, real part, Size: <code>[ n_rx_ports, n_tx_ports, n_path ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>coeff_im</code></b><br> 
   Channel coefficients, imaginary part, Size: <code>[ n_rx_ports, n_tx_ports, n_path ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>delays</code></b><br> 
   Propagation delay in seconds, Size: <code>[ n_rx_ports, n_tx_ports, n_path ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>aod</code></b> (optional)<br> 
   Azimuth of Departure angles in [rad], Size: <code>[ n_rx_ports, n_tx_ports, n_path ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>eod</code></b> (optional)<br> 
   Elevation of Departure angles in [rad], Size: <code>[ n_rx_ports, n_tx_ports, n_path ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>aoa</code></b> (optional)<br> 
   Azimuth of Arrival angles in [rad], Size: <code>[ n_rx_ports, n_tx_ports, n_path ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>eoa</code></b> (optional)<br> 
   Elevation of Arrival angles in [rad], Size: <code>[ n_rx_ports, n_tx_ports, n_path ]</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Caveat:</i></b><br><ul><li style="margin-bottom: 0.4em;">Antenna patterns, <code>fbs_pos</code>, <code>lbs_pos</code>, <code>path_gain</code>, <code>path_length</code>, and <code>M</code> can be provided in  
   single or double precision, but types must match. Outputs are returned in the same type. 
</li><li style="margin-bottom: 0.4em;">Input data is directly accessed from MATLAB / Octave memory, without copying. To improve performance 
   of repeated computations (e.g. in loops), consider preparing the data accordingly to avoid unecessary  
   computation. 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div>
<hr class="greyline">
<hr class="greyline">
<br>
<br>
<font size=+1><b>Channel functions</b></font>
<br>
<br>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="baseband_freq_response"></a>
<b>baseband_freq_response</b> - Transforms the channel into frequency domain and returns the frequency response
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
[ hmat_re, hmat_im ] = quadriga_lib.baseband_freq_response( coeff_re, coeff_im, delay, pilot_grid, bandwidth, i_snap );
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>coeff_re</code></b><br> 
   Channel coefficients, real part, Size: <code>[ n_rx, n_tx, n_path, n_snap ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>coeff_im</code></b><br> 
   Channel coefficients, imaginary part, Size: <code>[ n_rx, n_tx, n_path, n_snap ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>delays</code></b><br> 
   Propagation delay in seconds, Size: <code>[ n_rx, n_tx, n_path, n_snap ]</code> or <code>[ 1, 1, n_path, n_snap ]</code>  
   or <code>[ n_path, n_snap ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>pilot_grid</code></b><br> 
   Sub-carrier positions relative to the bandwidth. The carrier positions are given relative to the 
   bandwidth where '0' is the begin of the spectrum (i.e., the center frequency f0) and '1' is 
   equal to f0+bandwidth. To obtain the channel frequency response centered around f0, the 
   input variable 'pilot_grid' must be set to '(-N/2:N/2)/N', where N is the number of sub- 
   carriers. Vector of length: <code>[ n_carriers ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>bandwidth</code></b><br> 
   The baseband bandwidth in [Hz], scalar 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>i_snap</code></b> (optional)<br> 
   Snapshot indices for which the frequency response should be generated (1-based index). If this 
   variable is not given, all snapshots are processed. Length: <code>[ n_out ]</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Argument:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>hmat_re</code></b><br> 
   Freq. domain channel matrices (H), real part, Size <code>[ n_rx, n_tx, n_carriers, n_out ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>hmat_im</code></b><br> 
   Freq. domain channel matrices (H), imaginary part, Size <code>[ n_rx, n_tx, n_carriers, n_out ]</code> 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="channel_export_obj_file"></a>
<b>channel_export_obj_file</b> - Export path data to a Wavefront OBJ file for visualization in Blender
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>This function exports path data to a Wavefront OBJ file, which can be used for visualization in 3D 
software such as Blender. It supports various colormaps for color-coding the paths based on their 
gain values. In addition, the function allows you to control the maximum number of paths displayed, 
set gain thresholds for color-coding and selection.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
quadriga_lib.channel_export_obj_file( fn, max_no_paths, gain_max, gain_min, colormap, radius_max,
    radius_min, n_edges, rx_position, tx_position, no_interact, interact_coord, center_freq,
    coeff_re, coeff_im, i_snap )
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>fn</code></b><br> 
   Filename of the OBJ file, string, required 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>max_no_paths</code></b> (optional)<br> 
   Maximum number of paths to be shown, optional, default: 0 = export all above <code>gain_min</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>gain_max</code></b> (optional)<br> 
   Maximum path gain in dB (only for color-coding), optional, default = -60.0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>gain_min</code></b> (optional)<br> 
   Minimum path gain in dB (for color-coding and path selection), optional, default = -140.0 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>colormap</code></b> (optional)<br> 
   Colormap for the visualization, string, supported are 'jet', 'parula', 'winter', 'hot', 'turbo', 
   'copper', 'spring', 'cool', 'gray', 'autumn', 'summer', optional, default = 'jet' 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>radius_max</code></b> (optional)<br> 
   Maximum tube radius in meters, optional, default = 0.05 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>radius_min</code></b> (optional)<br> 
   Minimum tube radius in meters, optional, default = 0.01 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>n_edges</code></b> (optional)<br> 
   Number of vertices in the circle building the tube, must be >= 3, optional, default = 5 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>rx_position</code></b><br> 
   Receiver positions, required, size <code>[3, n_snap]</code> or <code>[3, 1]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>tx_position</code></b><br> 
   Transmitter positions, required, size <code>[3, n_snap]</code> or <code>[3, 1]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>no_interact</code></b><br> 
   Number interaction points of paths with the environment, required, uint32, Size <code>[n_path, n_snap]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>interact_coord</code></b><br> 
   Interaction coordinates, required, Size <code>[3, max(sum(no_interact)), n_snap]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>center_freq</code></b><br> 
   Center frequency in [Hz], required, Size <code>[n_snap, 1]</code> or scalar 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>coeff_re</code></b><br> 
   Channel coefficients, real part, Size: <code>[ n_rx, n_tx, n_path, n_snap ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>coeff_im</code></b><br> 
   Channel coefficients, imaginary part, Size: <code>[ n_rx, n_tx, n_path, n_snap ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>i_snap</code></b><br> (optional) 
   Snapshot indices, optional, 1-based, range [1 ... n_snap] 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Argument:</i></b><br>This function does not return a value. It writes the OBJ file directly to disk.
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="hdf5_create_file"></a>
<b>hdf5_create_file</b> - Create a new HDF5 channel file with a custom storage layout
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>Quadriga-Lib offers an HDF5-based method for storing and managing channel data. A key feature of this 
library is its ability to organize multiple channels within a single HDF5 file while enabling access 
to individual data sets without the need to read the entire file. In this system, channels can be 
structured in a multi-dimensional array. For instance, the first dimension might represent the Base 
Station (BS), the second the User Equipment (UE), and the third the frequency. However, it is important 
to note that the dimensions of the storage layout must be defined when the file is initially created 
and cannot be altered thereafter. The function <code>quadriga_lib.hdf5_create_file</code> is used to create an 
empty file with a predetermined custom storage layout.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
quadriga_lib.hdf5_create_file( fn, storage_dims );
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>fn</code></b><br> 
   Filename of the HDF5 file, string 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>storage_dims</code></b> (optional)<br> 
   Size of the dimensions of the storage space, vector with 1-4 elements, i.e. <code>[nx]</code>, <code>[nx, ny]</code>,  
   <code>[nx,ny,nz]</code> or <code>[nx,ny,nz,nw]</code>. By default, <code>nx = 65536, ny = 1, nz = 1, nw = 1</code> 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="hdf5_read_channel"></a>
<b>hdf5_read_channel</b> - Reads channel data from HDF5 files
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>Quadriga-Lib provides an HDF5-based solution for storing and organizing channel data. This data  
comprises various well-defined sets, including channel coefficients, positions of transmitters and  
receivers, as well as path data that reflects the interaction of radio waves with the environment.  
Typically, these datasets are multi-dimensional, encompassing data for <code>n_rx</code> receive antennas,  
<code>n_tx</code> transmit antennas, <code>n_path</code> propagation paths, and <code>n_snap</code> snapshots. Snapshots are  
particularly useful for recording data across different locations (such as along a trajectory) or  
various frequencies. It is important to note that not all datasets include all these dimensions.<br><br> 
 
The library also supports the addition of extra datasets of any type or shape, which can be useful  
for incorporating descriptive data or analysis results. To facilitate data access, the function  
<code>quadriga_lib.hdf5_read_channel</code> is designed to read both structured and unstructured data from the  
file.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
[ par, rx_position, tx_position, coeff_re, coeff_im, delay, center_freq, name, initial_pos, ...
   path_gain, path_length, path_polarization, path_angles, path_fbs_pos, path_lbs_pos, no_interact, ...
   interact_coord, rx_orientation, tx_orientation ] = quadriga_lib.hdf5_read_channel( fn, location, snap );
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>fn</code></b><br> 
   Filename of the HDF5 file, string 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>location</code></b> (optional)<br> 
   Storage location inside the file; 1-based; vector with 1-4 elements, i.e. <code>[ix]</code>, <code>[ix, iy]</code>,  
   <code>[ix,iy,iz]</code> or <code>[ix,iy,iz,iw]</code>; Default: <code>ix = iy = iz = iw = 1</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>snap</code></b> (optional)<br> 
   Snapshot range; optional; vector, default = read all 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>par</code></b><br> 
   Unstructured data as struct, may be empty if no unstructured data is present 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b>Structured data:</b> (outputs 2-19, single precision) 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>rx_position</code></td>
  <td>Receiver positions</td>
  <td><code>[3, n_snap]</code> or <code>[3, 1]</code></td>
</tr>
<tr>
  <td><code>tx_position</code></td>
  <td>Transmitter positions</td>
  <td><code>[3, n_snap]</code> or <code>[3, 1]</code></td>
</tr>
<tr>
  <td><code>coeff_re</code></td>
  <td>Channel coefficients, real part</td>
  <td><code>[n_rx, n_tx, n_path, n_snap]</code></td>
</tr>
<tr>
  <td><code>coeff_im</code></td>
  <td>Channel coefficients, imaginary part</td>
  <td><code>[n_rx, n_tx, n_path, n_snap]</code></td>
</tr>
<tr>
  <td><code>delay</code></td>
  <td>Propagation delays in seconds</td>
  <td><code>[n_rx, n_tx, n_path, n_snap]</code> or <code>[1, 1, n_path, n_snap]</code></td>
</tr>
<tr>
  <td><code>center_freq</code></td>
  <td>Center frequency in [Hz]</td>
  <td><code>[n_snap, 1]</code> or scalar</td>
</tr>
<tr>
  <td><code>name</code></td>
  <td>Name of the channel</td>
  <td>String</td>
</tr>
<tr>
  <td><code>initial_pos</code></td>
  <td>Index of reference position, 1-based</td>
  <td>uint32, scalar</td>
</tr>
<tr>
  <td><code>path_gain</code></td>
  <td>Path gain before antenna, linear scale</td>
  <td><code>[n_path, n_snap]</code></td>
</tr>
<tr>
  <td><code>path_length</code></td>
  <td>Path length from TX to RX phase center in m</td>
  <td><code>[n_path, n_snap]</code></td>
</tr>
<tr>
  <td><code>polarization</code></td>
  <td>Polarization transfer function, interleaved complex</td>
  <td><code>[8, n_path, n_snap]</code></td>
</tr>
<tr>
  <td><code>path_angles</code></td>
  <td>Departure and arrival angles {AOD, EOD, AOA, EOA} in rad</td>
  <td><code>[n_path, 4, n_snap]</code></td>
</tr>
<tr>
  <td><code>path_fbs_pos</code></td>
  <td>First-bounce scatterer positions</td>
  <td><code>[3, n_path, n_snap]</code></td>
</tr>
<tr>
  <td><code>path_lbs_pos</code></td>
  <td>Last-bounce scatterer positions</td>
  <td><code>[3, n_path, n_snap]</code></td>
</tr>
<tr>
  <td><code>no_interact</code></td>
  <td>Number interaction points of paths with the environment</td>
  <td>uint32, <code>[n_path, n_snap]</code></td>
</tr>
<tr>
  <td><code>interact_coord</code></td>
  <td>Interaction coordinates</td>
  <td><code>[3, max(sum(no_interact)), n_snap]</code></td>
</tr>
<tr>
  <td><code>rx_orientation</code></td>
  <td>Transmitter orientation</td>
  <td><code>[3, n_snap]</code> or <code>[3, 1]</code></td>
</tr>
<tr>
  <td><code>tx_orientation</code></td>
  <td>Receiver orientation</td>
  <td><code>[3, n_snap]</code> or <code>[3, 1]</code></td>
</tr>
</table><br>
    
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Caveat:</i></b><br><ul><li style="margin-bottom: 0.4em;">Empty outputs are returned if data set does not exist in the file 
</li><li style="margin-bottom: 0.4em;">All structured data is stored in single precision. Hence, outputs are also in single precision. 
</li><li style="margin-bottom: 0.4em;">Unstructured datatypes are returned as stored in the HDF file (same type, dimensions and storage order) 
</li><li style="margin-bottom: 0.4em;">Typically, <code>n_path</code> may vary for each snapshot. In such cases, <code>n_path</code> is set to the maximum value found  
   within the range of snapshots, and any missing paths are padded with zeroes. 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="hdf5_read_dset"></a>
<b>hdf5_read_dset</b> - Read a single unstructured dataset from an HDF5 file
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>Quadriga-Lib offers a solution based on HDF5 for storing and organizing channel data. In addition  
to structured datasets, the library facilitates the inclusion of extra datasets of various types  
and shapes. This feature is particularly beneficial for integrating descriptive data or analysis  
results. The function <code>quadriga_lib.hdf5_read_dset</code> retrieves a single unstructured dataset. The 
output type of the function is defined by the datatype in the file. An empty matrix is returned  
if the dataset does not exist in the file.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
dset = quadriga_lib.hdf5_read_dset_names( fn, location, name );
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>fn</code></b><br> 
   Filename of the HDF5 file, string 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>location</code></b> (optional)<br> 
   Storage location inside the file; 1-based; vector with 1-4 elements, i.e. <code>[ix]</code>, <code>[ix, iy]</code>,  
   <code>[ix,iy,iz]</code> or <code>[ix,iy,iz,iw]</code>; Default: <code>ix = iy = iz = iw = 1</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>name</code></b><br> 
   Name of the dataset; String 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Argument:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>dset</code></b><br> 
   Output data. Type and size is defined by the dataspace in the file 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="hdf5_read_dset_names"></a>
<b>hdf5_read_dset_names</b> - Read the names of unstructured data fields from an HDF5 file
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>Quadriga-Lib offers a solution based on HDF5 for storing and organizing channel data. In addition  
to structured datasets, the library facilitates the inclusion of extra datasets of various types  
and shapes. This feature is particularly beneficial for integrating descriptive data or analysis  
results. Users can add any number of such unstructured datasets, each identified by a unique  
dataset name. The function <code>quadriga_lib.hdf5_read_dset_names</code> retrieves the names of all these  
datasets, returning them as a cell array of strings.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
names = quadriga_lib.hdf5_read_dset_names( fn, location );
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>fn</code></b><br> 
   Filename of the HDF5 file, string 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>location</code></b> (optional)<br> 
   Storage location inside the file; 1-based; vector with 1-4 elements, i.e. <code>[ix]</code>, <code>[ix, iy]</code>,  
   <code>[ix,iy,iz]</code> or <code>[ix,iy,iz,iw]</code>; Default: <code>ix = iy = iz = iw = 1</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Argument:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>names</code></b><br> 
   List of names of all these at the given location in the files; Cell array of strings 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="hdf5_read_layout"></a>
<b>hdf5_read_layout</b> - Read the storage layout of channel data inside an HDF5 file
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>Quadriga-Lib provides an HDF5-based solution for the storage and organization of channel data. A  
notable feature of this library is its capacity to manage multiple channels within a single HDF5  
file. In this framework, channels can be arranged in a multi-dimensional array format. 
 
The function <code>quadriga_lib.hdf5_read_layout</code> is designed to read the storage layout from an  
existing file. Furthermore, it also generates an array that marks the locations within the layout  
where data already exists. This functionality aids in efficiently managing and accessing channel  
data within the HDF5 file structure.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
[ storage_dims, has_data ] = quadriga_lib.hdf5_read_layout( fn );
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Argument:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>fn</code></b><br> 
   Filename of the HDF5 file, string 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>storage_dims</code></b><br> 
   Size of the dimensions of the storage space, vector with 4 elements, i.e. <code>[nx,ny,nz,nw]</code>. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>has_data</code></b><br> 
   Array indicating if data exists (value 1) or not (value 0); uint32; Size: <code>[nx,ny,nz,nw]</code> 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="hdf5_reshape_layout"></a>
<b>hdf5_reshape_layout</b> - Reshapes the storage layout inside an existing HDF5 file
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>Quadriga-Lib provides an HDF5-based solution for the storage and organization of channel data. A  
notable feature of this library is its capacity to manage multiple channels within a single HDF5  
file. In this framework, channels can be arranged in a multi-dimensional array format. 
Once an HDF5 file has been created, the number of channels in the storage layout is fixed.  
However, it is possible to reshape the layout using <code>quadriga_lib.hdf5_reshape_layout</code>.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
quadriga_lib.hdf5_reshape_layout( fn, storage_dims );
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>fn</code></b><br> 
   Filename of the HDF5 file, string 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>storage_dims</code></b><br> 
   Size of the dimensions of the storage space, vector with 1-4 elements, i.e. <code>[nx]</code>, <code>[nx, ny]</code>,  
   <code>[nx,ny,nz]</code> or <code>[nx,ny,nz,nw]</code>. By default, <code>nx = 65536, ny = 1, nz = 1, nw = 1</code><br> 
   An error is thrown if the number of elements in the file is different from the given size. 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="hdf5_write_channel"></a>
<b>hdf5_write_channel</b> - Writes channel data to HDF5 files
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>Quadriga-Lib provides an HDF5-based solution for storing and organizing channel data. This function 
can be used to write structured and unstructured data to an HDF5 file.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
storage_dims = quadriga_lib.hdf5_write_channel( fn, location, rx_position, tx_position, ...
   coeff_re, coeff_im, delay, center_freq, name, initial_pos, path_gain, path_length, ...
   path_polarization, path_angles, path_fbs_pos, path_lbs_pos, no_interact, interact_coord, ...
   rx_orientation, tx_orientation )
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>fn</code></b><br> 
   Filename of the HDF5 file, string 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>location</code></b> (optional)<br> 
   Storage location inside the file; 1-based; vector with 1-4 elements, i.e. <code>[ix]</code>, <code>[ix, iy]</code>,  
   <code>[ix,iy,iz]</code> or <code>[ix,iy,iz,iw]</code>; Default: <code>ix = iy = iz = iw = 1</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>par</code></b><br> 
   Unstructured data as struct, can be empty if no unstructured data should be written 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b>Structured data:</b> (inputs 4-21, single or double precision) 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>rx_position</code></td>
  <td>Receiver positions</td>
  <td><code>[3, n_snap]</code> or <code>[3, 1]</code></td>
</tr>
<tr>
  <td><code>tx_position</code></td>
  <td>Transmitter positions</td>
  <td><code>[3, n_snap]</code> or <code>[3, 1]</code></td>
</tr>
<tr>
  <td><code>coeff_re</code></td>
  <td>Channel coefficients, real part</td>
  <td><code>[n_rx, n_tx, n_path, n_snap]</code></td>
</tr>
<tr>
  <td><code>coeff_im</code></td>
  <td>Channel coefficients, imaginary part</td>
  <td><code>[n_rx, n_tx, n_path, n_snap]</code></td>
</tr>
<tr>
  <td><code>delay</code></td>
  <td>Propagation delays in seconds</td>
  <td><code>[n_rx, n_tx, n_path, n_snap]</code> or <code>[1, 1, n_path, n_snap]</code></td>
</tr>
<tr>
  <td><code>center_freq</code></td>
  <td>Center frequency in [Hz]</td>
  <td><code>[n_snap, 1]</code> or scalar</td>
</tr>
<tr>
  <td><code>name</code></td>
  <td>Name of the channel</td>
  <td>String</td>
</tr>
<tr>
  <td><code>initial_pos</code></td>
  <td>Index of reference position, 1-based</td>
  <td>uint32, scalar</td>
</tr>
<tr>
  <td><code>path_gain</code></td>
  <td>Path gain before antenna, linear scale</td>
  <td><code>[n_path, n_snap]</code></td>
</tr>
<tr>
  <td><code>path_length</code></td>
  <td>Path length from TX to RX phase center in m</td>
  <td><code>[n_path, n_snap]</code></td>
</tr>
<tr>
  <td><code>polarization</code></td>
  <td>Polarization transfer function, interleaved complex</td>
  <td><code>[8, n_path, n_snap]</code></td>
</tr>
<tr>
  <td><code>path_angles</code></td>
  <td>Departure and arrival angles {AOD, EOD, AOA, EOA} in rad</td>
  <td><code>[n_path, 4, n_snap]</code></td>
</tr>
<tr>
  <td><code>path_fbs_pos</code></td>
  <td>First-bounce scatterer positions</td>
  <td><code>[3, n_path, n_snap]</code></td>
</tr>
<tr>
  <td><code>path_lbs_pos</code></td>
  <td>Last-bounce scatterer positions</td>
  <td><code>[3, n_path, n_snap]</code></td>
</tr>
<tr>
  <td><code>no_interact</code></td>
  <td>Number interaction points of paths with the environment</td>
  <td>uint32, <code>[n_path, n_snap]</code></td>
</tr>
<tr>
  <td><code>interact_coord</code></td>
  <td>Interaction coordinates</td>
  <td><code>[3, max(sum(no_interact)), n_snap]</code></td>
</tr>
<tr>
  <td><code>rx_orientation</code></td>
  <td>Transmitter orientation</td>
  <td><code>[3, n_snap]</code> or <code>[3, 1]</code></td>
</tr>
<tr>
  <td><code>tx_orientation</code></td>
  <td>Receiver orientation</td>
  <td><code>[3, n_snap]</code> or <code>[3, 1]</code></td>
</tr>
</table><br>
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>storage_dims</code></b><br> 
   Size of the dimensions of the storage space, vector with 4 elements, i.e. <code>[nx,ny,nz,nw]</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Caveat:</i></b><br><ul><li style="margin-bottom: 0.4em;">If the file exists already, the new data is added to the exisiting file 
</li><li style="margin-bottom: 0.4em;">If a new file is created, a storage layout is created to store the location of datasets in the file 
</li><li style="margin-bottom: 0.4em;">For <code>location = [ix]</code> storage layout is <code>[65536,1,1,1]</code> or <code>[ix,1,1,1]</code> if (<code>ix > 65536</code>) 
</li><li style="margin-bottom: 0.4em;">For <code>location = [ix,iy]</code> storage layout is <code>[1024,64,1,1]</code> 
</li><li style="margin-bottom: 0.4em;">For <code>location = [ix,iy,iz]</code> storage layout is <code>[256,16,16,1]</code> 
</li><li style="margin-bottom: 0.4em;">For <code>location = [ix,iy,iz,iw]</code> storage layout is <code>[128,8,8,8]</code> 
</li><li style="margin-bottom: 0.4em;">You can create a custom storage layout by creating the file first using "<code>hdf5_create_file</code>" 
</li><li style="margin-bottom: 0.4em;">You can reshape the storage layout by using "<code>hdf5_reshape_storage</code>", but the total number of elements must not change 
</li><li style="margin-bottom: 0.4em;">Inputs can be empty or missing. 
</li><li style="margin-bottom: 0.4em;">All structured data is written in single precision (but can can be provided as single or double) 
</li><li style="margin-bottom: 0.4em;">Unstructured datatypes are maintained in the HDF file 
</li><li style="margin-bottom: 0.4em;">Supported unstructured types: string, double, float, (u)int32, (u)int64 
</li><li style="margin-bottom: 0.4em;">Supported unstructured size: up to 3 dimensions 
</li><li style="margin-bottom: 0.4em;">Storage order of the unstructured data is maintained 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="hdf5_write_dset"></a>
<b>hdf5_write_dset</b> - Writes unstructured data to a HDF5 file
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>Quadriga-Lib offers a solution based on HDF5 for storing and organizing channel data. In addition  
to structured datasets, the library facilitates the inclusion of extra datasets of various types  
and shapes. This feature is particularly beneficial for integrating descriptive data or analysis  
results. The function <code>quadriga_lib.hdf5_write_dset</code> writes a single unstructured dataset.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
storage_dims = quadriga_lib.hdf5_write_dset( fn, location, name, data );
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>fn</code></b><br> 
   Filename of the HDF5 file, string 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>location</code></b> (optional)<br> 
   Storage location inside the file; 1-based; vector with 1-4 elements, i.e. <code>[ix]</code>, <code>[ix, iy]</code>,  
   <code>[ix,iy,iz]</code> or <code>[ix,iy,iz,iw]</code>; Default: <code>ix = iy = iz = iw = 1</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>name</code></b><br> 
   Name of the dataset; String 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>data</code></b><br> 
   Data to be written 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Argument:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>storage_dims</code></b><br> 
   Size of the dimensions of the storage space, vector with 4 elements, i.e. <code>[nx,ny,nz,nw]</code>. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Caveat:</i></b><br><ul><li style="margin-bottom: 0.4em;">Throws an error if dataset already exists at this location 
</li><li style="margin-bottom: 0.4em;">Throws an error if file does not exist (use hdf5_create_file) 
</li><li style="margin-bottom: 0.4em;">Supported types: string, double, float, (u)int32, (u)int64 
</li><li style="margin-bottom: 0.4em;">Supported size: up to 3 dimensions 
</li><li style="margin-bottom: 0.4em;">Storage order is maintained 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div>
<hr class="greyline">
<hr class="greyline">
<br>
<br>
<font size=+1><b>Miscellaneous / Tools</b></font>
<br>
<br>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="calc_rotation_matrix "></a>
<b>calc_rotation_matrix </b> - Calculates a 3x3 rotation matrix from a 3-element orientation vector
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>In linear algebra, a rotation matrix is a transformation matrix that is used to perform a rotation  
in Euclidean space. The rotation of a rigid body (or three-dimensional coordinate system with a  
fixed origin) is described by a single rotation about some axis. Such a rotation may be uniquely  
described by three real-valued parameters. The idea behind Euler rotations is to split the complete  
rotation of the coordinate system into three simpler constitutive rotations, called precession,  
nutation, and intrinsic rotation, being each one of them an increment on one of the Euler angles. In  
aviation orientation of the aircraft is usually expressed as intrinsic Tait-Bryan angles following  
the z-y-x convention, which are called heading, tilt, and bank (or synonymously, yaw, pitch,  
and roll). This function calculates the 3x3 rotation matrix <b>R</b> from the intrinsic Tait-Bryan  
(orientation) angles.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
rotation = quadriga_lib.calc_rotation_matrix( orientation, invert_y_axis, transpose )
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Example:</i></b><br>The following example obtains the 3x3 matrix R for a 45 degree rotation around the z-axis: 
 
<pre>
bank    = 0;
tilt    = 0;
heading = 45 * pi/180;

orientation = [ bank; tilt; heading ];
rotation = quadriga_lib.calc_rotation_matrix( orientation );
R = reshape( rotation, 3, 3 );
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>orientation</code></b><br> 
   This 3-element vector describes the orientation of the array antenna or of individual array elements. 
   The The first value describes the ”bank angle”, the second value describes the  ”tilt angle”,  
   (positive values point upwards), the third value describes the bearing or ”heading angle”, in  
   mathematic sense. Values must be given in [rad]. East corresponds to 0, and the angles increase  
   counter-clockwise, so north is pi/2, south is -pi/2, and west is equal to pi. <br> 
   Single or double precision, Size: <code>[3, n_row, n_col]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>invert_y_axis</code></b><br> 
   Optional parameter. If set to 1, the rotation around the y-axis is inverted. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>transpose</code></b><br> 
   Optional parameter. If set to 1, the output is transposed. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Argument:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>rotation</code></b><br> 
   The rotation matrix, i.e. a transformation matrix that is used to perform a rotation in 3D  
   Euclidean space. The matrix produces the desired effect only if it is used to premultiply column  
   vectors. The rotations are applies in the order: heading (around z axis), tilt (around y axis)  
   and bank (around x axis). The 9 elements of the rotation matrix are returned in column-major  
   order. Single or double precision (same as input), Size: <code>[9, n_row, n_col]</code> 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="cart2geo"></a>
<b>cart2geo</b> - Transform Cartesian (x,y,z) coordinates to Geographic (az, el, length) coordinates
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>This function transforms Cartesian (x,y,z) coordinates to Geographic (azimuth, elevation, length) 
coordinates. A geographic coordinate system is a three-dimensional reference system that locates 
points on the surface of a sphere. A point has three coordinate values: azimuth, elevation and length 
where azimuth and elevation measure angles. In the geographic coordinate system, the elevation angle 
θ = 90° points to the zenith and θ = 0° points to the horizon.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
[ azimuth, elevation, length ] = arrayant_lib.cart2geo( cart )
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Argument:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>cart</code></b><br> 
   Cartesian coordinates (x,y,z) 
   Single or double precision, Size: <code>[3, n_row, n_col]</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>azimuth</code></b><br> 
   Azimuth angles in [rad], values between -pi and pi. 
   Single or double precision (same as input), Size <code>[n_row, n_col]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>elevation</code></b><br> 
   Elevation angles in [rad], values between -pi/2 and pi/2. 
   Single or double precision (same as input), Size <code>[n_row, n_col]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>length</code></b><br> 
   Vector length, i.e. the distance from the origin to the point defined by x,y,z. 
   Single or double precision (same as input), Size <code>[n_row, n_col]</code> 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="geo2cart"></a>
<b>geo2cart</b> - Transform Geographic (az, el, length) to Cartesian (x,y,z) coordinates coordinates
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>This function transforms Geographic (azimuth, elevation, length) coordinates to Cartesian (x,y,z) 
coordinates. A geographic coordinate system is a three-dimensional reference system that locates 
points on the surface of a sphere. A point has three coordinate values: azimuth, elevation and length 
where azimuth and elevation measure angles. In the geographic coordinate system, the elevation angle 
θ = 90◦ points to the zenith and θ = 0◦ points to the horizon.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
cart = arrayant_lib.geo2cart( azimuth, elevation, length )
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>azimuth</code></b><br> 
   Azimuth angles in [rad], values between -pi and pi. 
   Single or double precision (same as input), Size <code>[n_row, n_col]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>elevation</code></b><br> 
   Elevation angles in [rad], values between -pi/2 and pi/2. 
   Single or double precision (same as input), Size <code>[n_row, n_col]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>length</code></b> (optional)<br> 
   Vector length, i.e. the distance from the origin to the point defined by x,y,z. 
   Single or double precision (same as input), Size <code>[n_row, n_col]</code> or empty <code>[]</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Argument:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>cart</code></b><br> 
   Cartesian coordinates (x,y,z) 
   Single or double precision, Size: <code>[3, n_row, n_col]</code> 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="version"></a>
<b>version</b> - Returns the quadriga-lib version number
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
version = quadriga_lib.version;
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Caveat:</i></b><br><ul><li style="margin-bottom: 0.4em;">If Quadriga-Lib was compiled with AVX2 support and the CPU supports intrinsic AVX2 instructions, 
   an suffix <code>_AVX2</code> is added after the version number 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="interp"></a>
<b>interp</b> - 2D and 1D linear interpolation.
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>This function implements 2D and 1D linear interpolation.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
dataI = quadriga_lib.interp( x, y, data, xI, yI );      % 2D case

dataI = quadriga_lib.interp( x, [], data, xI );         % 1D case
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>x</code></b><br> 
   Vector of sample points in x direction for which data is provided; single or double; Length: <code>[nx]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>y</code></b><br> 
   Vector of sample points in y direction for which data is provided; single or double; Length: <code>[ny]</code><br> 
   Must be an empty array <code>[]</code> in case of 1D interpolation. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>data</code></b><br> 
   The input data tensor; single or double; Size: <code>[ny, nx, ne]</code> or <code>[1, nx, ne]</code> for 1D case <br> 
   The 3rd dimension enables interpolation for mutiple datasets simultaneously. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>xI</code></b><br> 
   Vector of sample points in x direction for which data should be interpolated; single or double; 
   Length: <code>[nxI]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>yI</code></b><br> 
   Vector of sample points in y direction for which data should be interpolated; single or double; 
   Length: <code>[nyI]</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>dataI</code></b><br> 
   The interpolated dat; single or double (same as <code>data</code>); 
   Size: <code>[nyI, nxI, ne]</code> or <code>[1, nxI, ne]</code> for 1D case <br> 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div>
<hr class="greyline">
<hr class="greyline">
<br>
<br>
<font size=+1><b>Site-Specific Simulation Tools</b></font>
<br>
<br>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="generate_diffraction_paths"></a>
<b>generate_diffraction_paths</b> - Generate propagation paths for estimating the diffraction gain
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>Diffraction refers to the phenomenon where waves bend or interfere around the edges of an obstacle, 
extending into the region that would otherwise be in the obstacle's geometrical shadow. The object 
causing the diffraction acts as a secondary source for the wave's propagation. A specific example of 
this is the knife-edge effect, or knife-edge diffraction, where a sharp, well-defined obstacle—like 
a mountain range or a building wall—partially truncates the incident radiation.<br><br> 
 
To estimate the diffraction gain in a three-dimensional space, one can assess the extent to which the 
Fresnel ellipsoid is obstructed by objects, and then evaluate the impact of this obstruction on the 
received power. This method presupposes that diffracted waves travel along slightly varied paths 
before arriving at a receiver. These waves may reach the receiver out of phase with the primary wave 
due to their different travel lengths, leading to either constructive or destructive interference.<br><br> 
 
The process of estimating the gain involves dividing the wave propagation from a transmitter to a 
receiver into <code>n_path</code> paths. These paths are represented by elliptic arcs, which are further 
approximated using <code>n_seg</code> line segments. Each segment can be individually blocked or attenuated 
by environmental objects. To determine the overall diffraction gain, a weighted sum of these 
individual path contributions is calculated. The weighting is adjusted to align with the uniform 
theory of diffraction (UTD) coefficients in two dimensions, but the methodology is adapted for 
any 3D object shape. This function generates the elliptic propagation paths and corresponding weights 
necessary for this calculation.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Caveat:</i></b><br><ul><li style="margin-bottom: 0.4em;">Each ellipsoid consists of <code>n_path</code> diffraction paths. The number of paths is determined by the 
   level of detail (<code>lod</code>). 
</li><li style="margin-bottom: 0.4em;">All diffraction paths of an ellipsoid originate at <code>orig</code> and arrive at <code>dest</code> 
</li><li style="margin-bottom: 0.4em;">Each diffraction path has <code>n_seg</code> segments 
</li><li style="margin-bottom: 0.4em;">Points <code>orig</code> and <code>dest</code> lay on the semi-major axis of the ellipsoid 
</li><li style="margin-bottom: 0.4em;">The generated rays sample the volume of the ellipsoid 
</li><li style="margin-bottom: 0.4em;">Weights are calculated from the Knife-edge diffraction model when parts of the ellipsoid are shadowed 
</li><li style="margin-bottom: 0.4em;">Initial weights are normalized such that <code>sum(prod(weights,3),2) = 1</code> 
</li><li style="margin-bottom: 0.4em;">Inputs <code>orig</code> and <code>dest</code> may be provided as double or single precision 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
[ rays, weights ] = quadriga_lib.generate_diffraction_paths( orig, dest, center_frequency, lod );
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>orig</code></b><br> 
   Origin point of the propagation ellipsoid (e.g. transmitter positions). Size: <code>[ n_pos, 3 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>dest</code></b><br> 
   Destination point of the propagation ellipsoid (e.g. receiver positions). Size: <code>[ n_pos, 3 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>center_freq</code></b><br> 
   The center frequency in [Hz], scalar, default = 299792458 Hz 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>lod</code></b><br> 
   Level of detail, scalar value 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <td><code>lod = 1</code></td>
  <td>results in <code>n_path = 7</code> and <code>n_seg = 3</code></td>
</tr>
<tr>
  <td><code>lod = 2</code></td>
  <td>results in <code>n_path = 19</code> and <code>n_seg = 3</code></td>
</tr>
<tr>
  <td><code>lod = 3</code></td>
  <td>results in <code>n_path = 37</code> and <code>n_seg = 4</code></td>
</tr>
<tr>
  <td><code>lod = 4</code></td>
  <td>results in <code>n_path = 61</code> and <code>n_seg = 5</code></td>
</tr>
<tr>
  <td><code>lod = 5</code></td>
  <td>results in <code>n_path = 1</code> and <code>n_seg = 2</code> (for debugging)</td>
</tr>
<tr>
  <td><code>lod = 6</code></td>
  <td>results in <code>n_path = 2</code> and <code>n_seg = 2</code> (for debugging)</td>
</tr>
</table><br>
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>rays</code></b><br> 
   Coordinates of the generated rays; Size: <code>[ n_pos, n_path, n_seg-1, 3 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>weights</code></b><br> 
   Weights; Size: <code>[ n_pos, n_path, n_seg ]</code> 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="icosphere"></a>
<b>icosphere</b> - Construct a geodesic polyhedron (icosphere), a convex polyhedron made from triangles
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>An icosphere is constructed by subdividing faces of an icosahedron, a polyhedron with 20 faces, 
12 vertices and 30 edges, and then projecting the new vertices onto the surface of a sphere. The 
resulting mesh has 6 triangles at each vertex, except for 12 vertices which have 5 triangles. 
The approximate equilateral triangles have roughly the same edge length and surface area.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
[ center, length, vert, direction ] = quadriga_lib.icosphere( no_div, radius, direction_xyz );
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>no_div</code></b><br> 
   Number of divisions per edge of the generating icosahedron. The resulting number of faces is 
   equal to <code>no_face = 20 · no_div^2</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>radius</code></b><br> 
   Radius of the sphere in meters 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>direction_xyz</code></b><br> 
   Direction format indicator: 0 = Spherical (default), 1 = Cartesian 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>center</code></b><br> 
   Position of the center point of each triangle; Size: <code>[ no_face, 3 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>length</code></b><br> 
   Length of the vector pointing from the origin to the center point. This number is smaller than 
   1 since the triangles are located inside the unit sphere; <br>Size: <code>[ no_face ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>vert</code></b><br> 
   The 3 vectors pointing from the center point to the vertices of each triangle; the values are 
   in the order <code>[ v1x, v1y, v1z, v2x, v2y, v2z, v3x, v3y, v3z ]</code>; <br>Size: <code>[ no_face, 9 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>direction</code></b><br> 
   The directions of the vertex-rays. If the format indicator <code>direction_xyz</code> is set to <code>0</code>, the 
   output is in geographic coordinates (azimuth and elevation angle in rad); the values are in the 
   order <code>[ v1az, v1el, v2az, v2el, v3az, v3el ]</code>;Size: <code>[ no_face, 6 ]</code> If the format indicator 
   <code>direction_xyz</code> is set to <code>1</code>, the output is in Cartesian coordinates and the values are in the 
   order <code>[ v1x, v1y, v1z, v2x, v2y, v2z, v3x, v3y, v3z  ]</code>; Size: <code>[ no_face, 9 ]</code> 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="obj_file_read"></a>
<b>obj_file_read</b> - Reads a triangulated 3D polygon mesh from a Wavefront OBJ file
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>The function imports a polygon mesh from an OBJ file. The OBJ file format is a straightforward data 
format, exclusively representing 3D geometry. It details the position of each vertex and defines 
polygons as lists of these vertices. By default, vertices are arranged in a counter-clockwise order, 
eliminating the need for explicit declaration of face normals. When exporting the mesh from software 
like Blender, it's essential to triangulate the mesh and include material definitions. If the 
material name exists in the material database, the function loads the corresponding properties. 
Otherwise, it defaults to using standard properties.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
[ mesh, mtl_prop, vert_list, face_ind, obj_ind, mtl_ind, obj_names, mtl_names ] = ...
    quadriga_lib.obj_file_read( fn, use_single );
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>fn</code></b><br> 
   Filename of the OBJ file, string 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>use_single</code></b> (optional)<br> 
   Indicator if results should be returned in single precision, default = 0, returned in double precision 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>mesh</code></b><br> 
   Vertices of the triangular mesh in global Cartesian coordinates. Each face is described by 3 points 
   in 3D-space. Hence, a face has 9 values in the order [ v1x, v1y, v1z, v2x, v2y, v2z, v3x, v3y, v3z ]; <br> 
   Size: <code>[ no_mesh, 9 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>mtl_prop</code></b><br> 
   Material properties of each mesh element; If no material is defined for an object, the properties  
   for vacuum are used. Size: <code>[ no_mesh, 5 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>vert_list</code></b><br> 
   List of vertices found in the OBJ file; Size: <code>[ no_vert, 3 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>face_ind</code></b><br> 
   Triangular faces are defined by three vertices. Vertex indices match the corresponding vertex elements 
   of the previously defined <code>vert_list</code> (1-based indexing). <br> 
   uint32; Size: <code>[ no_mesh, 3 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>obj_id</code></b><br> 
   Mesh elements in the OBJ file can be grouped into objects (e.g. 12 triangles define the walls of a 
   cube). Each object is identified by a unique ID (1-based index). <br> 
   uint32; Size: <code>[ no_mesh, 1 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>mtl_id</code></b><br> 
   Each mesh element gets assigned a material and each unique material gets assigned an ID. Different 
   faces of an object can have different materials. If no material is defined in the OBJ file, the  
   id is set to <code>0</code> and no entry is made in <code>mtl_names</code>. <br> 
   uint32; Size: <code>[ no_mesh, 1 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>obj_names</code></b><br> 
   Names of the objects in the OBJ file; Cell array of strings 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>mtl_names</code></b><br> 
   Names of the materials in the OBJ file; Cell array of strings 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Material properties:</i></b><br>Each material is defined by its electrical properties. Radio waves that interact with a building will 
produce losses that depend on the electrical properties of the building materials, the material 
structure and the frequency of the radio wave. The fundamental quantities of interest are the electrical 
permittivity (ϵ) and the conductivity (σ). A simple regression model for the frequency dependence is 
obtained by fitting measured values of the permittivity and the conductivity at a number of frequencies. 
The five parameters returned in <code>mtl_prop</code> then are: 
 
<ul><li style="margin-bottom: 0.4em;">Real part of relative permittivity at f = 1 GHz (a) 
</li><li style="margin-bottom: 0.4em;">Frequency dependence of rel. permittivity (b) such that ϵ = a · f^b 
</li><li style="margin-bottom: 0.4em;">Conductivity at f = 1 GHz (c) 
</li><li style="margin-bottom: 0.4em;">Frequency dependence of conductivity (d) such that σ = c· f^d 
</li><li style="margin-bottom: 0.4em;">Fixed attenuation in dB applied to each transition 
</li></ul>
 
A more detailed explanation together with a derivation can be found in ITU-R P.2040. The following 
list of material is currently supported and the material can be selected by using the <code>usemtl</code> tag 
in the OBJ file. When using Blender, the simply assign a material with that name to an object or face. 
In addition, custom properties can be set by assigning adding the 5 properties after the material 
name, separated by <code>:</code>, e.g.: 
 
<pre>
usemtl custom::2.1:0.1:0.1:0.5:20
</pre>
 
The following materials are defined by default: 
 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <th>Name</th>
  <th>a</th>
  <th>b</th>
  <th>c</th>
  <th>d</th>
  <th>Att</th>
  <th>max fGHz</th>
  <th></th>
</tr>
<tr>
  <td>vacuum / air</td>
  <td>1.0</td>
  <td>0.0</td>
  <td>0.0</td>
  <td>0.0</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>textiles</td>
  <td>1.5</td>
  <td>0.0</td>
  <td>5e-5</td>
  <td>0.62</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>plastic</td>
  <td>2.44</td>
  <td>0.0</td>
  <td>2.33e-5</td>
  <td>1.0</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>ceramic</td>
  <td>6.5</td>
  <td>0.0</td>
  <td>0.0023</td>
  <td>1.32</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>sea_water</td>
  <td>80.0</td>
  <td>-0.25</td>
  <td>4.0</td>
  <td>0.58</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>sea_ice</td>
  <td>3.2</td>
  <td>-0.022</td>
  <td>1.1</td>
  <td>1.5</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>water</td>
  <td>80.0</td>
  <td>-0.18</td>
  <td>0.6</td>
  <td>1.52</td>
  <td>0.0</td>
  <td>20</td>
  <td></td>
</tr>
<tr>
  <td>water_ice</td>
  <td>3.17</td>
  <td>-0.005</td>
  <td>5.6e-5</td>
  <td>1.7</td>
  <td>0.0</td>
  <td>20</td>
  <td></td>
</tr>
<tr>
  <td>itu_concrete</td>
  <td>5.24</td>
  <td>0.0</td>
  <td>0.0462</td>
  <td>0.7822</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>itu_brick</td>
  <td>3.91</td>
  <td>0.0</td>
  <td>0.0238</td>
  <td>0.16</td>
  <td>0.0</td>
  <td>40</td>
  <td></td>
</tr>
<tr>
  <td>itu_plasterboard</td>
  <td>2.73</td>
  <td>0.0</td>
  <td>0.0085</td>
  <td>0.9395</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>itu_wood</td>
  <td>1.99</td>
  <td>0.0</td>
  <td>0.0047</td>
  <td>1.0718</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>itu_glass</td>
  <td>6.31</td>
  <td>0.0</td>
  <td>0.0036</td>
  <td>1.3394</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>itu_ceiling_board</td>
  <td>1.48</td>
  <td>0.0</td>
  <td>0.0011</td>
  <td>1.075</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>itu_chipboard</td>
  <td>2.58</td>
  <td>0.0</td>
  <td>0.0217</td>
  <td>0.78</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>itu_plywood</td>
  <td>2.71</td>
  <td>0.0</td>
  <td>0.33</td>
  <td>0.0</td>
  <td>0.0</td>
  <td>40</td>
  <td></td>
</tr>
<tr>
  <td>itu_marble</td>
  <td>7.074</td>
  <td>0.0</td>
  <td>0.0055</td>
  <td>0.9262</td>
  <td>0.0</td>
  <td>60</td>
  <td></td>
</tr>
<tr>
  <td>itu_floorboard</td>
  <td>3.66</td>
  <td>0.0</td>
  <td>0.0044</td>
  <td>1.3515</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>itu_metal</td>
  <td>1.0</td>
  <td>0.0</td>
  <td>1.0e7</td>
  <td>0.0</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>itu_very_dry_ground</td>
  <td>3.0</td>
  <td>0.0</td>
  <td>0.00015</td>
  <td>2.52</td>
  <td>0.0</td>
  <td>10</td>
  <td></td>
</tr>
<tr>
  <td>itu_medium_dry_ground</td>
  <td>15.0</td>
  <td>-0.1</td>
  <td>0.035</td>
  <td>1.63</td>
  <td>0.0</td>
  <td>10</td>
  <td></td>
</tr>
<tr>
  <td>itu_wet_ground</td>
  <td>30.0</td>
  <td>-0.4</td>
  <td>0.15</td>
  <td>1.3</td>
  <td>0.0</td>
  <td>10</td>
  <td></td>
</tr>
<tr>
  <td>itu_vegetation</td>
  <td>1.0</td>
  <td>0.0</td>
  <td>1.0e-4</td>
  <td>1.1</td>
  <td>0.0</td>
  <td>100</td>
  <td></td>
</tr>
<tr>
  <td>irr_glass</td>
  <td>6.27</td>
  <td>0.0</td>
  <td>0.0043</td>
  <td>1.1925</td>
  <td>23.0</td>
  <td>100</td>
  <td></td>
</tr>
</table><br>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="point_cloud_aabb"></a>
<b>point_cloud_aabb</b> - Calculate the axis-aligned bounding box (AABB) of set of points in 3D-sapce
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>The axis-aligned minimum bounding box (or AABB) for a given set points is its minimum bounding  
box subject to the constraint that the edges of the box are parallel to the (Cartesian) 
coordinate axes. Axis-aligned bounding boxes are used as an approximate location of the set of 
points.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
aabb = quadriga_lib.point_cloud_aabb( points, sub_cloud_index, vec_size );
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>points</code></b><br> 
   Points in 3D-Cartesian space; Size: [ n_points, 3 ] 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>sub_cloud_index</code></b> (optional)<br> 
   Start indices of the sub-clouds in 0-based notation. If this parameter is not given, the AABB of 
   the entire point cloud is returned. Type: uint32; Vector of length <code>[ n_sub_cloud ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>vec_size</code></b> (optional)<br> 
   Vector size for SIMD processing (e.g. 8 for AVX2, 32 for CUDA). Default value = 1. For values > 1, 
   the number of rows in the output is increased to a multiple of <code>vec_size</code>, padded with zeros. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Argument:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>aabb</code></b><br> 
   Axis-aligned bounding box of each sub-cloud. Each box is described by 6 values: 
   <code>[ x_min, x_max, y_min, y_max, z_min, z_max ]</code>; Size: <code>[ n_sub_cloud, 6 ]</code> 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="point_cloud_segmentation"></a>
<b>point_cloud_segmentation</b> - Rearranges elements of a point cloud into smaller sub-clouds
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>This function processes the elements of a large point cloud by clustering those that are 
closely spaced. The resulting cloud retains the same elements but rearranges their order. 
The function aims to minimize the size of the axis-aligned bounding box around each cluster, 
referred to as a sub-cloud, while striving to maintain a specific number of elements within 
each cluster.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
[ points_out, sub_cloud_index, forward_index, reverse_index ] = ...
    quadriga_lib.point_cloud_segmentation( points_in, target_size, vec_size );
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>points_in</code></b><br> 
   Points in 3D-Cartesian space; Size: <code>[ n_points_in, 3 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>target_size</code></b> (optional)<br> 
   The target number of elements of each sub-cloud. Default value = 1024. For best performance, the 
   value should be around 10 * sgrt( n_points_in ) 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>vec_size</code></b> (optional)<br> 
   Vector size for SIMD processing (e.g. 8 for AVX2, 32 for CUDA). Default value = 1. 
   For values > 1,the number of rows for each sub-cloud in the output is increased to a multiple 
   of <code>vec_size</code>. For padding, zero-sized triangles are placed at the center of the AABB of 
   the corresponding sub-cloud. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>points_out</code></b><br> 
   Points in 3D-Cartesian space; singe or double precision;  Size: <code>[ n_points_out, 9 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>sub_cloud_index</code></b><br> 
   Start indices of the sub-clouds in 0-based notation. Type: uint32; Vector of length <code>[ n_sub_cloud ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>forward_index</code></b><br> 
   Indices for mapping elements of "points_in" to "points_out"; 1-based; 
   Length: <code>[ n_points_out ]</code>; For <code>vec_size > 1</code>, the added elements not contained in the input 
   are indicated by zeros. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>reverse_index</code></b><br> 
   Indices for mapping elements of "points_out" to "points_in"; 1-based; Length: <code>[ n_points_in ]</code> 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="ray_mesh_interact"></a>
<b>ray_mesh_interact</b> - Calculates interactions (reflection, transmission, refraction) of radio waves with objects
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">Radio waves that interact with a building, or other objects in the environment, will produce losses 
   that depend on the electrical properties of the materials and material structure. 
</li><li style="margin-bottom: 0.4em;">This function calculates the interactions of radio-waves with objects in a 3D environment. 
</li><li style="margin-bottom: 0.4em;">It considers a plane wave incident upon a planar interface between two homogeneous and isotropic 
   media of differing electric properties. The media extend sufficiently far from the interface such 
   that the effect of any other interface is negligible. 
</li><li style="margin-bottom: 0.4em;">Air to media transition is assumed if front side of a face is hit and FBS != SBS 
</li><li style="margin-bottom: 0.4em;">Media to air transition is assumed if back side of a face is hit and FBS != SBS 
</li><li style="margin-bottom: 0.4em;">Media to media transition is assumed if FBS = SBS with opposing face orientations 
</li><li style="margin-bottom: 0.4em;">Order of the vertices determines side (front or back) of a mesh element 
</li><li style="margin-bottom: 0.4em;">Overlapping geometry in the triangle mesh must be avoided, since materials are transparent to radio 
   waves. 
</li><li style="margin-bottom: 0.4em;">Implementation is done according to ITU-R P.2040-1. 
</li><li style="margin-bottom: 0.4em;">Rays that do not interact with the environment (i.e. for which <code>fbs_ind = 0</code>) are omitted from 
   the output. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Material properties:</i></b><br>Each material is defined by its electrical properties. Radio waves that interact with a building will 
produce losses that depend on the electrical properties of the building materials, the material 
structure and the frequency of the radio wave. The fundamental quantities of interest are the electrical 
permittivity (ϵ) and the conductivity (σ). The five parameters returned in <code>mtl_prop</code> then are: 
 
<ul><li style="margin-bottom: 0.4em;">Real part of relative permittivity at f = 1 GHz (a) 
</li><li style="margin-bottom: 0.4em;">Frequency dependence of rel. permittivity (b) such that ϵ = a · f^b 
</li><li style="margin-bottom: 0.4em;">Conductivity at f = 1 GHz (c) 
</li><li style="margin-bottom: 0.4em;">Frequency dependence of conductivity (d) such that σ = c· f^d 
</li><li style="margin-bottom: 0.4em;">Fixed attenuation in dB applied to each transition 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
[ origN, destN, gainN, xprmatN, trivecN, tridirN, orig_lengthN, fbs_angleN, thicknessN, edge_lengthN, normal_vecN] = ...
    quadriga_lib.ray_mesh_interact(  interaction_type, center_freq, orig, dest, fbs, sbs, mesh, mtl_prop,
    fbs_ind, sbs_ind, trivec, tridir, orig_length );
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>interaction_type</code></b><br> 
   Interaction type: (0) Reflection, (1) Transmission, (2) Refraction 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>center_freq</code></b><br> 
   Center frequency in [Hz]; Scalar value 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>orig</code></b><br> 
   Ray origins in 3D Cartesian coordinates; Size: <code>[ no_ray, 3 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>dest</code></b><br> 
   Ray destinations in 3D Cartesian coordinates; Size: <code>[ no_ray, 3 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>fbs</code></b><br> 
   First interaction point between the rays and the triangular mesh. Size: <code>[ no_ray, 3 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>sbs</code></b><br> 
   Second interaction point between the rays and the triangular mesh. Size: <code>[ no_ray, 3 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>mesh</code></b><br> 
   Vertices of the triangular mesh in global Cartesian coordinates. Each face is described by 3 points 
   in 3D-space. Hence, a face has 9 values in the order [ v1x, v1y, v1z, v2x, v2y, v2z, v3x, v3y, v3z ]; 
   Size: <code>[ no_mesh, 9 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>mtl_prop</code></b><br> 
   Material properties of each mesh element (see above); Size: <code>[ no_mesh, 5 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>fbs_ind</code></b><br> 
   Index of the triangle that was hit by the ray at the FBS location; 1-based; Length: <code>[ no_ray ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>sbs_ind</code></b><br> 
   Index of the triangle that was hit by the ray at the SBS location; 1-based; Length: <code>[ no_ray ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>trivec</code></b> (optional)<br> 
   The 3 vectors pointing from the center point of the ray at the <code>origin</code> to the vertices of a triangular 
   propagation tube, the values are in the order <code>[ v1x, v1y, v1z, v2x, v2y, v2z, v3x, v3y, v3z ]</code>; 
   Size: <code>[ no_ray, 9 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>tridir</code></b> (optional)<br> 
   The directions of the vertex-rays. Size: <code>[ n_ray, 6 ]</code> or <code>[ n_ray, 9 ]</code><br> 
   For 6 columns, values are in geographic coordinates (azimuth and elevation angle in rad); the  
   values are in the order <code>[ v1az, v1el, v2az, v2el, v3az, v3el ]</code>; 
   For 9 columns, the input is in Cartesian coordinates and the values are in the  order  
   <code>[ v1x, v1y, v1z, v2x, v2y, v2z, v3x, v3y, v3z  ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>orig_length</code></b> (optional)<br> 
   Path length at origin point, default is 0, Size: [ n_ray ] 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>origN</code></b><br> 
   New ray origins after the interaction with the medium, usually placed close to the FBS location. 
   A small offset of 0.001 m in the direction of travel after the interaction with the medium is added 
   to avoid getting stuct inside a mesh element. Size: <code>[ no_rayN, 3 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>destN</code></b><br> 
   New ray destinaion after the interaction with the medium, taking the change of direction into account; 
   Size: <code>[ no_rayN, 3 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>gainN</code></b><br> 
   Gain (negative loss) caused by the interaction with the medium, averaged over both polarization 
   directions. This value includes the in-medium attenuation, but does not account for FSPL. Linear scale. 
   Size: <code>[ no_rayN ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>xprmatN</code></b><br> 
   Polarization transfer matrix; 
   Interleaved complex values (ReVV, ImVV, ReVH, ImVH, ReHV, ImHV, ReHH, ImHH); 
   The values account for the following effects: (1) gain caused by the interaction with the medium, 
   (2) different reflection/transmission coefficients for transverse electric (TE) and transverse 
   magnetic (TM) polarisation, (3) orientation of the incidence plane, (4) in-medium attenuation. 
   FSPL is excluded.  Size: <code>[ no_rayN, 8 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>trivecN</code></b><br> 
   The 3 vectors pointing from the center point of the ray at <code>origN</code> to the vertices of a triangular 
   propagation tube.  Size: <code>[ no_rayN, 9 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>tridirN</code></b><br> 
   The directions of the vertex-rays after interaction with the medium;  
   Size: <code>[ no_rayN, 6 ]</code> or <code>[ no_rayN, 9 ]</code> depending on input size 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>orig_lengthN</code></b><br> 
   Length of the ray from <code>orig</code> to <code>origN</code>. If <code>orig_length</code> is given as input, its value is added. 
   Size: <code>[ no_rayN ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>fbs_angleN</code></b><br> 
   Angle between incoming ray and FBS in [rad], Size <code>[ n_rayN ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>thicknessN</code></b><br> 
   Material thickness in meters calculated from the difference between FBS and SBS, Size <code>[ n_rayN ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>edge_lengthN</code></b><br> 
   Max. edge length of the ray tube triangle at the new origin. A value of infinity indicates that only 
   a part of the ray tube hits the object. Size <code>[ n_rayN, 3 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>normal_vecN</code></b><br> 
   Normal vector of FBS and SBS, Size <code>[ n_rayN, 6 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>out_typeN</code></b><br> 
   A numeric indicator describing the type of the interaction. The total refection indicator is only  
   set in refraction mode.<br><br> 
<table style="border-collapse: separate; border-spacing: 20px 0;">
<tr>
  <th>No</th>
  <th>θF<0</th>
  <th>θS<0</th>
  <th>dFS=0</th>
  <th>TotRef</th>
  <th>iSBS=0</th>
  <th>NF=-NS</th>
  <th>NF=NS</th>
  <th>startIn</th>
  <th>endIn</th>
  <th>Meaning</th>
</tr>
<tr>
  <td>0</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td>Undefined</td>
</tr>
<tr>
  <td>1</td>
  <td>no</td>
  <td>N/A</td>
  <td>no</td>
  <td>N/A</td>
  <td>yes</td>
  <td>N/A</td>
  <td>N/A</td>
  <td>no</td>
  <td>yes</td>
  <td>Single Hit o-i</td>
</tr>
<tr>
  <td>2</td>
  <td>yes</td>
  <td>N/A</td>
  <td>no</td>
  <td>no</td>
  <td>yes</td>
  <td>N/A</td>
  <td>N/A</td>
  <td>yes</td>
  <td>no</td>
  <td>Single Hit i-o</td>
</tr>
<tr>
  <td>3</td>
  <td>yes</td>
  <td>N/A</td>
  <td>no</td>
  <td>yes</td>
  <td>yes</td>
  <td>N/A</td>
  <td>N/A</td>
  <td>yes</td>
  <td>no</td>
  <td>Single Hit i-o, TR</td>
</tr>
<tr>
  <td>---</td>
  <td>-----</td>
  <td>------</td>
  <td>-------</td>
  <td>--------</td>
  <td>--------</td>
  <td>--------</td>
  <td>-------</td>
  <td>---------</td>
  <td>-------</td>
  <td>----------------------------</td>
</tr>
<tr>
  <td>4</td>
  <td>no</td>
  <td>yes</td>
  <td>yes</td>
  <td>no</td>
  <td>no</td>
  <td>yes</td>
  <td>no</td>
  <td>yes</td>
  <td>yes</td>
  <td>M2M, M2 hit first</td>
</tr>
<tr>
  <td>5</td>
  <td>yes</td>
  <td>no</td>
  <td>yes</td>
  <td>no</td>
  <td>no</td>
  <td>yes</td>
  <td>no</td>
  <td>yes</td>
  <td>yes</td>
  <td>M2M, M1 hit first</td>
</tr>
<tr>
  <td>6</td>
  <td>yes</td>
  <td>no</td>
  <td>yes</td>
  <td>yes</td>
  <td>no</td>
  <td>yes</td>
  <td>no</td>
  <td>yes</td>
  <td>yes</td>
  <td>M2M, M1 hit first, TR</td>
</tr>
<tr>
  <td>---</td>
  <td>-----</td>
  <td>------</td>
  <td>-------</td>
  <td>--------</td>
  <td>--------</td>
  <td>--------</td>
  <td>-------</td>
  <td>---------</td>
  <td>-------</td>
  <td>----------------------------</td>
</tr>
<tr>
  <td>7</td>
  <td>no</td>
  <td>no</td>
  <td>yes</td>
  <td>N/A</td>
  <td>no</td>
  <td>no</td>
  <td>yes</td>
  <td>no</td>
  <td>yes</td>
  <td>Overlapping Faces, o-i</td>
</tr>
<tr>
  <td>8</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
  <td>yes</td>
  <td>yes</td>
  <td>no</td>
  <td>Overlapping Faces, i-o</td>
</tr>
<tr>
  <td>9</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>no</td>
  <td>no</td>
  <td>yes</td>
  <td>yes</td>
  <td>no</td>
  <td>Overlapping Faces, i-o, TR</td>
</tr>
<tr>
  <td>---</td>
  <td>-----</td>
  <td>------</td>
  <td>-------</td>
  <td>--------</td>
  <td>--------</td>
  <td>--------</td>
  <td>-------</td>
  <td>---------</td>
  <td>-------</td>
  <td>----------------------------</td>
</tr>
<tr>
  <td>10</td>
  <td>no</td>
  <td>yes</td>
  <td>yes</td>
  <td>N/A</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
  <td>Edge Hit, o-i-o</td>
</tr>
<tr>
  <td>11</td>
  <td>yes</td>
  <td>no</td>
  <td>yes</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
  <td>yes</td>
  <td>yes</td>
  <td>Edge Hit, i-o-i</td>
</tr>
<tr>
  <td>12</td>
  <td>yes</td>
  <td>no</td>
  <td>yes</td>
  <td>yes</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
  <td>yes</td>
  <td>yes</td>
  <td>Edge Hit, i-o-i, TR</td>
</tr>
<tr>
  <td>13</td>
  <td>no</td>
  <td>no</td>
  <td>yes</td>
  <td>N/A</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
  <td>yes</td>
  <td>Edge Hit, o-i</td>
</tr>
<tr>
  <td>14</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
  <td>yes</td>
  <td>no</td>
  <td>Edge Hit, i-o</td>
</tr>
<tr>
  <td>15</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
  <td>yes</td>
  <td>no</td>
  <td>Edge Hit, i-o, TR</td>
</tr>
</table><br>
    
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="ray_point_intersect"></a>
<b>ray_point_intersect</b> - Calculates the intersection of ray beams with points in three dimensions
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>Unlike traditional ray tracing, where rays do not have a physical size, beam tracing models rays as  
beams with volume. Beams are defined by triangles whose vertices diverge as the beam extends. This  
approach is used to simulate a kind of divergence or spread in the beam, reminiscent of how radio  
waves spreads as they travel from a point source. The volumetric nature of the beams allows for more  
realistic modeling of energy distribution. As beams widen, the energy they carry can be distributed  
across their cross-sectional area, affecting the intensity of the interaction with surfaces. 
Unlike traditional ray tracing where intersections are line-to-geometry tests, beam tracing requires  
volumetric intersection tests. 
 
Ray beams are determined by an origin point, three vectors pointing from the origin to the three  
vertices of a triangle that defines the shape of the tube and the three direction of the rays at  
the vertices.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
[ hit_count, ray_ind ] = quadriga_lib.ray_point_intersect( orig, trivec, tridir, points, ...
    max_no_hit, sub_cloud_index, target_size );
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>orig</code></b><br> 
   Ray origins in 3D Cartesian coordinates; Size: <code>[ no_ray, 3 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>trivec</code></b><br> 
   The 3 vectors pointing from the center point of the ray at the ray <code>origin</code> to the vertices of  
   a triangular propagation tube (the beam), the values are in the order  
   <code>[ v1x, v1y, v1z, v2x, v2y, v2z, v3x, v3y, v3z ]</code>; Size: <code>[ no_ray, 9 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>tridir</code></b><br> 
   The directions of the vertex-rays. Size: <code>[ n_ray, 9 ]</code>, Values must be given in Cartesian  
   coordinates in the order  <code>[ d1x, d1y, d1z, d2x, d2y, d2z, d3x, d3y, d3z  ]</code>; The vector does 
   not need to be normalized. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>points</code></b><br> 
   Points in 3D-Cartesian space; Size: <code>[ n_points_in, 3 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>max_no_hit</code></b> (optional)<br> 
   Max. number of hits in the output <code>ray_ind</code>, default = 32 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>sub_cloud_index</code></b> (optional)<br> 
   Start indices of the sub-clouds in 0-based notation. Type: uint32; Vector of length <code>[ n_sub_cloud ]</code>  
   If this optional input is not given, the sub-could index is calculated automatically. Passing a 
   value of <code>uint32(0)</code> will disable the sub-cloud calculation.  
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>target_size</code></b> (optional)<br> 
   Target value for the sub-cloud size, only evaluated if 'sub_cloud_index' is not given. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>hit_count</code></b><br> 
   Number of rays that hit a point, unit32, Length: <code>[ n_points ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>ray_ind</code></b><br> 
   Ray indices that hit the points, 1-based, 0 = no hit, Size <code>[ n_points, max_no_hit ]</code> 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="ray_triangle_intersect"></a>
<b>ray_triangle_intersect</b> - Calculates the intersection of rays and triangles in three dimensions
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br><ul><li style="margin-bottom: 0.4em;">This function implements the Möller–Trumbore ray-triangle intersection algorithm, known for its 
   efficiency in calculating the intersection of a ray and a triangle in three-dimensional space. 
   This method achieves its speed by eliminating the need for precomputed plane equations of the plane 
   containing the triangle. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;">For further information, refer to [Wikipedia: <a href="https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm">Möller–Trumbore intersection algorithm</a>]. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;">The algorithm defines the ray using two points: an origin and a destination. Similarly, the triangle 
   is specified by its three vertices. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;">To enhance performance, this implementation leverages AVX2 intrinsic functions and OpenMP, when 
   available, to speed up the computational process. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
[ fbs, sbs, no_interact, fbs_ind, sbs_ind ] = quadriga_lib.ray_triangle_intersect( orig, dest, mesh );
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>orig</code></b><br> 
   Ray origins in 3D Cartesian coordinates; Size: <code>[ no_ray, 3 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>dest</code></b><br> 
   Ray destinations in 3D Cartesian coordinates; Size: <code>[ no_ray, 3 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>mesh</code></b><br> 
   Vertices of the triangular mesh in global Cartesian coordinates. Each face is described by 3 points 
   in 3D-space. Hence, a face has 9 values in the order [ v1x, v1y, v1z, v2x, v2y, v2z, v3x, v3y, v3z ]; <br> 
   Size: <code>[ no_mesh, 9 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>sub_mesh_index</code></b> (optional)<br> 
   Start indices of the sub-meshes in 0-based notation. If this parameter is not given, intersections 
   are calculated for each mesh element, leading to poor performance for large meshed.  
   Type: uint32; Vector of length <code>[ n_sub_mesh ]</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>fbs</code></b><br> 
   First interaction point between the rays and the triangular mesh. If no interaction was found, the 
   FBS location is equal to <code>dest</code>. Size: <code>[ no_ray, 3 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>sbs</code></b><br> 
   Second interaction point between the rays and the triangular mesh. If no interaction was found, the 
   SBS location is equal to <code>dest</code>. Size: <code>[ no_ray, 3 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>no_interact</code></b><br> 
   Total number of interactions between the origin point and the destination; uint32; Length: <code>[ no_ray ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>fbs_ind</code></b><br> 
   Index of the triangle that was hit by the ray at the FBS location; 1-based; uint32; Length: <code>[ no_ray ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>sbs_ind</code></b><br> 
   Index of the triangle that was hit by the ray at the SBS location; 1-based; uint32; Length: <code>[ no_ray ]</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Caveat:</i></b><br><ul><li style="margin-bottom: 0.4em;"><code>orig</code>, <code>dest</code>, and <code>mesh</code> can be provided in single or double precision; <code>fbs</code> and <code>lbs</code> will have 
   the same type. 
</li><li style="margin-bottom: 0.4em;">All internal computation are done in single precision to achieve an additional 2x improvement in 
   speed compared to double precision when using AVX2 intrinsic instructions 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="subdivide_triangles"></a>
<b>subdivide_triangles</b> - Subdivide the faces of a triangle mesh into smaller faces
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>This function splits the triangles of a mesh into smaller triangles by subdividing the edges 
into <code>n_div</code> sub-edges. This creates <code>n_div^2</code> sub-faces per face.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
triangles_out = quadriga_lib.subdivide_triangles( triangles_in, no_div );
[ triangles_out, mtl_prop_out ] = quadriga_lib.subdivide_triangles( triangles_in, no_div, mtl_prop_in );
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>triangles_in</code></b><br> 
   Vertices of the triangular mesh in global Cartesian coordinates. Each face is described by 3 
   points in 3D-space: <code>[ v1x, v1y, v1z, v2x, v2y, v2z, v3x, v3y, v3z ]</code>; single or double precision; 
   <br>Size: <code>[ n_triangles_in, 9 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>no_div</code></b><br> 
   Number of divisions per edge of the input mesh. The resulting number of faces is equal to 
   <code>n_triangles_out = n_triangles_in * n_div^2</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>mtl_prop_in</code></b> (optional)<br> 
   Material properties of each mesh element; Size: <code>[ n_triangles_in, 5 ]</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>triangles_out</code></b><br> 
   Vertices of the sub-divided mesh in global Cartesian coordinates; singe or double precision; 
   <br>Size: <code>[ n_triangles_out, 9 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>mtl_prop_out</code></b><br> 
   Material properties for the sub-divided triangle mesh elements. The values for the new faces are  
   copied from <code>mtl_prop_in</code>; Size: <code>[ n_triangles_out, 5 ]</code> 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="triangle_mesh_aabb"></a>
<b>triangle_mesh_aabb</b> - Calculate the axis-aligned bounding box (AABB) of a triangle mesh and its sub-meshes
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>The axis-aligned minimum bounding box (or AABB) for a given set of triangles is its minimum 
bounding box subject to the constraint that the edges of the box are parallel to the (Cartesian) 
coordinate axes. Axis-aligned bounding boxes are used as an approximate location of the set of 
triangles. In order to find intersections with the triangles (e.g. using ray tracing), the 
initial check is the intersections between the rays and the AABBs. Since it is usually a much 
less expensive operation than the check of the actual intersection (because it only requires 
comparisons of coordinates), it allows quickly excluding checks of the pairs that are far apart.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
aabb = quadriga_lib.subdivide_triangles( triangle_mesh, sub_mesh_index, vec_size );
</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>triangles</code></b><br> 
   Vertices of the triangle mesh in global Cartesian coordinates. Each face is described by 3 
   points in 3D-space: <code>[ v1x, v1y, v1z, v2x, v2y, v2z, v3x, v3y, v3z ]</code>; single or double precision; 
   Size: <code>[ n_triangles, 9 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>sub_mesh_index</code></b> (optional)<br> 
   Start indices of the sub-meshes in 0-based notation. If this parameter is not given, the AABB of 
   the entire triangle mesh is returned. Type: uint32; Vector of length <code>[ n_sub_mesh ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>vec_size</code></b> (optional)<br> 
   Vector size for SIMD processing (e.g. 8 for AVX2, 32 for CUDA). Default value = 1. For values > 1, 
   the number of rows in the output is increased to a multiple of <code>vec_size</code>, padded with zeros. 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Argument:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>aabb</code></b><br> 
   Axis-aligned bounding box of each sub-mesh. Each box is described by 6 values: 
   <code>[ x_min, x_max, y_min, y_max, z_min, z_max ]</code>; Size: <code>[ n_sub_mesh, 6 ]</code> 
</li></ul>
</li>
</ul>
<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="triangle_mesh_segmentation"></a>
<b>triangle_mesh_segmentation</b> - Rearranges elements of a triangle mesh into smaller sub-meshes
<ul>
<li style="margin-bottom: 1.5em;">
<b><i>Description:</i></b><br>This function processes the elements of a large triangle mesh by clustering those that are  
closely spaced. The resulting mesh retains the same elements but rearranges their order.  
The function aims to minimize the size of the axis-aligned bounding box around each cluster,  
referred to as a sub-mesh, while striving to maintain a specific number of elements within  
each cluster. 
 
This approach is particularly useful in computer graphics and simulation applications where  
managing computational resources efficiently is crucial. By organizing the mesh elements into  
compact clusters, the function enhances rendering performance and accelerates computational  
tasks, such as collision detection and physics simulations. It allows for quicker processing  
and reduced memory usage, making it an essential technique in both real-time graphics rendering  
and complex simulation environments.
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Usage:</i></b><br><pre>
[ triangles_out, sub_mesh_index, mesh_index ] = quadriga_lib.triangle_mesh_segmentation( ...
    triangles_in, target_size, vec_size );

[ triangles_out, sub_mesh_index, mesh_index, mtl_prop_out ] = ...
     quadriga_lib.triangle_mesh_segmentation( triangles_in, target_size, vec_size, mtl_prop_in );

</pre>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Input Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>triangles_in</code></b><br> 
   Vertices of the triangular mesh in global Cartesian coordinates. Each face is described by 3 
   points in 3D-space: <code>[ v1x, v1y, v1z, v2x, v2y, v2z, v3x, v3y, v3z ]</code>; single or double precision; 
   Size: <code>[ n_triangles_in, 9 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>target_size</code></b> (optional)<br> 
   The target number of elements of each sub-mesh. Default value = 1024. For best performance, the  
   value should be around sgrt( n_triangles_in ) 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>vec_size</code></b> (optional)<br> 
   Vector size for SIMD processing (e.g. 8 for AVX2, 32 for CUDA). Default value = 1.  
   For values > 1,the number of rows for each sub-mesh in the output is increased to a multiple  
   of <code>vec_size</code>. For padding, zero-sized triangles are placed at the center of the AABB of  
   the corresponding sub-mesh. 
    
</li><li style="margin-bottom: 0.4em;"><b><code>mtl_prop_in</code></b> (optional)<br> 
   Material properties of each mesh element; Size: <code>[ n_triangles_in, 5 ]</code> 
</li></ul>
</li>
<li style="margin-bottom: 1.5em;">
<b><i>Output Arguments:</i></b><br><ul><li style="margin-bottom: 0.4em;"><b><code>triangles_out</code></b><br> 
   Vertices of the clustered mesh in global Cartesian coordinates; singe or double precision; 
   Size: <code>[ n_triangles_out, 9 ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>sub_mesh_index</code></b><br> 
   Start indices of the sub-meshes in 0-based notation. Type: uint32; Vector of length <code>[ n_sub_mesh ]</code> 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>mesh_index</code></b><br> 
   Indices for mapping elements of "triangles_in" to "triangles_out"; 1-based;  
   Length: <code>[ n_triangles_out ]</code>; For <code>vec_size > 1</code>, the added elements not contained in the input 
   are indicated by zeros. 
</li></ul>
 
<ul><li style="margin-bottom: 0.4em;"><b><code>mtl_prop_out</code></b><br> 
   Material properties for the sub-divided triangle mesh elements. The values for the new faces are  
   copied from <code>mtl_prop_in</code>; Size: <code>[ n_triangles_out, 5 ]</code>; For <code>vec_size > 1</code>, the added elements 
   will contain the vacuum / air material. 
</li></ul>
</li>
</ul>
    <!-- CONTENT END -->

    <br>
    <!-- <br> -->

    <div id="quadriga-lib_sf_line"></div>

  </div>

</body>

</html>